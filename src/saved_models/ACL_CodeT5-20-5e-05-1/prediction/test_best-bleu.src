{"source": "the value of this attribute if this attribute is present in the map . otherwise # get default value ( ) <s> public long get ( with attributes attributes ) { return attributes . get attributes ( ) . get ( this ) ; } <s> public long get ( with attributes with attributes ) { return with attributes . get attributes ( ) . get ( this ) ; }"}
{"source": "the requested graph item , or null if the graph item wasn ' t found and the create parameter is false . <s> public synchronized graph item get item ( string item class , entity entity , boolean create ) { item entry entry = ( item entry ) m _ entry map . get ( item class ) ; if ( entry ! = null ) { graph item item = ( graph item ) entry . item map . get ( entity ) ; if ( ! create ) { return item ; } else if ( item = = null ) { item = m _ ifactory . get item ( item class ) ; item . init ( this , item class , entity ) ; add item ( entry , entity , item ) ; } if ( item instanceof node item ) ( ( node item ) item ) . remove all neighbors ( ) ; item . set dirty ( num ) ; item . set visible ( true ) ; return item ; } else { throw new illegal argument exception ( str + str ) ; } } <s> public synchronized visual item get item ( string item class , entity entity , boolean create ) { item entry entry = ( item entry ) m _ entry map . get ( item class ) ; if ( entry ! = null ) { visual item item = ( visual item ) entry . item map . get ( entity ) ; if ( ! create ) { return item ; } else if ( item = = null ) { item = m _ ifactory . get item ( item class ) ; item . init ( this , item class , entity ) ; add item ( entry , entity , item ) ; } if ( item instanceof node item ) ( ( node item ) item ) . remove all neighbors ( ) ; item . set dirty ( num ) ; item . set visible ( true ) ; return item ; } else { throw new illegal argument exception ( str + str ) ; } }"}
{"source": "the new vertex edges data structure . <s> public vertex edges < i , e > unwrap ( ) { if ( current edge ! = null ) { new edges . add ( current edge ) ; current edge = null ; } while ( old edges iterator . has next ( ) ) { new edges . add ( old edges iterator . next ( ) ) ; } return new edges ; } <s> public out edges < i , e > unwrap ( ) { if ( current edge ! = null ) { new edges . add ( current edge ) ; current edge = null ; } while ( old edges iterator . has next ( ) ) { new edges . add ( old edges iterator . next ( ) ) ; } return new edges ; }"}
{"source": "for an assignment or variable declaration return the assigned value , otherwise null . <s> node get assigned value ( ) { return node util . get assigned value ( get name node ( ) ) ; } <s> node get assigned value ( ) { return ( parent . get type ( ) = = token . function ) ? parent : node util . get assigned value ( get name node ( ) ) ; }"}
{"source": "the dcc file transfer that can be used to monitor this transfer . <s> public dcc file transfer dcc send file ( file file , user reciever , int timeout ) throws ioexception { if ( file = = null ) throw new illegal argument exception ( str ) ; if ( reciever = = null ) throw new illegal argument exception ( str ) ; dcc file transfer transfer = new dcc file transfer ( this , file , reciever , timeout ) ; transfer . do send ( true ) ; return transfer ; } <s> public send file transfer dcc send file ( file file , user reciever , int timeout ) throws ioexception { return dcc handler . send file ( file , reciever , timeout ) ; }"}
{"source": "the maximum length of the string . <s> public final int get max length ( ) { return max length ; } <s> public integer get max length ( ) { return max length ; }"}
{"source": "the full xml rpc file manager client built from the cas curator property filemgr . url . <s> public xml rpc file manager client get file manager client ( ) { try { return new xml rpc file manager client ( new url ( this . get file mgr url ( ) ) ) ; } catch ( exception e ) { log . log ( level . severe , e . get message ( ) ) ; return null ; } } <s> public file manager client get file manager client ( ) { try { return rpc communication factory . create client ( new url ( this . get file mgr url ( ) ) ) ; } catch ( exception e ) { log . log ( level . severe , e . get message ( ) ) ; return null ; } }"}
{"source": "a map of the first two columns . ( first column = > second column ) <s> public sorted map < string , string > get origin tab contents as strings ( ) { open tab ( tab . origin ) ; return map table cells key value ( string . class , get visible table rows ( true , true ) , num ) ; } <s> public sorted map < string , string > get origin tab contents as strings ( final origin selected column ) { open tab ( tab . origin ) ; return map table cells key value ( string . class , get visible table rows ( true , false ) , selected column . column ) ; }"}
{"source": "# format key ( string , boolean , boolean , boolean ) format at = true , format colon = false , format hyphen = false , first case = false <s> public static string format other key ( string full name ) { return format key ( full name , true , false , false , false ) ; } <s> public static string format other key ( string full name ) { return format key ( full name , false , true , false , false ) ; }"}
{"source": "the allowed read scopes <s> public list < string > read scopes ( ) { return read scopes ; } <s> @ deprecated public list < string > read scopes ( ) { return sentinel _ empty _ scopes ; }"}
{"source": "the stored value or null if it doesn ' t exist in specified form . <s> public double get extra long ( string key ) { return m extra data . opt long ( key ) ; } <s> public long get extra long ( string key ) throws jsonexception { return m extra data . get long ( key ) ; }"}
{"source": "default value as string representation <s> public fx string get default value ( ) { return default value ; } <s> public fx value get default value ( ) { if ( default value = = null ) default value = get empty value ( ) ; return default value ; }"}
{"source": "score for that day <s> public int get value ( long timestamp ) { compute all ( ) ; string [ ] args = { habit . get id ( ) . to string ( ) , long . to string ( timestamp ) } ; return sqlite utils . int query ( str , args ) ; } <s> public final double get value ( long timestamp ) { compute ( timestamp , timestamp ) ; score s = get computed by timestamp ( timestamp ) ; if ( s = = null ) throw new illegal state exception ( ) ; return s . get value ( ) ; }"}
{"source": "a string object for title items and a device admin info object for actual device admins . <s> @ override public object get item ( int position ) { if ( position < num ) { throw new array index out of bounds exception ( ) ; } int admin position = position ; final int n = m admins by profile . size ( ) ; int i = num ; for ( ; i < n ; + + i ) { final int list size = m admins by profile . value at ( i ) . size ( ) + num ; if ( admin position < list size ) { break ; } admin position - = list size ; } if ( i = = n ) { throw new array index out of bounds exception ( ) ; } if ( admin position = = num ) { resources res = get activity ( ) . get resources ( ) ; if ( m admins by profile . key at ( i ) = = user handle . my user id ( ) ) { return res . get string ( r . string . personal _ device _ admin _ title ) ; } else { return res . get string ( r . string . managed _ device _ admin _ title ) ; } } else { return m admins by profile . value at ( i ) . get ( admin position - num ) ; } } <s> @ override public object get item ( int position ) { return ( ( device admin list item ) ( m admins . get ( position ) ) ) . info ; }"}
{"source": "if reached , return true ; else , return false . <s> public static boolean exceeds max count ( ) { return m test count > = max _ test _ count ; } <s> public static boolean exceeds max count ( ) { final long max test count = host config . get max test count ( ) ; return ( max test count > num ) & & ( m test count > = max test count ) ; }"}
{"source": "a new sequence service with the default server url <s> public sequence service create sequence service ( ) { return create sequence service ( default server url ) ; } <s> public sequence service create sequence service ( ) { return create sequence service ( default endpoint url ) ; }"}
{"source": "the latest loaded lsn . <s> public lsn restart ( ) throws babu dbexception { database manager . reset ( ) ; db checkptr = new checkpointer impl ( this ) ; lsn db lsn = null ; lsn zero = new lsn ( num , num ) ; for ( database db raw : database manager . get database list ( ) ) { database impl db = ( database impl ) db raw ; lsn on disk = db . get lsmdb ( ) . get ondisk lsn ( ) ; if ( db lsn = = null & & ! on disk . equals ( zero ) ) db lsn = on disk ; else if ( db lsn ! = null ) { if ( ! on disk . equals ( zero ) & & ! db lsn . equals ( on disk ) ) throw new runtime exception ( str + db lsn . to string ( ) + str + db . get lsmdb ( ) . get ondisk lsn ( ) . to string ( ) ) ; } } if ( db lsn = = null ) { db lsn = new lsn ( num , num ) ; } else { db lsn = new lsn ( db lsn . get view id ( ) , db lsn . get sequence no ( ) + num ) ; } logging . log message ( logging . level _ info , this , str ) ; lsn next lsn = replay logs ( db lsn ) ; if ( db lsn . compare to ( next lsn ) > num ) { next lsn = db lsn ; } logging . log message ( logging . level _ info , this , str + next lsn ) ; try { logger = new disk logger ( configuration . get db log dir ( ) , next lsn . get view id ( ) , next lsn . get sequence no ( ) + num , configuration . get sync mode ( ) , configuration . get pseudo sync wait ( ) , configuration . get max queue length ( ) * configuration . get num threads ( ) ) ; logger . start ( ) ; } catch ( ioexception ex ) { throw new babu dbexception ( error code . io _ error , str , ex ) ; } worker = new lsmdbworker [ configuration . get num threads ( ) ] ; for ( int i = num ; i < configuration . get num threads ( ) ; i + + ) { worker [ i ] = new <s> public lsn restart ( ) throws babu dbexception { if ( ! this . stopped ) throw new babu dbexception ( error code . io _ error , str ) ; database manager . reset ( ) ; db checkptr = new checkpointer impl ( this ) ; lsn db lsn = null ; lsn zero = new lsn ( num , num ) ; for ( database db raw : database manager . get database list ( ) ) { database impl db = ( database impl ) db raw ; lsn on disk = db . get lsmdb ( ) . get ondisk lsn ( ) ; if ( db lsn = = null & & ! on disk . equals ( zero ) ) db lsn = on disk ; else if ( db lsn ! = null ) { if ( ! on disk . equals ( zero ) & & ! db lsn . equals ( on disk ) ) throw new runtime exception ( str + db lsn . to string ( ) + str + db . get lsmdb ( ) . get ondisk lsn ( ) . to string ( ) ) ; } } if ( db lsn = = null ) { db lsn = new lsn ( num , num ) ; } else { db lsn = new lsn ( db lsn . get view id ( ) , db lsn . get sequence no ( ) + num ) ; } logging . log message ( logging . level _ info , this , str ) ; lsn next lsn = replay logs ( db lsn ) ; if ( db lsn . compare to ( next lsn ) > num ) { next lsn = db lsn ; } logging . log message ( logging . level _ info , this , str + next lsn ) ; try { logger = new disk logger ( configuration . get db log dir ( ) , next lsn . get view id ( ) , next lsn . get sequence no ( ) + num , configuration . get sync mode ( ) , configuration . get pseudo sync wait ( ) , configuration . get max queue length ( ) * configuration . get num threads ( ) ) ; logger . start ( ) ; } catch ( ioexception ex ) { throw new babu dbexception ( error code . io _ error , str , ex ) ; } worker = new lsmdbworker [ configuration . get num threads ( ) ] ; for ( int i"}
{"source": "value between 1 and 16 , 777 , 215 <s> public int get position ( ) { return this . current position ; } <s> public int get position ( ) { return current position ; }"}
{"source": "true if changes are visible for the result set type <s> public boolean own updates are visible ( int type ) { return false ; } <s> public boolean own updates are visible ( int type ) { if ( type = = jdbc20 translation . type _ scroll _ insensitive ) { return true ; } else { return false ; } }"}
{"source": "whether a new access token was successfully retrieved <s> protected token response execute refresh token ( ) throws ioexception { return new refresh token request ( transport , json factory , new generic url ( token server encoded url ) , refresh token ) . set client authentication ( client authentication ) . set request initializer ( request initializer ) . execute ( ) ; } <s> protected token response execute refresh token ( ) throws ioexception { if ( refresh token = = null ) { return null ; } return new refresh token request ( transport , json factory , new generic url ( token server encoded url ) , refresh token ) . set client authentication ( client authentication ) . set request initializer ( request initializer ) . execute ( ) ; }"}
{"source": "string buffer filled with the plain text form of all sentences in the matches panel <s> public string buffer get matched sentences ( ) { string buffer sb = new string buffer ( ) ; for ( int i = num ; i < list . get model ( ) . get size ( ) ; i + + ) { string t = ( ( tree from file ) list . get model ( ) . get element at ( i ) ) . get label ( ) . get text ( ) ; sb . append ( t ) ; sb . append ( str ) ; } return sb ; } <s> public string get matched sentences ( ) { string builder sb = new string builder ( ) ; for ( int i = num , sz = list . get model ( ) . get size ( ) ; i < sz ; i + + ) { string t = list . get model ( ) . get element at ( i ) . get label ( ) . get text ( ) ; sb . append ( t ) ; sb . append ( str ) ; } return sb . to string ( ) ; }"}
{"source": "a non - null object iterating over no nulls . <s> public iterable < document request > get document requests ( ) { throw new unsupported operation exception ( str ) ; } <s> public iterable < document request > get document requests ( ) { return document requests ; }"}
{"source": "the last time the trigger will fire . <s> public date get final fire time ( ) { date final time = null ; java . util . calendar curr cal = java . util . calendar . get instance ( ) ; curr cal . set time ( this . end time ) ; while ( ( final time = = null ) & & ( this . start time . before ( curr cal . get time ( ) ) ) ) { curr cal . add ( java . util . calendar . date , - num ) ; final time = get fire time after ( curr cal . get time ( ) ) ; } return final time ; } <s> public date get final fire time ( ) { if ( end time = = null ) return null ; date final time = null ; java . util . calendar curr cal = java . util . calendar . get instance ( ) ; curr cal . set time ( this . end time ) ; while ( ( final time = = null ) & & ( this . start time . before ( curr cal . get time ( ) ) ) ) { curr cal . add ( java . util . calendar . date , - num ) ; final time = get fire time after ( curr cal . get time ( ) ) ; } return final time ; }"}
{"source": "the conditions <s> public list < workflow condition > get conditions ( ) { return conditions ; } <s> @ deprecated public list < workflow condition > get conditions ( ) { list < workflow condition > all conds = new vector < workflow condition > ( ) ; all conds . add all ( pre conditions ) ; all conds . add all ( this . post conditions ) ; return all conds ; }"}
{"source": "the name of the main character of a user . returns null if not found . <s> public string get main character for user in guild ( user user , guild guild ) { mongo collection < document > collection = get bot ( ) . get mongo database ( ) . get collection ( mongo _ wow _ characters _ collection ) ; document document = collection . find ( and ( eq ( str , user . get id ( ) ) , eq ( str , guild . get id ( ) ) ) ) . first ( ) ; return document ! = null ? document . get string ( str ) : null ; } <s> public jsonobject get main character for user in guild ( user user , guild guild ) { jsonobject character = null ; http url url = new http url . builder ( ) . scheme ( str ) . host ( get bot ( ) . get bot settings ( ) . get property ( str ) ) . add path segments ( str + user . get id ( ) + str + guild . get id ( ) ) . build ( ) ; request request = new request . builder ( ) . url ( url ) . build ( ) ; try { response response = client . new call ( request ) . execute ( ) ; jsonobject json object = new jsonobject ( response . body ( ) . source ( ) ) ; character = json object . length ( ) > num ? json object : null ; } catch ( ioexception e ) { e . print stack trace ( ) ; } return character ; }"}
{"source": "the insets object <s> public insets get border insets ( component c , insets insets ) { if ( this . insets ! = null ) { if ( insets = = null ) { insets = new insets ( this . insets . top , this . insets . left , this . insets . bottom , this . insets . right ) ; } else { insets . top = this . insets . top ; insets . bottom = this . insets . bottom ; insets . left = this . insets . left ; insets . right = this . insets . right ; } } else if ( insets = = null ) { insets = new insets ( num , num , num , num ) ; } else { insets . top = insets . bottom = insets . left = insets . right = num ; } if ( c instanceof jcomponent ) { region region = region . get region ( ( jcomponent ) c ) ; insets margin = null ; if ( ( region = = region . arrow _ button | | region = = region . button | | region = = region . check _ box | | region = = region . check _ box _ menu _ item | | region = = region . menu | | region = = region . menu _ item | | region = = region . radio _ button | | region = = region . radio _ button _ menu _ item | | region = = region . toggle _ button ) & & ( c instanceof abstract button ) ) { margin = ( ( abstract button ) c ) . get margin ( ) ; } else if ( ( region = = region . editor _ pane | | region = = region . formatted _ text _ field | | region = = region . password _ field | | region = = region . text _ area | | region = = region . text _ field | | region = = region . text _ pane ) & & ( c instanceof jtext component ) ) { margin = ( ( jtext component ) c ) . get margin ( ) ; } else if ( region = = region . tool _ bar & & ( c instanceof jtool bar ) ) { margin = ( ( jtool bar ) c ) . get margin ( ) ; } else if ( region = = region . menu _ bar & & ( c instanceof jmenu bar ) ) { margin = ( ( jmenu bar ) c ) . get margin ( ) ; } if ( margin ! = null ) { insets . top + = margin . top ; insets . <s> public insets get border insets ( component c ) { return get border insets ( c , null ) ; }"}
{"source": "sdp content <s> private string build add video sdp proposal ( ) { if ( logger . is activated ( ) ) { logger . info ( str ) ; } string sdp = str ; try { if ( ( get video player ( ) = = null ) | | ( get video player ( ) . get media codec ( ) = = null ) ) { handle error ( new ipcall error ( ipcall error . unsupported _ video _ type , str ) ) ; } else if ( ( get video renderer ( ) = = null ) | | ( get video renderer ( ) . get media codec ( ) = = null ) ) { handle error ( new ipcall error ( ipcall error . unsupported _ video _ type , str ) ) ; } else { string ntp time = sip utils . construct ntptime ( system . current time millis ( ) ) ; string ip address = get dialog path ( ) . get sip stack ( ) . get local ip address ( ) ; logger . warn ( str ) ; get audio player ( ) . get local rtp port ( ) ; string audio sdp = audio sdp builder . build sdp ( get audio player ( ) . get supported audio codecs ( ) , get audio player ( ) . get local rtp port ( ) ) ; logger . warn ( str ) ; string video sdp ; video sdp = video sdp builder . build sdp with orientation extension ( get video player ( ) . get supported media codecs ( ) , get video player ( ) . get local rtp port ( ) ) ; sdp = str + sip utils . crlf + str + ntp time + str + ntp time + str + sdp utils . format address type ( ip address ) + sip utils . crlf + str + sip utils . crlf + str + sdp utils . format address type ( ip address ) + sip utils . crlf + str + sip utils . crlf + audio sdp + str + sip utils . crlf + video sdp + str + sip utils . crlf ; } } catch ( remote exception e ) { if ( logger . is activated ( ) ) { logger . error ( str , e ) ; } handle error ( new ipcall error ( ipcall error . unexpected _ exception , e . get message ( ) ) ) ; } return sdp ; } <s> private string build add video sdp proposal ( ) { if ( logger . is activated ( ) ) { logger . debug ( str ) ; } try { string ntp time = sip utils . construct ntptime ( system . current time millis ( ) ) ; string ip address = get dialog path ( ) . get sip stack ( ) . get local ip address ( ) ; get audio player ( ) . get local rtp port ( ) ; string audio sdp = audio sdp builder . build sdp offer ( get audio player ( ) . get supported audio codecs ( ) , get audio player ( ) . get local rtp port ( ) ) ; string video sdp ; video sdp = video sdp builder . build sdp offer with orientation ( get video player ( ) . get supported video codecs ( ) , get video player ( ) . get local rtp port ( ) ) ; return str + sip utils . crlf + str + ntp time + str + ntp time + str + sdp utils . format address type ( ip address ) + sip utils . crlf + str + sip utils . crlf + str + sdp utils . format address type ( ip address ) + sip utils . crlf + str + sip utils . crlf + audio sdp + str + sip utils . crlf + video sdp + str + sip utils . crlf ; } catch ( remote exception e ) { if ( logger . is activated ( ) ) { logger . error ( str , e ) ; } handle error ( new ipcall error ( ipcall error . unexpected _ exception , e . get message ( ) ) ) ; return null ; } }"}
{"source": "the dir context <s> public static ldap context create path context ( ldap context ldap context , string [ ] path tokens ) throws naming exception { for ( int i = num ; i < ( path tokens . length ) ; i + + ) { string sub context = cn + str + path tokens [ i ] ; ldap context = ( ldap context ) create sub context ( ldap context , sub context , null ) ; } return ldap context ; } <s> public static ldap context create path context ( ldap context authority context , string [ ] path tokens ) throws naming exception { for ( int i = num ; i < ( path tokens . length ) ; i + + ) { string sub context = cn + str + path tokens [ i ] ; authority context = ( ldap context ) create sub context ( authority context , sub context , null ) ; } return authority context ; }"}
{"source": "menu placed under specified control <s> public menu get control menu ( final control c ) { menu menu = display . sync exec ( new result runnable < menu > ( ) { @ override public menu run ( ) { menu m = c . get menu ( ) ; return m ; } } ) ; if ( menu = = null ) { throw new core layer exception ( c . get class ( ) + str ) ; } return menu ; } <s> public menu get control menu ( final control c ) { menu control menu = control handler . get instance ( ) . get menu ( c ) ; if ( control menu = = null ) { throw new core layer exception ( c . get class ( ) + str ) ; } return control menu ; }"}
{"source": "the offline player by the name of the raw arg <s> public offline player as offline player ( ) { return bukkit . get offline player ( arg ) ; } <s> public offline player as offline player ( ) { return bukkit . get offline player ( raw ) ; }"}
{"source": "the report task <s> public reports task create reports task ( ) { return new reports task ( url ) ; } <s> public incidents task create reports task ( ) { return new incidents task ( url ) ; }"}
{"source": "an object name based on the given key <s> public static object name as object name ( object key ) throws malformed object name exception { if ( key = = null ) { throw new null pointer exception ( str ) ; } if ( key instanceof object name ) { return ( object name ) key ; } if ( key instanceof class ) { class clazz = ( class ) key ; return new object name ( str + clazz . get name ( ) ) ; } else { string text = key . to string ( ) ; if ( text . index of ( str ) = = - num ) { text = str + text ; } return new object name ( text ) ; } } <s> private static object name as object name ( object component key ) throws malformed object name exception { if ( component key = = null ) { throw new null pointer exception ( str ) ; } if ( component key instanceof object name ) { return ( object name ) component key ; } if ( component key instanceof class ) { class clazz = ( class ) component key ; return new object name ( str + clazz . get name ( ) ) ; } else { string text = component key . to string ( ) ; if ( text . index of ( str ) = = - num ) { text = str + text ; } return new object name ( text ) ; } }"}
{"source": "the source range of \" word pattern \" in # result code . <s> private source range get result range ( string word pattern ) { int offset = result code . index of ( word pattern ) ; assert that ( offset ) . described as ( word pattern + str + result code ) . is positive ( ) ; string word = string utils . substring before ( word pattern , str ) ; return new source range ( offset , word . length ( ) ) ; } <s> private source range get result range ( string ident pattern ) { int offset = result code . index of ( ident pattern ) ; assert that ( offset ) . described as ( ident pattern + str + result code ) . is positive ( ) ; string identifier = ident pattern . substring ( num , not _ identifier _ matcher . index in ( ident pattern ) ) ; return new source range ( offset , identifier . length ( ) ) ; }"}
{"source": "the derobject <s> private derobject to asn1 object ( x509 certificate cert ) throws certificate encoding exception { try { return new asn1 input stream ( cert . get encoded ( ) ) . read object ( ) ; } catch ( exception e ) { throw new certificate encoding exception ( str + e . to string ( ) ) ; } } <s> private asn1 object to asn1 object ( x509 certificate cert ) throws certificate encoding exception { try { return new asn1 input stream ( cert . get encoded ( ) ) . read object ( ) ; } catch ( exception e ) { throw new certificate encoding exception ( str + e . to string ( ) ) ; } }"}
{"source": "builds a fixture - making object using the given secret dao <s> public static secret fixtures using ( secret dao secret dao ) { return new secret fixtures ( secret dao ) ; } <s> public static secret fixtures using ( secret jooq dao secret jooq dao ) { return new secret fixtures ( secret jooq dao ) ; }"}
{"source": "a list of the values of the first column of an sql query <s> public < t > list < t > query simple list ( class < t > c , string sql cmd , connection conn ) { if ( check open ( ) = = false ) return null ; result set rs = null ; try { if ( check open ( ) = = false ) return null ; long start = system . current time millis ( ) ; if ( log . is info enabled ( ) ) log . info ( str + sql cmd ) ; rs = driver . execute query ( sql cmd , null , false , conn ) ; if ( rs = = null ) { error ( driver ) ; return null ; } list < t > result = new array list < t > ( ) ; while ( rs . next ( ) ) { t item = object utils . convert ( c , rs . get object ( num ) ) ; result . add ( item ) ; } if ( log . is info enabled ( ) ) log . info ( str + string . value of ( result . size ( ) ) + str + string . value of ( system . current time millis ( ) - start ) + str ) ; clear error ( ) ; return result ; } catch ( class cast exception e ) { log . error ( str , e ) ; error ( errors . exception , e ) ; return null ; } catch ( sqlexception e ) { log . error ( str , e ) ; error ( dberrors . query failed , e ) ; return null ; } finally { close result set ( rs ) ; } } <s> public < t > int query simple list ( class < t > c , string sql cmd , connection conn , collection < t > result ) { if ( check open ( ) = = false ) return - num ; result set rs = null ; try { long start = system . current time millis ( ) ; if ( log . is info enabled ( ) ) log . info ( str + sql cmd ) ; rs = driver . execute query ( sql cmd , null , false , conn ) ; if ( rs = = null ) { error ( driver ) ; return - num ; } int count = num ; while ( rs . next ( ) ) { t item = object utils . convert ( c , rs . get object ( num ) ) ; result . add ( item ) ; count + + ; } if ( log . is info enabled ( ) ) log . info ( str + string . value of ( count ) + str + string . value of ( system . current time millis ( ) - start ) + str ) ; clear error ( ) ; return count ; } catch ( class cast exception e ) { log . error ( str , e ) ; error ( errors . exception , e ) ; return - num ; } catch ( sqlexception e ) { log . error ( str , e ) ; error ( dberrors . query failed , e ) ; return - num ; } finally { close result set ( rs ) ; } }"}
{"source": "the map of action instances to persist , keyed by the class of action . keys with null values indicate actions that should be removed if present . <s> @ non null protected map < class < ? extends action > , action > retrieve actions ( @ non null scmrevision revision , @ non null task listener listener ) throws ioexception , interrupted exception { return collections . empty map ( ) ; } <s> @ non null protected list < action > retrieve actions ( @ non null scmrevision revision , @ non null scmhead event event , @ non null task listener listener ) throws ioexception , interrupted exception { return collections . empty list ( ) ; }"}
{"source": "returns true <s> public boolean update component ( widget component , uidl uidl , boolean manage caption ) { if ( manage caption ) { layout parent = get parent layout ( component ) ; if ( parent ! = null ) parent . update caption ( component , uidl ) ; } boolean visible = ! uidl . get boolean attribute ( str ) ; component . set visible ( visible ) ; if ( ! visible ) return true ; if ( widget factory . is correct implementation ( component , uidl ) ) return false ; layout parent = get parent layout ( component ) ; if ( parent = = null ) return false ; widget w = widget factory . create widget ( uidl ) ; register paintable ( uidl . get id ( ) , ( paintable ) w ) ; parent . replace child component ( component , w ) ; ( ( paintable ) w ) . update from uidl ( uidl , this ) ; return true ; } <s> public boolean update component ( widget component , uidl uidl , boolean manage caption ) { if ( ! widget factory . is correct implementation ( component , uidl ) ) { layout parent = get parent layout ( component ) ; if ( parent ! = null ) { widget w = widget factory . create widget ( uidl ) ; register paintable ( uidl . get id ( ) , ( paintable ) w ) ; parent . replace child component ( component , w ) ; ( ( paintable ) w ) . update from uidl ( uidl , this ) ; return true ; } } if ( manage caption ) { layout parent = get parent layout ( component ) ; if ( parent ! = null ) parent . update caption ( component , uidl ) ; } if ( component instanceof focus widget ) ( ( focus widget ) component ) . set enabled ( ! uidl . get boolean attribute ( str ) ) ; boolean visible = ! uidl . get boolean attribute ( str ) ; component . set visible ( visible ) ; if ( ! visible ) return true ; return false ; }"}
{"source": "a token stream object . notice that , in order to support lucene - like token stream behavior , this object ' s reset method must only be used as reset ( null ) and will reset the token stream to its starting point . <s> public final token stream deserialize ( final byte [ ] data , final char sequence char sequence ) throws ioexception { return deserialize ( data , num , data . length , char sequence ) ; } <s> public final twitter token stream deserialize ( final byte [ ] data , final char sequence char sequence ) throws ioexception { return deserialize ( data , num , data . length , char sequence ) ; }"}
{"source": "blue value in given position <s> public short get blue ( final int i ) { return data [ get1 dindex ( i ) + num ] ; } <s> public short get blue ( ) { return data [ get first1 dindex ( ) + num ] ; }"}
{"source": "the async appender base <s> @ override public async appender base < iaccess event > build ( ) { return new async appender base < iaccess event > ( ) ; } <s> @ override public async appender base < iaccess event > build ( ) { return new async appender base < iaccess event > ( ) { @ override protected void preprocess ( iaccess event event ) { event . prepare for deferred processing ( ) ; } } ; }"}
{"source": "the other object type id or null if no object digest info is set . <s> public string get digest algorithm ( ) { if ( holder . get object digest info ( ) ! = null ) { holder . get object digest info ( ) . get digest algorithm ( ) . get object id ( ) . get id ( ) ; } return null ; } <s> public algorithm identifier get digest algorithm ( ) { if ( holder . get object digest info ( ) ! = null ) { return holder . get object digest info ( ) . get digest algorithm ( ) ; } return null ; }"}
{"source": "project item with specified text without decorators <s> public project item get child ( string text ) { string [ ] child path = new string [ path . length + num ] ; system . arraycopy ( path , num , child path , num , path . length ) ; child path [ child path . length - num ] = text ; return new project item ( tree viewer handler . get tree item ( tree item , text ) , project , child path ) ; } <s> public project item get child ( string text ) { string [ ] child path = new string [ path . length + num ] ; system . arraycopy ( path , num , child path , num , path . length ) ; child path [ child path . length - num ] = text ; return project . get project item ( child path ) ; }"}
{"source": "uri , stripped of any fragment <s> static public string proxy ( final string uri ) { final int fragment start = uri . index of ( str ) ; return - num = = fragment start ? uri : uri . substring ( num , fragment start ) ; } <s> static public string proxy ( final string href ) { final int hash = href . index of ( str ) ; return - num = = hash ? href : href . substring ( num , hash ) ; }"}
{"source": "a string containing the unique identity hash code <s> private string get identity key ( object value ) { return str + system . identity hash code ( value ) ; } <s> private idkey get identity key ( object value ) { return new idkey ( value ) ; }"}
{"source": "the value of this entry ( in case it is single valued ) , or the first value of this entry ( in case it is multivalued ) . <s> public object get value ( ) { if ( is presence type ( ) ) return null ; if ( value is array ) return ( ( object [ ] ) value ) [ num ] ; return value ; } <s> public object get value ( ) { if ( is presence type ( ) ) return null ; if ( multi valued ) return ( ( object [ ] ) value ) [ num ] ; return value ; }"}
{"source": "true if the received query expression matches at least one node in the received xml value ; unknown if either the query expression or the xml value is null ; false otherwise . <s> public boolean data value xmlexists ( string data value x expr , xmldata value xml ) throws standard exception { if ( ( x expr = = null ) | | x expr . is null ( ) ) return sqlboolean . unknown truth value ( ) ; if ( ( xml = = null ) | | xml . is null ( ) ) return sqlboolean . unknown truth value ( ) ; return new sqlboolean ( xml . exists ( x expr . get string ( ) ) ) ; } <s> public boolean data value xmlexists ( sql xml util sqlx util ) throws standard exception { if ( this . is null ( ) ) { return sqlboolean . unknown truth value ( ) ; } if ( sanity manager . debug ) { sanity manager . assert ( sqlx util ! = null , str ) ; } try { return new sqlboolean ( sqlx util . eval xqexpression ( this ) ) ; } catch ( exception xe ) { if ( xe instanceof standard exception ) throw ( standard exception ) xe ; else { throw standard exception . new exception ( sqlstate . lang _ unexpected _ xml _ exception , xe ) ; } } }"}
{"source": "a read - only view of the additional http headers which will be included in every request to the server , or null if no headers have been added <s> public map < string , string > get additional http headers ( ) { return additional http headers = = null ? null : collections . unmodifiable map ( additional http headers ) ; } <s> public map < string , string > get additional http headers ( ) { return collections . unmodifiable map ( additional http headers ) ; }"}
{"source": "an http client <s> public http client build ( string name ) { final basic http params params = create http params ( name ) ; final instrumented client conn manager manager = create connection manager ( registry , name ) ; final instrumented http client client = new instrumented http client ( metric registry , manager , params , name ) ; set strategies for client ( client ) ; return client ; } <s> public closeable http client build ( string name ) { final instrumented http client connection manager manager = create connection manager ( registry , name ) ; final closeable http client client = create client ( manager , name ) ; return client ; }"}
{"source": "the application config object <s> public static application config get module config ( page context page context ) { application config app config = ( application config ) page context . get request ( ) . get attribute ( globals . module _ key ) ; if ( app config = = null ) { app config = ( application config ) page context . get servlet context ( ) . get attribute ( globals . module _ key ) ; } return app config ; } <s> public static module config get module config ( page context page context ) { module config module config = ( module config ) page context . get request ( ) . get attribute ( globals . module _ key ) ; if ( module config = = null ) { module config = ( module config ) page context . get servlet context ( ) . get attribute ( globals . module _ key ) ; } return module config ; }"}
{"source": "a valid revision object corresponding to the argument , with a usable corresponding head , or null if malformed or not found <s> @ check for null public final scmrevision fetch ( @ non null string revision , @ check for null task listener listener ) throws ioexception , interrupted exception { return retrieve ( revision , default listener ( listener ) ) ; } <s> @ check for null public final scmrevision fetch ( @ non null string thing name , @ check for null task listener listener ) throws ioexception , interrupted exception { return retrieve ( thing name , default listener ( listener ) ) ; }"}
{"source": "the list <s> public index linked list get list ( ) { return list ; } <s> public index linked list get list ( ) { return index list ; }"}
{"source": "a style sheet processing instruction if target is \" xml - stylesheet \" or a generic processing instruction otherwise . <s> public processing instruction create processing instruction ( string target , string data ) throws domexception { if ( str . equals ( target ) ) { return new style sheet processing instruction ( data , this , ( style sheet factory ) get implementation ( ) ) ; } return new generic processing instruction ( target , data , this ) ; } <s> public processing instruction create processing instruction ( string target , string data ) throws domexception { if ( str . equals ( target ) ) { return new svgstyle sheet processing instruction ( data , this , ( style sheet factory ) get implementation ( ) ) ; } return new generic processing instruction ( target , data , this ) ; }"}
{"source": "a influxdb reporter <s> public scheduled reporter build ( influxdb influxdb ) { return executor = = null ? new reporter v08 ( registry , influxdb , clock , prefix , rate unit , duration unit , filter , skip idle metrics ) : new reporter v08 ( registry , influxdb , clock , prefix , rate unit , duration unit , filter , skip idle metrics , executor ) ; } <s> public scheduled reporter build ( ) { scheduled reporter reporter ; switch ( influxdb version ) { case v08 : influxdb influxdb = build influxdb ( ) ; reporter = ( executor = = null ) ? new reporter v08 ( registry , influxdb , clock , prefix , rate unit , duration unit , filter , skip idle metrics ) : new reporter v08 ( registry , influxdb , clock , prefix , rate unit , duration unit , filter , skip idle metrics , executor ) ; break ; default : sender s = build sender ( ) ; reporter = executor = = null ? new measurement reporter ( s , registry , filter , rate unit , duration unit , clock , tags , transformer ) : new measurement reporter ( s , registry , filter , rate unit , duration unit , clock , tags , transformer , executor ) ; } return reporter ; }"}
{"source": "the source . <s> public string get source ( ) { return source ; } <s> public string get source ( ) { int pos = source . last index of ( str ) ; if ( pos ! = - num ) { return source . substring ( pos + num ) ; } else { return source ; } }"}
{"source": "a copy of the mappings if storing by value or the same instance if by reference <s> protected final map < k , v > copy map ( map < k , expirable < v > > map ) { class loader class loader = cache manager . get class loader ( ) ; return map . entry set ( ) . stream ( ) . collect ( collectors . to map ( entry - > copier . copy ( entry . get key ( ) , class loader ) , entry - > copier . copy ( entry . get value ( ) . get ( ) , class loader ) ) ) ; } <s> protected final map < k , v > copy map ( map < k , expirable < v > > map ) { class loader class loader = cache manager . get class loader ( ) ; return map . entry set ( ) . stream ( ) . collect ( to map ( entry - > copier . copy ( entry . get key ( ) , class loader ) , entry - > copier . copy ( entry . get value ( ) . get ( ) , class loader ) ) ) ; }"}
{"source": "the context running this job . in most situations it ' s a service . <s> @ non null protected final context get context ( ) { return m context ; } <s> @ non null protected final context get context ( ) { context context = m context reference . get ( ) ; return context = = null ? m application context : context ; }"}
{"source": "ping info <s> protected ping info parse ( int exit value , list < string > out lines , list < string > err lines ) { ping info info = new ping info ( ) ; pattern round trip time pat = pattern . compile ( rtt _ reg _ ex ) ; pattern transmit receive pat = pattern . compile ( transmitted _ received _ reg _ ex ) ; pattern no route to host pat = pattern . compile ( no _ route _ to _ host _ reg _ ex ) ; pattern unknown host pat = pattern . compile ( unknown _ host _ reg _ ex ) ; info . set host ( get host ( ) ) ; switch ( exit value ) { case num : for ( string line : out lines ) { matcher matcher = round trip time pat . matcher ( line ) ; if ( matcher . find ( ) ) { info . set rttmin ( double . parse double ( matcher . group ( num ) ) ) ; info . set rttavg ( double . parse double ( matcher . group ( num ) ) ) ; info . set rttmax ( double . parse double ( matcher . group ( num ) ) ) ; info . set rttmdev ( double . parse double ( matcher . group ( num ) ) ) ; } } for ( string line : out lines ) { matcher matcher = transmit receive pat . matcher ( line ) ; if ( matcher . find ( ) ) { info . set transmitted ( integer . parse int ( matcher . group ( num ) ) ) ; info . set received ( integer . parse int ( matcher . group ( num ) ) ) ; } } if ( info . get received ( ) = = num ) { info . set status ( service status . fail ) ; } else { info . set status ( service status . success ) ; } break ; case num : case num : case num : for ( string line : out lines ) { matcher matcher = transmit receive pat . matcher ( line ) ; if ( matcher . find ( ) ) { info . set transmitted ( integer . parse int ( matcher . group ( num ) ) ) ; info . set received ( integer . parse int ( matcher . group ( num ) ) ) ; } } for ( string line : err lines ) { matcher matcher = unknown host pat . matcher ( line ) ; if ( matcher . find ( ) ) { info . set message ( matcher . group ( num ) ) ; } } info . set status ( service status . fail ) ; break <s> protected ping result parse ( int exit value , list < string > out lines , list < string > err lines ) { ping result info = new ping result ( ) ; pattern round trip time pat = pattern . compile ( rtt _ reg _ ex ) ; pattern transmit receive pat = pattern . compile ( transmitted _ received _ reg _ ex ) ; pattern no route to host pat = pattern . compile ( no _ route _ to _ host _ reg _ ex ) ; pattern unknown host pat = pattern . compile ( unknown _ host _ reg _ ex ) ; info . set host ( get host ( ) ) ; switch ( exit value ) { case num : for ( string line : out lines ) { matcher matcher = round trip time pat . matcher ( line ) ; if ( matcher . find ( ) ) { info . set rttmin ( double . parse double ( matcher . group ( num ) ) ) ; info . set rttavg ( double . parse double ( matcher . group ( num ) ) ) ; info . set rttmax ( double . parse double ( matcher . group ( num ) ) ) ; info . set rttmdev ( double . parse double ( matcher . group ( num ) ) ) ; } } for ( string line : out lines ) { matcher matcher = transmit receive pat . matcher ( line ) ; if ( matcher . find ( ) ) { info . set transmitted ( integer . parse int ( matcher . group ( num ) ) ) ; info . set received ( integer . parse int ( matcher . group ( num ) ) ) ; } } if ( info . get received ( ) = = num ) { info . set status ( service status . fail ) ; } else { info . set status ( service status . success ) ; } break ; case num : case num : case num : for ( string line : out lines ) { matcher matcher = transmit receive pat . matcher ( line ) ; if ( matcher . find ( ) ) { info . set transmitted ( integer . parse int ( matcher . group ( num ) ) ) ; info . set received ( integer . parse int ( matcher . group ( num ) ) ) ; } } for ( string line : err lines ) { matcher matcher = unknown host pat . matcher ( line ) ; if ( matcher . find ( ) ) { info . set message ( matcher . group ( num ) ) ; } } info . set status ( service status . fail ) ; break"}
{"source": "the hostname , null if not found or takes longer than 30s to find <s> private string get hostname ( final inet address remote ) { final string [ ] hostname = new string [ ] { null } ; final atomic boolean done = new atomic boolean ( false ) ; thread thread = new thread ( new runnable ( ) { public void run ( ) { hostname [ num ] = remote . get canonical host name ( ) ; done . get and set ( true ) ; synchronized ( done ) { done . notify all ( ) ; } } } ) ; thread . run ( ) ; long end time = system . current time millis ( ) + dns _ timeout ; while ( system . current time millis ( ) < end time & & ! done . get ( ) ) { try { synchronized ( done ) { done . wait ( end time - system . current time millis ( ) ) ; } } catch ( interrupted exception e ) { } } return hostname [ num ] ; } <s> private string get hostname ( final inet address remote ) throws firewall exception { future task < string > lookup = new future task < string > ( new callable < string > ( ) { public string call ( ) { return remote . get canonical host name ( ) ; } } ) ; dns _ lookup . execute ( lookup ) ; try { return lookup . get ( dns _ timeout , time unit . milliseconds ) ; } catch ( exception e ) { return null ; } finally { lookup . cancel ( true ) ; } }"}
{"source": "a list of temp files <s> public list < file path > get temp files ( ) { list < file path > temp files = new array list < file path > ( ) ; for ( entry < managed file , file path > entry : file2 path . entry set ( ) ) { boolean no target given = string utils . is blank ( entry . get key ( ) . target location ) ; if ( no target given ) { temp files . add ( entry . get value ( ) ) ; } } return temp files ; } <s> list < string > get temp files ( ) { list < string > temp files = new array list < string > ( ) ; for ( entry < managed file , file path > entry : file2 path . entry set ( ) ) { boolean no target given = string utils . is blank ( entry . get key ( ) . target location ) ; if ( no target given ) { temp files . add ( entry . get value ( ) . get remote ( ) ) ; } } return temp files ; }"}
{"source": "the failover list composite assigned to it by the server <s> public failover list composite get failover list ( ) { return failover list ; } <s> public failover list composite get failover list ( ) { return failover list ! = null ? failover list : new failover list composite ( new array list < server entry > ( ) ) ; }"}
{"source": "true if the edit - value is longer then ta _ length chars <s> public boolean is ta ( ) { return cur edit _ str _ value . length ( ) > ta _ length ; } <s> public boolean is ta ( ) { return cur edit _ str _ value . length ( ) > ta _ length | | cur edit _ str _ value . index of ( str ) > num ; }"}
{"source": "the y location of the center of this circle <s> public float get y ( ) { return center [ num ] ; } <s> public float get y ( ) { if ( top = = null ) { calculate top ( ) ; } return top . float value ( ) ; }"}
{"source": "ping info <s> public ping info perform check ( ping configuration configuration ) { ping info info = client . ping ( configuration ) ; set ping info ( info , configuration , client ) ; return info ; } <s> public ping result perform check ( ping configuration configuration ) { ping result info = client . ping ( configuration ) ; set ping info ( info , configuration , client ) ; return info ; }"}
{"source": "an array list of the view objects located in the current activity <s> public array list < view > get views ( ) { try { return view fetcher . get views ( null ) ; } catch ( exception e ) { e . print stack trace ( ) ; return null ; } } <s> public array list < view > get views ( ) { try { return view fetcher . get views ( null , false ) ; } catch ( exception e ) { e . print stack trace ( ) ; return null ; } }"}
{"source": "the key with which the value will be associated <s> public string literal get key ( ) { return key ; } <s> public expression get key ( ) { return key ; }"}
{"source": "true if it depends on the given add - on , false otherwise . <s> public boolean depends on ( add on add on ) { if ( dependencies = = null | | dependencies . get add ons ( ) . is empty ( ) ) { return false ; } return depends on ( dependencies . get add ons ( ) , add on ) ; } <s> public boolean depends on ( collection < add on > add ons ) { if ( dependencies = = null | | dependencies . get add ons ( ) . is empty ( ) ) { return false ; } for ( add on add on : add ons ) { if ( depends on ( add on ) ) { return true ; } } return false ; }"}
{"source": "a data instance that contains the cached data <s> public data get single data ( xref idc ) { list < data > dlist = data . get ( idc ) ; if ( dlist ! = null & & dlist . size ( ) > num ) return dlist . get ( num ) ; return null ; } <s> public reporter data get single data ( xref idc ) { list < reporter data > dlist = data . get ( idc ) ; if ( dlist ! = null & & dlist . size ( ) > num ) return dlist . get ( num ) ; return null ; }"}
{"source": "current estimated rotation we are at <s> public int get estimated rotation ( ) { if ( ! is rotating ( ) ) { return get rotation ( ) ; } else { double time spent = ( system . current time millis ( ) - starting time ) / num ; int pos = current starting point + ( int ) ( current velocity * time spent ) ; double angle = ( double ) ( pos ) / settings . get handler rotation ( ) * num ; return ( int ) ( math . round ( angle ) ) % num ; } } <s> public int get estimated rotation ( ) { if ( ! is rotating ( ) ) { return get rotation ( ) ; } double time spent = ( system . current time millis ( ) - estimated rotation start time ) / num ; int rotation = estimated rotation start + ( int ) ( current velocity * time spent ) ; if ( ( estimated rotation start < estimated rotation end ) ! = ( estimated rotation start < rotation ) ) { rotation = estimated rotation end ; } double angle = ( double ) ( rotation ) / settings . get handler rotation ( ) * num ; return ( int ) ( math . round ( angle ) ) % num ; }"}
{"source": "a criterion that evaluates the raw selection and selection args <s> public static criterion from raw selection ( final string selection , final string [ ] selection args ) { if ( text utils . is empty ( selection ) ) { return criterion . all ; } return new criterion ( null ) { @ override protected void populate ( sql builder builder , boolean for sql validation ) { builder . sql . append ( selection ) ; if ( selection args ! = null & & selection args . length > num ) { if ( builder . args = = null ) { throw new unsupported operation exception ( str + str ) ; } collections . add all ( builder . args , selection args ) ; } } } ; } <s> public static criterion from raw selection ( final string selection , final string [ ] selection args ) { if ( text utils . is empty ( selection ) ) { return null ; } return new criterion ( null ) { @ override protected void populate ( sql builder builder , boolean for sql validation ) { builder . sql . append ( selection ) ; if ( selection args ! = null & & selection args . length > num ) { if ( builder . args = = null ) { throw new unsupported operation exception ( str + str ) ; } collections . add all ( builder . args , selection args ) ; } } } ; }"}
{"source": "true if text is found and false if it is not found before the timeout <s> public boolean wait for text ( string text , int expected minimum number of matches , long timeout , boolean scroll ) { return robotium utils . wait for text ( text , expected minimum number of matches , timeout , scroll ) ; } <s> public boolean wait for text ( string text , int minimum number of matches , long timeout , boolean scroll ) { return robotium utils . wait for text ( text , minimum number of matches , timeout , scroll ) ; }"}
{"source": "the address of the sender as a long . <s> public long get numerical address ( ) { return address ; } <s> public inet address get numerical address ( ) { return address ; }"}
{"source": "true if the method has a jsecurity has role or implies annotation , false otherwise . <s> public boolean matches ( method method , class target class ) { return ( ( method . get annotation ( implies . class ) ! = null ) | | ( method . get annotation ( has role . class ) ! = null ) ) ; } <s> public boolean matches ( method method , class target class ) { return ( ( method . get annotation ( permission required . class ) ! = null ) | | ( method . get annotation ( roles required . class ) ! = null ) ) ; }"}
{"source": "service credentials if they are already set . <s> protected service credentials get service credentials ( ) { return this . service credentials ; } <s> protected account get service credentials ( ) { return this . account ; }"}
{"source": "contact id , if not found invalid _ id is returned <s> private long get rcs raw contact id from phone number ( string phone number ) { string [ ] projection = { data . raw _ contact _ id } ; string selection = data . mimetype + str + phone . number + str ; string [ ] selection args = { mimetype _ number , phone number } ; string sort order = data . raw _ contact _ id ; cursor cur = ctx . get content resolver ( ) . query ( data . content _ uri , projection , selection , selection args , sort order ) ; if ( cur ! = null ) { while ( cur . move to next ( ) ) { long rcs raw contact id = cur . get long ( cur . get column index ( data . raw _ contact _ id ) ) ; cur . close ( ) ; return rcs raw contact id ; } cur . close ( ) ; } return invalid _ id ; } <s> private list < long > get rcs raw contact id from phone number ( string phone number ) { list < long > contacts ids = new array list < long > ( ) ; string [ ] projection = { data . raw _ contact _ id } ; string selection = data . mimetype + str + phone . number + str ; string [ ] selection args = { mimetype _ number , phone number } ; string sort order = data . raw _ contact _ id ; cursor cur = ctx . get content resolver ( ) . query ( data . content _ uri , projection , selection , selection args , sort order ) ; if ( cur ! = null ) { while ( cur . move to next ( ) ) { long rcs raw contact id = cur . get long ( cur . get column index ( data . raw _ contact _ id ) ) ; contacts ids . add ( rcs raw contact id ) ; } cur . close ( ) ; } return contacts ids ; }"}
{"source": "the object name for the given exchange on the test virtual host . <s> public object name get exchange object name ( string virtual host name , string exchange ) { all objects all object = new all objects ( _ mbsc ) ; all object . querystring = str + virtual host name + str + exchange + str ; set < object name > object names = all object . return objects ( ) ; _ test . assert not null ( str , object names ) ; _ test . assert equals ( str + exchange + str , num , object names . size ( ) ) ; return object names . iterator ( ) . next ( ) ; } <s> @ suppress warnings ( str ) public object name get exchange object name ( string virtual host name , string exchange ) { all objects all object = new all objects ( _ mbsc ) ; all object . querystring = str + virtual host name + str + exchange + str ; set < object name > object names = all object . return objects ( ) ; _ test . assert not null ( str , object names ) ; _ test . assert equals ( str + exchange + str , num , object names . size ( ) ) ; object name object name = object names . iterator ( ) . next ( ) ; _ test . get logger ( ) . info ( str + object name ) ; return object name ; }"}
{"source": "scale animation builder instance . call com . davemorrissey . labs . subscaleview . subsampling scale image view . scale animation builder # start ( ) to start the anim . <s> public scale animation builder animate scale ( float scale ) { if ( ! is image ready ( ) ) { return null ; } return new scale animation builder ( scale ) ; } <s> public animation builder animate scale ( float scale ) { if ( ! is image ready ( ) ) { return null ; } return new animation builder ( scale ) ; }"}
{"source": "the instance of fortran editor vpgtasks associated with the given editor , creating the instance on - demand if necessary <s> public static fortran editor vpgtasks instance ( abstract fortran editor editor ) { if ( editor . reconciler tasks = = null ) editor . reconciler tasks = new fortran editor vpgtasks ( editor ) ; return ( fortran editor vpgtasks ) editor . reconciler tasks ; } <s> public static fortran editor tasks instance ( abstract fortran editor editor ) { if ( editor . reconciler tasks = = null ) editor . reconciler tasks = new fortran editor tasks ( editor ) ; return ( fortran editor tasks ) editor . reconciler tasks ; }"}
{"source": "string or empty <s> public static string get message id ( sip request request ) { extension header message id header = ( extension header ) request . get header ( imdn utils . header _ imdn _ msg _ id ) ; if ( message id header ! = null ) { return message id header . get value ( ) ; } try { string content = request . get content ( ) ; int index = content . index of ( imdn utils . header _ imdn _ msg _ id ) ; if ( index ! = - num ) { index = index + imdn utils . header _ imdn _ msg _ id . length ( ) + num ; string part = content . substring ( index ) ; string msg id = part . substring ( num , part . index of ( sip utils . crlf ) ) ; return msg id . trim ( ) ; } } catch ( exception e ) { } return null ; } <s> public static string get message id ( sip request request ) { string result = null ; try { string content = request . get content ( ) ; int index = content . index of ( imdn utils . header _ imdn _ msg _ id ) ; if ( index ! = - num ) { index = index + imdn utils . header _ imdn _ msg _ id . length ( ) + num ; string part = content . substring ( index ) ; string msg id = part . substring ( num , part . index of ( crlf ) ) ; result = msg id . trim ( ) ; } } catch ( exception e ) { } return result ; }"}
{"source": "an array with all interfaces . the array may be empty . <s> public static class [ ] get all interfaces ( class clazz ) { set interfaces = new hash set ( ) ; get interfaces ( clazz , interfaces ) ; return ( class [ ] ) interfaces . to array ( new class [ interfaces . size ( ) ] ) ; } <s> public static set get all interfaces ( class clazz ) { set interfaces = new hash set ( ) ; get interfaces ( clazz , interfaces ) ; return interfaces ; }"}
{"source": "when the work has ben accepted . <s> public synchronized long get accepted time ( ) { return m _ accepted time ; } <s> public synchronized long get accepted time ( ) { return accepted time ; }"}
{"source": "a json array with the result of the cat indices request . <s> private json array cat indices ( collection < string > indices , string . . . fields ) { final string field names = string . join ( str , fields ) ; final cat request = new cat . indices builder ( ) . add index ( indices ) . set parameter ( str , field names ) . build ( ) ; final cat result response = jest utils . execute ( jest client , request , ( ) - > str + indices ) ; return optional . of ( response . get json object ( ) ) . map ( json - > gson utils . as json array ( json . get ( str ) ) ) . or else ( new json array ( ) ) ; } <s> private json node cat indices ( collection < string > indices , string . . . fields ) { final string field names = string . join ( str , fields ) ; final cat request = new cat . indices builder ( ) . add index ( indices ) . set parameter ( str , field names ) . build ( ) ; final cat result response = jest utils . execute ( jest client , request , ( ) - > str + indices ) ; return response . get json object ( ) . path ( str ) ; }"}
{"source": "the time when the entry will expire <s> protected long expire time ms ( supplier < duration > expires ) { try { duration duration = expires . get ( ) ; return duration . is zero ( ) ? num : duration . get adjusted time ( current time millis ( ) ) ; } catch ( exception e ) { logger . log ( level . warning , str , e ) ; return long . max _ value ; } } <s> protected long expire time ms ( supplier < duration > expires ) { try { duration duration = expires . get ( ) ; if ( duration = = null ) { return - num ; } return duration . is zero ( ) ? num : duration . get adjusted time ( current time millis ( ) ) ; } catch ( exception e ) { logger . log ( level . warning , str , e ) ; return - num ; } }"}
{"source": "what modified to account for all , both , and none options . <s> protected set < string > populate what ( set < string > what ) { if ( ! check option ( what ) ) { return null ; } if ( what . contains ( what _ all ) ) { what . add ( what _ impl ) ; what . add ( what _ main ) ; what . add ( what _ helper ) ; } if ( ! what . contains ( what _ client ) & & ! what . contains ( what _ server ) & & ! what . contains ( what _ both ) ) { what . add ( what _ both ) ; } if ( what . contains ( what _ both ) ) { what . add ( what _ client ) ; what . add ( what _ server ) ; } if ( what . contains ( what _ none ) ) { what . clear ( ) ; } return what ; } <s> protected set < string > populate what ( set < string > what ) throws exception { check option ( what ) ; if ( what . contains ( what _ help ) ) throw new exception ( str + what help ( ) ) ; if ( ! what . contains ( what _ client ) & & ! what . contains ( what _ server ) & & ! what . contains ( what _ both ) ) { what . add ( what _ both ) ; what . add ( what _ client ) ; what . add ( what _ server ) ; } else if ( what . contains ( what _ both ) ) { what . add ( what _ client ) ; what . add ( what _ server ) ; } else if ( what . contains ( what _ client ) & & what . contains ( what _ server ) ) { what . add ( what _ both ) ; } assertion . check ( ( what . contains ( what _ client ) & & ! what . contains ( what _ server ) & & ! what . contains ( what _ both ) ) | | ( ! what . contains ( what _ client ) & & what . contains ( what _ server ) & & ! what . contains ( what _ both ) ) | | ( what . contains ( what _ client ) & & what . contains ( what _ server ) & & what . contains ( what _ both ) ) , str ) ; if ( ! what . contains ( what _ all ) & & ! what . contains ( what _ none ) & & ! what . contains ( what _ intf ) & & ! what . contains ( what _ main ) & & ! what . contains ( what _ impl ) ) { what . add ( what _ intf ) ; } if ( what . contains ( what _ all ) ) { what . add ( what _ intf ) ; what . add ( what _ main ) ; what . add ( what _ impl ) ; what . remove ( what _ all ) ; what . remove ( what _ none ) ; } if ( what . contains ( what _ none ) ) { what . remove ( what _ intf ) ; what . remove ( what _ main ) ; what . remove ( what _ impl ) ; what . remove ( what _ none ) ; } return what ; }"}
{"source": "current directory history , or if empty , only current directory ( as file [ 0 ] ) . <s> private file [ ] get directory history ( ) { file [ ] dirhist = settings . instance ( ) . get directory history ( ) ; if ( dirhist = = null | | dirhist . length = = num ) return new file [ ] { new file ( str ) . get absolute file ( ) } ; else return dirhist ; } <s> private file [ ] get directory history ( ) { return settings . instance ( ) . get directory history ( ) ; }"}
{"source": "null if gobble start was null , or a gobbling object containing the result of the gobble . gobbling # treepath minus gobbled still refers to the _ placeholder _ but some separators and one raw item have been removed . gobbling # gobbled tree is the result of the gobbling <s> private static gobbling gobble ( treepath < syntactic tree > gobble start ) { if ( null = = gobble start ) { return null ; } preconditions . check argument ( gobble start . get tree at end ( ) . is one of ( _ placeholder _ ) ) ; gobble start = treepath tools . get next sibling ( gobble start ) ; do { if ( is raw item ( gobble start ) ) { if ( treepath tools . has next sibling ( gobble start ) ) { final treepath < syntactic tree > next start = treepath tools . get next sibling ( gobble start ) ; final treepath < syntactic tree > next start minus previous = treepath tools . remove previous sibling ( next start ) ; return new gobbling ( next start minus previous , make embedded list item ( gobble start ) , true ) ; } else { final treepath < syntactic tree > minus previous = treepath tools . remove end ( gobble start ) ; return new gobbling ( minus previous , make embedded list item ( gobble start ) , false ) ; } } else if ( gobble start . get tree at end ( ) . is one of ( whitespace _ , line _ break _ ) ) { if ( treepath tools . has next sibling ( gobble start ) ) { gobble start = treepath tools . get next sibling ( gobble start ) ; } } else { return null ; } } while ( true ) ; } <s> private static gobbling gobble ( treepath < syntactic tree > gobble start , int indentation ) { preconditions . check argument ( gobble start . get tree at end ( ) . is one of ( _ placeholder _ ) ) ; treepath < syntactic tree > start = gobble start ; do { if ( treepath tools . has next sibling ( start ) ) { final treepath < syntactic tree > next = treepath tools . get next sibling ( start ) ; if ( is raw item ( next ) ) { final treepath < syntactic tree > minus next = treepath tools . remove next sibling ( start ) ; return new gobbling ( minus next , make embedded list item ( next ) , indentation ) ; } else { final syntactic tree next tree = next . get tree at end ( ) ; if ( next tree . is one of ( whitespace _ , line _ break _ ) ) { start = treepath tools . remove next sibling ( start ) ; if ( next tree . is one of ( whitespace _ ) ) { indentation = get whitespace length ( next ) ; } continue ; } } } return new gobbling ( start ) ; } while ( true ) ; }"}
{"source": "a list with instances of org . mule . module . google . calendar . model . calendar list <s> @ processor @ inject @ oauth protected @ oauth invalidate access token on ( exception = oauth token expired exception . class ) public list < calendar list > get calendar list ( mule message message , @ optional @ default ( str ) int max results , @ optional string page token , @ optional @ default ( str ) boolean show hidden ) throws ioexception { com . google . api . services . calendar . calendar . calendar list . list calendars = this . client . calendar list ( ) . list ( ) ; com . google . api . services . calendar . model . calendar list list = calendars . set max results ( max results ) . set page token ( page token ) . set show hidden ( show hidden ) . execute ( ) ; this . save next page token ( list , message ) ; return calendar list . value of ( list . get items ( ) , calendar list . class ) ; } <s> @ processor @ oauth protected @ oauth invalidate access token on ( exception = oauth token expired exception . class ) @ paged public paging delegate < calendar list > get calendar list ( @ optional @ default ( str ) final boolean show hidden , final paging configuration paging configuration ) throws ioexception { return new token based paging delegate < calendar list > ( ) { @ override public list < calendar list > do get page ( ) throws ioexception { com . google . api . services . calendar . calendar . calendar list . list calendars = client . calendar list ( ) . list ( ) ; com . google . api . services . calendar . model . calendar list list = calendars . set max results ( paging configuration . get fetch size ( ) ) . set page token ( this . get page token ( ) ) . set show hidden ( show hidden ) . execute ( ) ; set page token ( list . get next page token ( ) ) ; return calendar list . value of ( list . get items ( ) , calendar list . class ) ; } } ; }"}
{"source": "the property descriptors as a collection <s> public properties get properties ( ) { return m _ properties ; } <s> public dictionary get properties ( ) { return m _ properties ; }"}
{"source": "a sqlrow ( non fetched ) or null . <s> public final sqlrow get selected row ( ) { if ( this . is empty ( ) ) return null ; else { return new sqlrow ( this . get foreign table ( ) , this . get selected id ( ) ) ; } } <s> public final sqlrow get selected row ( ) { if ( this . is empty ( ) ) { return null ; } else { final icombo selection item o = this . get value ( ) ; final sqlrow accessor r = o . get row ( ) ; if ( r ! = null ) { return r . as row ( ) ; } else { return new sqlrow ( this . get foreign table ( ) , o . get id ( ) ) ; } } }"}
{"source": "the base url with no final \" / \" . <s> protected string get base url ( ) { final string builder base url builder = new string builder ( ) ; if ( string utils . is not empty ( base url ) ) { base url builder . append ( this . base url ) ; } else { base url builder . append ( default _ base _ url ) ; } return extend get base url ( base url builder ) . to string ( ) ; } <s> protected string get base url ( ) { return this . extend get base url ( new string builder ( this . base url ) ) . to string ( ) ; }"}
{"source": "the signature string <s> public string to string ( boolean alt member sep ) { string buffer s = new string buffer ( ) ; if ( class name ! = null ) { s . append ( class name ) ; } if ( member name ! = null ) { if ( class name ! = null ) { s . append ( alt member sep ? alt _ member _ separator : str ) ; } s . append ( member name ) ; } if ( descriptor ! = null & & ( class name = = null | | member name ! = null ) ) { s . append ( descriptor ) ; } return s . to string ( ) ; } <s> @ override public string to string ( ) { if ( string rep = = null ) { string rep = to string ( true ) ; } return string rep ; }"}
{"source": "the authentication token <s> @ processor @ invalidate connection on ( exception = jira connector exception . class ) public string login ( string username , string password ) { return client . login ( username , password ) ; } <s> @ processor public string login ( string username , string password ) { return config . get client ( ) . login ( username , password ) ; }"}
{"source": "new instance of the rule to be used by unit tests <s> static mongo database rule create ( ) { final mongo client client ; if ( mongo assertions . use mongo ( ) ) { client = new mongo client ( ) ; } else if ( mongo assertions . use fongo ( ) ) { client = new fongo ( mongo database rule . class . get simple name ( ) ) . get mongo ( ) ; } else { throw new unsupported operation exception ( str ) ; } return new mongo database rule ( client ) ; } <s> static mongo database policy create ( ) { final mongo client client ; if ( mongo assertions . use mongo ( ) ) { client = new mongo client ( ) ; } else if ( mongo assertions . use fongo ( ) ) { client = new fongo ( mongo database policy . class . get simple name ( ) ) . get mongo ( ) ; } else { throw new unsupported operation exception ( str ) ; } return new mongo database policy ( client ) ; }"}
{"source": "a new feature service with the default server url <s> public feature service create feature service ( ) { return create feature service ( default server url ) ; } <s> public feature service create feature service ( ) { return create feature service ( default endpoint url ) ; }"}
{"source": "a hashtable representation of the passed in workflow task configuration ' s properties . <s> public static hashtable get xml rpc workflow task configuration ( workflow task configuration config ) { hashtable configuration = new hashtable ( ) ; for ( object o : config . get properties ( ) . key set ( ) ) { string name = ( string ) o ; string value = ( string ) config . get properties ( ) . get ( name ) ; configuration . put ( name , value ) ; } return configuration ; } <s> public static hash map get xml rpc workflow task configuration ( workflow task configuration config ) { hash map configuration = new hash map ( ) ; for ( object o : config . get properties ( ) . key set ( ) ) { string name = ( string ) o ; string value = ( string ) config . get properties ( ) . get ( name ) ; configuration . put ( name , value ) ; } return configuration ; }"}
{"source": "- 20 right bytes of the hash keccak of the data <s> public static byte [ ] sha3omit12 ( byte [ ] input ) { byte [ ] hash = sha3 ( input ) ; return copy of range ( hash , num , hash . length ) ; } <s> public static byte [ ] sha3omit12 ( byte [ ] input ) { byte [ ] hash = sha3 ( input ) ; byte [ ] address = copy of range ( hash , num , hash . length ) ; address [ num ] = wallet . get address pre fix byte ( ) ; return address ; }"}
{"source": "hidden source <s> public static hidden hide ( ) { return hide ( null ) ; } <s> public static internal hide ( ) { return hide ( null ) ; }"}
{"source": "true if the function was successfully <s> public boolean reorganize space ( connection con , sequencer engine seq , fx tree mode source mode , fx tree mode dest mode , long node id , boolean include node id , big decimal override spacing , big decimal override left , fx tree node info insert parent , int insert position , big decimal insert space , big decimal [ ] insert boundaries , int depth delta , long destination node , boolean create mode , boolean create keep ids , long first created node id ) throws fx tree exception { fx tree node info spreaded node info ; try { node info = ( fx tree node info spreaded ) get tree node info ( con , source mode , node id ) ; } catch ( exception e ) { return false ; } if ( ! node info . is space optimizable ( ) ) { if ( node id = = root _ node ) { return false ; } return reorganize space ( con , seq , source mode , dest mode , node info . get parent id ( ) , include node id , override spacing , override left , insert parent , insert position , insert space , insert boundaries , depth delta , destination node , create mode , create keep ids , first created node id ) ; } big decimal spacing = node info . get default spacing ( ) ; if ( override spacing ! = null & & override spacing . compare to ( spacing ) < num ) { spacing = override spacing ; } else { if ( spacing . compare to ( go _ up ) < num ) { return reorganize space ( con , seq , source mode , dest mode , node info . get parent id ( ) , include node id , override spacing , override left , insert parent , insert position , insert space , insert boundaries , depth delta , destination node , create mode , create keep ids , first created node id ) ; } } statement stmt = null ; prepared statement ps = null ; result set rs ; big decimal left = override left = = null ? node info . get left ( ) : override left ; big decimal right = null ; string include node = include node id ? str : str ; long counter = num ; first created node id = - num ; long new id = - num ; try { string create props = create mode ? str : str ; string sql = str + create props + str + create props + str + get table ( source mode ) + str + str + include <s> public long reorganize space ( connection con , sequencer engine seq , fx tree mode source mode , fx tree mode dest mode , long node id , boolean include node id , big decimal override spacing , big decimal override left , fx tree node info insert parent , int insert position , big decimal insert space , big decimal [ ] insert boundaries , int depth delta , long destination node , boolean create mode , boolean create keep ids ) throws fx tree exception { long first created node id = - num ; fx tree node info spreaded node info ; try { node info = ( fx tree node info spreaded ) get tree node info ( con , source mode , node id ) ; } catch ( exception e ) { return - num ; } if ( ! node info . is space optimizable ( ) ) { if ( node id = = root _ node ) { return - num ; } return reorganize space ( con , seq , source mode , dest mode , node info . get parent id ( ) , include node id , override spacing , override left , insert parent , insert position , insert space , insert boundaries , depth delta , destination node , create mode , create keep ids ) ; } big decimal spacing = node info . get default spacing ( ) ; if ( override spacing ! = null & & override spacing . compare to ( spacing ) < num ) { spacing = override spacing ; } else { if ( spacing . compare to ( go _ up ) < num ) { return reorganize space ( con , seq , source mode , dest mode , node info . get parent id ( ) , include node id , override spacing , override left , insert parent , insert position , insert space , insert boundaries , depth delta , destination node , create mode , create keep ids ) ; } } statement stmt = null ; prepared statement ps = null ; result set rs ; big decimal left = override left = = null ? node info . get left ( ) : override left ; big decimal right = null ; string include node = include node id ? str : str ; long counter = num ; long new id = - num ; try { string create props = create mode ? str : str ; string sql = str + create props + str + create props + str + get table ( source mode ) + str + str + include node + node info . get left ( ) + str + include"}
{"source": "connection jdbc2 object . <s> private connection jdbc2 get connection ( ) throws sqlexception { return ( connection jdbc2 ) statement . get connection ( ) ; } <s> private connection jdbc get connection ( ) throws sqlexception { return ( connection jdbc ) statement . get connection ( ) ; }"}
{"source": "collected array <s> public rel data type [ ] collect operand types ( ) { rel data type [ ] ret = new rel data type [ get operand count ( ) ] ; for ( int i = num ; i < ret . length ; i + + ) { ret [ i ] = get operand type ( i ) ; } return ret ; } <s> public list < rel data type > collect operand types ( ) { return new abstract list < rel data type > ( ) { public rel data type get ( int index ) { return get operand type ( index ) ; } public int size ( ) { return get operand count ( ) ; } } ; }"}
{"source": "label text . <s> public string create text ( mil std2525 tactical graphic graphic ) { string function id = graphic . get function id ( ) ; if ( circular fire support area . function _ id _ target . equals ( function id ) ) return graphic . get text ( ) ; else return create date range text ( graphic , function id ) ; } <s> public string [ ] create text ( mil std2525 tactical graphic graphic ) { string [ ] result ; string function id = graphic . get function id ( ) ; if ( circular fire support area . function _ id _ target . equals ( function id ) ) { result = new string [ ] { graphic . get text ( ) } ; } else { boolean use separate time label = this . is show separate time label ( function id ) ; string main text = this . create main text ( graphic , function id , ! use separate time label ) ; if ( use separate time label ) { string time text = this . create time range text ( graphic ) ; result = new string [ ] { main text , time text } ; } else { result = new string [ ] { main text } ; } } return result ; }"}
{"source": "ping host <s> public static builder host ( final string host ) { return builder ( ) . host ( host ) ; } <s> public builder host ( string host ) { this . host = host ; return this ; }"}
{"source": "port , on which the server did start <s> public int start ( final string work dir , final cryptor cryptor ) { final server connector connector = new server connector ( server ) ; connector . set host ( localhost ) ; final string context path = str ; final servlet context handler context = new servlet context handler ( servlet context handler . sessions ) ; context . add servlet ( get milton servlet holder ( work dir , context path , cryptor ) , str ) ; context . set context path ( context path ) ; server . set handler ( context ) ; try { server . set connectors ( new connector [ ] { connector } ) ; server . start ( ) ; } catch ( exception ex ) { log . error ( str , ex ) ; } return connector . get local port ( ) ; } <s> public synchronized boolean start ( final string work dir , final cryptor cryptor ) { final server connector connector = new server connector ( server ) ; connector . set host ( localhost ) ; final string context path = str ; final servlet context handler context = new servlet context handler ( servlet context handler . sessions ) ; context . add servlet ( get milton servlet holder ( work dir , context path , cryptor ) , str ) ; context . set context path ( context path ) ; server . set handler ( context ) ; try { server . set connectors ( new connector [ ] { connector } ) ; server . start ( ) ; port = connector . get local port ( ) ; return true ; } catch ( exception ex ) { log . error ( str , ex ) ; return false ; } }"}
{"source": "unique string representation of the underlying physical connection <s> public string to string ( ) { try { return get real connection ( ) . to string ( ) ; } catch ( sqlexception e ) { return str ; } } <s> public string to string ( ) { if ( conn string = = null ) { string wrapped string ; try { wrapped string = get real connection ( ) . to string ( ) ; } catch ( sqlexception e ) { wrapped string = str ; } conn string = this . get class ( ) . get name ( ) + str + this . hash code ( ) + str + wrapped string ; } return conn string ; }"}
{"source": "jsonobject array list <s> private jsonobject get selected region json ( cluster cluster , string selected region full path ) throws jsonexception { pulse log writer logger = pulse log writer . get logger ( ) ; long total heap size = cluster . get total heap size ( ) ; long total disk usage = cluster . get total bytes on disk ( ) ; cluster . region reg = cluster . get cluster region ( selected region full path ) ; if ( reg ! = null ) { jsonobject region json = new jsonobject ( ) ; region json . put ( str , reg . get name ( ) ) ; region json . put ( str , reg . get full path ( ) ) ; region json . put ( str , total heap size ) ; region json . put ( str , reg . get system region entry count ( ) ) ; region json . put ( str , reg . get member count ( ) ) ; final string region type = reg . get region type ( ) ; region json . put ( str , region type ) ; region json . put ( str , reg . get gets rate ( ) ) ; region json . put ( str , reg . get puts rate ( ) ) ; region json . put ( str , reg . get lru eviction rate ( ) ) ; decimal format df2 = new decimal format ( pulse constants . decimal _ format _ pattern ) ; cluster . member [ ] cluster members list = cluster . get members ( ) ; list < cluster . member > cluster members l = new array list < cluster . member > ( ) ; for ( string member name : reg . get member name ( ) ) { for ( cluster . member member : cluster members list ) { string name = member . get name ( ) ; name = name . replace ( str , str ) ; string id = member . get id ( ) ; id = id . replace ( str , str ) ; if ( ( member name . equals ( id ) ) | | ( member name . equals ( name ) ) ) { cluster members l . add ( member ) ; } } } collections . sort ( cluster members l , member current heap usage comparator ) ; jsonarray member array = new jsonarray ( ) ; for ( cluster . member member : cluster members l ) { jsonobject region member = new jsonobject ( ) ; region member . put ( str , member . get id ( ) ) ; region member . put ( str , member . get name ( ) ) <s> private object node get selected region json ( cluster cluster , string selected region full path ) { pulse log writer logger = pulse log writer . get logger ( ) ; long total heap size = cluster . get total heap size ( ) ; long total disk usage = cluster . get total bytes on disk ( ) ; cluster . region reg = cluster . get cluster region ( selected region full path ) ; if ( reg ! = null ) { object node region json = mapper . create object node ( ) ; region json . put ( str , reg . get name ( ) ) ; region json . put ( str , reg . get full path ( ) ) ; region json . put ( str , total heap size ) ; region json . put ( str , reg . get system region entry count ( ) ) ; region json . put ( str , reg . get member count ( ) ) ; final string region type = reg . get region type ( ) ; region json . put ( str , region type ) ; region json . put ( str , reg . get gets rate ( ) ) ; region json . put ( str , reg . get puts rate ( ) ) ; region json . put ( str , reg . get lru eviction rate ( ) ) ; decimal format df2 = new decimal format ( pulse constants . decimal _ format _ pattern ) ; cluster . member [ ] cluster members list = cluster . get members ( ) ; list < cluster . member > cluster members l = new array list < cluster . member > ( ) ; for ( string member name : reg . get member name ( ) ) { for ( cluster . member member : cluster members list ) { string name = member . get name ( ) ; name = name . replace ( str , str ) ; string id = member . get id ( ) ; id = id . replace ( str , str ) ; if ( ( member name . equals ( id ) ) | | ( member name . equals ( name ) ) ) { cluster members l . add ( member ) ; } } } collections . sort ( cluster members l , member current heap usage comparator ) ; array node member array = mapper . create array node ( ) ; for ( cluster . member member : cluster members l ) { object node region member = mapper . create object node ( ) ; region member . put ( str , member . get id ( ) ) ; region member . put ( str , member . get name"}
{"source": "the invoking thread ' s contention manager <s> static public contention manager get contention manager ( ) { thread state thread state = base task . get thread state ( ) ; return thread state . manager ( ) ; } <s> static public contention manager get contention manager ( ) { return cm ; }"}
{"source": "the result as a long value , if no result the long value 0 <s> public final long query single long ( string sql cmd , long def val , connection conn ) { object value = query single value ( sql cmd , conn ) ; return ( ( value ! = null ) ? long . parse long ( value . to string ( ) ) : def val ) ; } <s> public final long query single long ( string sql cmd , long def val , connection conn ) { return query single long ( sql cmd , null , def val , conn ) ; }"}
{"source": "the android . telecomm . connection . video provider . <s> public android . telecomm . connection . video provider get video provider ( ) { return m video provider ; } <s> public android . telecom . connection . video provider get video provider ( ) { return m video provider ; }"}
{"source": "a prototype factory containing prototypes for ianswer data ' s , idata references , and question data groups . if a factory doesn ' t yet exist , one is created , and default ianswer data implementing classes are pre - populated . <s> public prototype factory get question elements factory ( ) { if ( question factory = = null ) { question factory = new prototype factory ( ) ; add answer data prototype ( new date data ( ) ) ; add answer data prototype ( new integer data ( ) ) ; add answer data prototype ( new select multi data ( ) ) ; add answer data prototype ( new select one data ( ) ) ; add answer data prototype ( new string data ( ) ) ; add answer data prototype ( new time data ( ) ) ; } return question factory ; } <s> public prototype factory deprecated get question elements factory ( ) { if ( question factory = = null ) { question factory = new prototype factory deprecated ( ) ; add answer data prototype ( new date data ( ) ) ; add answer data prototype ( new integer data ( ) ) ; add answer data prototype ( new select multi data ( ) ) ; add answer data prototype ( new select one data ( ) ) ; add answer data prototype ( new string data ( ) ) ; add answer data prototype ( new time data ( ) ) ; } return question factory ; }"}
{"source": "true if the ranks are equal . <s> public boolean equals ( object other ) { if ( other instanceof pw pair ) { pw pair other pw pair = ( pw pair ) other ; return get rank ( ) = = other pw pair . get rank ( ) ; } return false ; } <s> @ override public boolean equals ( object other ) { if ( this = = other ) { return true ; } if ( other instanceof pw pair ) { pw pair other pw pair = ( pw pair ) other ; return get rank ( ) = = other pw pair . get rank ( ) & & m url device . equals ( other pw pair . m url device ) & & m pws result . equals ( other pw pair . m pws result ) ; } return false ; }"}
{"source": "uri identical to the one provided , with host name swapped with the resolved value <s> static string resolve ( string original host ) { string current host = original host ; if ( is local or ip ( current host ) ) { return original host ; } try { string target host = null ; do { attributes attrs = dir context . get attributes ( current host , new string [ ] { a _ record _ type , cname _ record _ type } ) ; attribute attr = attrs . get ( a _ record _ type ) ; if ( attr ! = null ) { target host = attr . get ( ) . to string ( ) ; } attr = attrs . get ( cname _ record _ type ) ; if ( attr ! = null ) { current host = attr . get ( ) . to string ( ) ; } else { target host = current host ; } } while ( target host = = null ) ; return target host ; } catch ( naming exception e ) { logger . warn ( str + current host + str + original host , e ) ; return original host ; } } <s> public static string resolve ( string original host ) { string current host = original host ; if ( is local or ip ( current host ) ) { return original host ; } try { string target host = null ; do { attributes attrs = dir context . get attributes ( current host , new string [ ] { a _ record _ type , cname _ record _ type } ) ; attribute attr = attrs . get ( a _ record _ type ) ; if ( attr ! = null ) { target host = attr . get ( ) . to string ( ) ; } attr = attrs . get ( cname _ record _ type ) ; if ( attr ! = null ) { current host = attr . get ( ) . to string ( ) ; } else { target host = current host ; } } while ( target host = = null ) ; return target host ; } catch ( naming exception e ) { logger . warn ( str + current host + str + original host , e ) ; return original host ; } }"}
{"source": "the content length of the response , or null if it has not been set <s> public long get response content length ( ) { string content length string = response headers . get first ( headers . content _ length ) ; if ( content length string = = null ) { return null ; } return long . parse long ( content length string ) ; } <s> public long get response content length ( ) { string content length string = response headers . get first ( headers . content _ length ) ; if ( content length string = = null ) { return - num ; } return long . parse long ( content length string ) ; }"}
{"source": "a unique type <s> public static type new type ( string type name ) { type newtype = new type ( type name ) ; type names . put ( type name , newtype ) ; return newtype ; } <s> public static type new type ( string type name ) { if ( type names . contains key ( type name ) ) { return ( type ) type names . get ( type name ) ; } type newtype = new type ( type name ) ; type names . put ( type name , newtype ) ; return newtype ; }"}
{"source": "green value in given position <s> public short get green ( final int i ) { return data [ get1 dindex ( i ) + num ] ; } <s> public short get green ( ) { return data [ get first1 dindex ( ) + num ] ; }"}
{"source": "token stream to tokenize the text <s> public token stream get default token stream ( ) { return tokenization stream ; } <s> public twitter token stream get default token stream ( ) { return tokenization stream ; }"}
{"source": "list of radii , in meters . if there are no rings this returns an empty list . <s> public iterable < double > get radii ( ) { return this . radii ; } <s> public iterable < double > get radii ( ) { if ( this . radii ! = null ) return this . radii ; return collections . empty list ( ) ; }"}
{"source": "the extended fluent pipeline <s> public t v ( ) { return this . add ( new vertices pipe ( ) ) ; } <s> public gremlin pipeline < s , vertex > v ( ) { return this . add ( new vertices pipe ( ) ) ; }"}
{"source": "action forward where the action should flow <s> @ override public action forward execute ( final action mapping mapping , final action form form , final http servlet request request , final http servlet response response ) throws exception { string status msg = request . get parameter ( str ) ; if ( status msg = = null | | status msg . trim ( ) . length ( ) = = num ) { request . set attribute ( str , str ) ; return mapping . find forward ( str ) ; } sasfhelper helper = sasfstatic helper . get helper ( request ) ; social auth manager manager = helper . get auth manager ( ) ; auth provider provider = null ; if ( manager ! = null ) { provider = manager . get current auth provider ( ) ; } if ( provider ! = null ) { try { provider . update status ( status msg ) ; request . set attribute ( str , str ) ; return mapping . find forward ( str ) ; } catch ( social auth exception e ) { request . set attribute ( str , e . get message ( ) ) ; e . print stack trace ( ) ; } } return mapping . find forward ( str ) ; } <s> @ action ( value = str ) public string execute ( ) throws exception { if ( status message = = null | | status message . trim ( ) . length ( ) = = num ) { request . set attribute ( str , str ) ; return str ; } sasfhelper helper = sasfstatic helper . get helper ( request ) ; social auth manager manager = helper . get auth manager ( ) ; auth provider provider = null ; if ( manager ! = null ) { provider = manager . get current auth provider ( ) ; } if ( provider ! = null ) { try { provider . update status ( status message ) ; request . set attribute ( str , str ) ; return str ; } catch ( social auth exception e ) { request . set attribute ( str , e . get message ( ) ) ; e . print stack trace ( ) ; } } return str ; }"}
{"source": "string buffer filled with the penn treebank forms of all trees in the matches panel <s> public string buffer get matches ( ) { string buffer sb = new string buffer ( ) ; for ( int i = num ; i < list . get model ( ) . get size ( ) ; i + + ) { tree t = ( ( tree from file ) list . get model ( ) . get element at ( i ) ) . get tree ( ) ; sb . append ( t . penn string ( ) ) ; sb . append ( str ) ; } return sb ; } <s> public string get matches ( ) { string builder sb = new string builder ( ) ; for ( int i = num , sz = list . get model ( ) . get size ( ) ; i < sz ; i + + ) { tree t = ( ( tree from file ) list . get model ( ) . get element at ( i ) ) . get tree ( ) ; sb . append ( t . penn string ( ) ) ; sb . append ( str ) ; } return sb . to string ( ) ; }"}
{"source": "false if the processing should be aborted . <s> private boolean handle access denied exception ( access denied exception ade ) throws access denied exception { exception to catch event exception to catch event = new exception to catch event ( ade ) ; exception to catch event . set optional ( true ) ; bean manager . fire event ( exception to catch event ) ; if ( ! exception to catch event . is handled ( ) ) { throw ade ; } return false ; } <s> protected runtime exception handle access denied exception ( access denied exception original exception ) { exception to catch event exception to catch event = new exception to catch event ( original exception ) ; this . bean manager . fire event ( exception to catch event ) ; if ( ! exception to catch event . is handled ( ) ) { throw original exception ; } return null ; }"}
{"source": "a image list or null . <s> public final image [ ] get pending images ( ) { return pending images ! = null ? arrays . copy of ( pending images , pending images . length ) : null ; } <s> public final image [ ] get pending images ( ) { return pending images ! = null ? arrays . copy of ( pending images , pending images . length ) : new image [ num ] ; }"}
{"source": "the access token string . <s> public final string get access token ( ) { synchronized ( this . lock ) { return this . token info . get token ( ) ; } } <s> public final string get access token ( ) { synchronized ( this . lock ) { return ( this . token info = = null ) ? null : this . token info . get token ( ) ; } }"}
{"source": "a user spinner adapter or null if there is only one profile . <s> public static user spinner adapter create user spinner adapter ( user manager user manager , context context ) { list < user handle > user profiles = user manager . get user profiles ( ) ; if ( user profiles . size ( ) < num ) { return null ; } user handle my user handle = new user handle ( user handle . my user id ( ) ) ; user profiles . remove ( my user handle ) ; user profiles . add ( num , my user handle ) ; array list < user details > user details = new array list < user details > ( user profiles . size ( ) ) ; final int count = user profiles . size ( ) ; for ( int i = num ; i < count ; i + + ) { user details . add ( new user details ( user profiles . get ( i ) , user manager , context ) ) ; } return new user spinner adapter ( context , user details ) ; } <s> public static user adapter create user spinner adapter ( user manager user manager , context context ) { list < user handle > user profiles = user manager . get user profiles ( ) ; if ( user profiles . size ( ) < num ) { return null ; } user handle my user handle = new user handle ( user handle . my user id ( ) ) ; user profiles . remove ( my user handle ) ; user profiles . add ( num , my user handle ) ; return create user adapter ( user manager , context , user profiles ) ; }"}
{"source": "# put ( string , boolean ) <s> @ override public object put ( object value ) { return put ( value , false ) ; } <s> @ override public object put ( object value ) { return put ( null , value ) ; }"}
{"source": "true : can launch bundle , false : otherwise <s> public boolean preload bundle ( bundle bundle ) { return false ; } <s> public boolean preload bundle ( bundle bundle ) { return true ; }"}
{"source": "the specified heap object . <s> @ suppress warnings ( str ) public static < t > t get object ( heap heap , json value name , class < t > type ) throws heap exception { object o = heap . get ( name . required ( ) . as string ( ) ) ; if ( o ! = null & & ! ( type . is instance ( o ) ) ) { throw new json value exception ( name , str + type . get name ( ) ) ; } return ( t ) o ; } <s> public static < t > t get object ( heap heap , json value name , class < t > type ) throws heap exception { if ( name . is null ( ) ) { return null ; } return get required object ( heap , name , type ) ; }"}
{"source": "the qname of the type <s> public static qname get xsitype ( type entry te ) { qname xml type = null ; if ( te ! = null & & te instanceof element & & te . get ref type ( ) ! = null ) { te = te . get ref type ( ) ; } if ( te ! = null & & te instanceof collection type & & te . get ref type ( ) ! = null ) { te = te . get ref type ( ) ; } if ( te ! = null ) { xml type = te . get qname ( ) ; } return xml type ; } <s> public static qname get xsitype ( parameter param ) { if ( param . get mimetype ( ) ! = null ) { return get mimetype qname ( param . get mimetype ( ) ) ; } qname xml type = null ; type entry te = param . get type ( ) ; if ( te ! = null & & te instanceof element & & te . get ref type ( ) ! = null ) { te = te . get ref type ( ) ; } if ( te ! = null & & te instanceof collection type & & te . get ref type ( ) ! = null ) { te = te . get ref type ( ) ; } if ( te ! = null ) { xml type = te . get qname ( ) ; } return xml type ; }"}
{"source": "host name and port , as a string . <s> public static string get host from url ( string url ) { if ( url . index of ( str ) = = - num ) return url ; int slashes = num ; if ( url . contains ( str ) ) slashes + = num ; string [ ] parts = url . split ( str ) ; if ( parts . length < slashes ) return url ; return parts [ slashes ] ; } <s> public static string get host from url ( string url ) { string authority = get authority from url ( url ) ; int idx = authority . index of ( str ) ; if ( idx = = - num ) return authority ; return authority . substring ( num , idx ) ; }"}
{"source": "the meta object for the containment reference ' state ' . <s> public ereference get change _ state ( ) { return ( ereference ) change eclass . get estructural features ( ) . get ( num ) ; } <s> public eattribute get change _ state ( ) { return ( eattribute ) change eclass . get estructural features ( ) . get ( num ) ; }"}
{"source": "the home directory of phoenix <s> public string get home directory ( ) { return m _ phoenix home ; } <s> public string get home directory ( ) { return m _ loom home ; }"}
{"source": "the extended fluent pipeline <s> public t add ( final pipe pipe ) { this . add pipe ( pipe ) ; return ( t ) this ; } <s> public gremlin pipeline add ( final pipe pipe ) { this . add pipe ( pipe ) ; return this ; }"}
{"source": "absolute path to directory in which native npm call must be performed . basically , the method scans project for package . json file and returns it ' s parent , ignoring \" node _ modules \" <s> public static string get npm working dir ( iproject project , final string . . . ignores ) throws core exception { string working dir = null ; final list < ifile > found files = new array list < > ( ) ; if ( project ! = null & & project . exists ( ) ) { project . accept ( new iresource visitor ( ) { @ override public boolean visit ( iresource resource ) throws core exception { if ( ! found files . is empty ( ) ) { return false ; } else if ( resource . get type ( ) = = iresource . folder & & ignores ! = null ) { for ( string ignore : ignores ) { if ( resource . get name ( ) . equals ( ignore ) ) { return false ; } } } else if ( resource . get type ( ) = = iresource . file & & npm constants . package _ json . equals ( resource . get name ( ) ) ) { found files . add ( ( ifile ) resource ) ; } return true ; } } ) ; } if ( ! found files . is empty ( ) ) { working dir = found files . get ( num ) . get parent ( ) . get full path ( ) . to osstring ( ) ; } return working dir ; } <s> public static ipath get npm working dir ( iproject project , final string . . . ignores ) throws core exception { ipath working dir = null ; final list < ifile > found files = new array list < > ( ) ; if ( project ! = null & & project . exists ( ) ) { project . accept ( new iresource visitor ( ) { @ override public boolean visit ( iresource resource ) throws core exception { if ( ! found files . is empty ( ) ) { return false ; } else if ( resource . get type ( ) = = iresource . folder & & ignores ! = null ) { for ( string ignore : ignores ) { if ( resource . get name ( ) . equals ( ignore ) ) { return false ; } } } else if ( resource . get type ( ) = = iresource . file & & npm constants . package _ json . equals ( resource . get name ( ) ) ) { found files . add ( ( ifile ) resource ) ; } return true ; } } ) ; } if ( ! found files . is empty ( ) ) { working dir = found files . get ( num ) . get parent ( ) . get location ( ) ; } return working dir ; }"}
{"source": "a string which must be null if no business re - identification is needed <s> protected string get new id for ( eobject element _ p ) { return copy physical ids ( ) ? null : ecore util . generate uuid ( ) ; } <s> protected string get new id for ( eobject element _ p ) { return copy xml ids ( ) ? null : ecore util . generate uuid ( ) ; }"}
{"source": "a comet support instance <s> protected comet support resolve multiple native support conflict ( final list < class < ? extends comet support > > available ) { final string builder b = new string builder ( str ) ; for ( class < ? extends comet support > cs : available ) { b . append ( ( cs ! = null ) ? cs . get canonical name ( ) : str ) . append ( str ) ; } b . append ( str + available . get ( num ) ) ; logger . warn ( str , b . to string ( ) ) ; return new comet support ( available . get ( num ) ) ; } <s> protected async support resolve multiple native support conflict ( final list < class < ? extends async support > > available ) { final string builder b = new string builder ( str ) ; for ( class < ? extends async support > cs : available ) { b . append ( ( cs ! = null ) ? cs . get canonical name ( ) : str ) . append ( str ) ; } b . append ( str + available . get ( num ) ) ; logger . warn ( str , b . to string ( ) ) ; return new comet support ( available . get ( num ) ) ; }"}
{"source": "whether it is text <s> public static boolean is text based content type ( string content type ) { return content type . starts with ( str ) | | content type . starts with ( str ) ; } <s> public static boolean is text based content type ( string content type ) { return content type ! = null & & ( content type . starts with ( str ) | | content type . starts with ( str ) ) ; }"}
{"source": "a list with instances of org . mule . module . google . drive . model . org . mule . module . google . drive . model . comment reply <s> @ processor @ oauth protected @ oauth invalidate access token on ( exception = oauth token expired exception . class ) @ inject public list < comment reply > list comment replies ( mule message message , string file id , string comment id , @ optional @ default ( str ) boolean include deleted , @ optional @ default ( str ) int max results , @ optional @ default ( str ) string page token ) throws ioexception { comment reply list response = this . client . replies ( ) . list ( file id , comment id ) . set include deleted ( include deleted ) . set max results ( max results ) . set page token ( page token ) . execute ( ) ; pagination utils . save page token ( next _ page _ token , response . get next page token ( ) , message ) ; return comment reply . value of ( response . get items ( ) , comment reply . class ) ; } <s> @ processor @ oauth protected @ oauth invalidate access token on ( exception = oauth token expired exception . class ) @ paged public paging delegate < comment reply > list comment replies ( final string file id , final string comment id , @ optional @ default ( str ) final boolean include deleted , @ optional @ default ( str ) final int max results , final paging configuration paging configuration ) throws ioexception { return new token based paging delegate < comment reply > ( ) { @ override protected list < comment reply > do get page ( ) throws ioexception { comment reply list response = client . replies ( ) . list ( file id , comment id ) . set include deleted ( include deleted ) . set max results ( max results ) . set page token ( this . get page token ( ) ) . execute ( ) ; this . set page token ( response . get next page token ( ) ) ; return comment reply . value of ( response . get items ( ) , comment reply . class ) ; } } ; }"}
{"source": "the filter extensions string array or null . <s> public string [ ] get filter extensions ( ) { return filter extensions ! = null ? arrays . copy of ( filter extensions , filter extensions . length ) : null ; } <s> public string [ ] get filter extensions ( ) { return filter extensions ! = null ? arrays . copy of ( filter extensions , filter extensions . length ) : new string [ num ] ; }"}
{"source": "table metadata array <s> @ request mapping ( value = str , method = { request method . put } ) @ response body public cube request update cube desc ( @ request body cube request cube request ) throws json processing exception { cube desc desc = deserialize cube desc ( cube request ) ; if ( desc = = null ) { return cube request ; } final string cube name = desc . get name ( ) ; if ( string utils . is empty ( cube name ) ) { return error request ( cube request , str ) ; } metadata manager metadata manager = metadata manager . get instance ( kylin config . get instance from env ( ) ) ; data model desc model desc = null ; if ( string utils . is not empty ( cube request . get model desc data ( ) ) ) { model desc = deserialize data model desc ( cube request ) ; if ( model desc = = null ) { return cube request ; } final string mode name = model desc . get name ( ) ; if ( ! string utils . equals ( desc . get model name ( ) , mode name ) ) { return error request ( cube request , str + desc . get model name ( ) + str + mode name ) ; } data model desc old model desc = metadata manager . get data model desc ( mode name ) ; if ( old model desc = = null ) { return error request ( cube request , str + mode name + str ) ; } if ( ! model desc . compatible with ( old model desc ) ) { return error request ( cube request , str ) ; } } if ( ! cube service . is cube desc editable ( desc ) ) { string error = str + desc . get name ( ) . to upper case ( ) + str ; return error request ( cube request , error ) ; } try { if ( model desc ! = null ) metadata manager . update data model desc ( model desc ) ; cube instance cube = cube service . get cube manager ( ) . get cube ( cube name ) ; string project name = ( null = = cube request . get project ( ) ) ? project instance . default _ project _ name : cube request . get project ( ) ; desc = cube service . update cube and desc ( cube , desc , project name ) ; } catch ( access denied exception access denied exception ) { throw new forbidden exception ( str ) ; } catch ( exception e ) { logger . error ( str + e . get localized message ( ) , <s> @ request mapping ( value = str , method = { request method . put } ) @ response body public cube request update cube desc ( @ request body cube request cube request ) throws json processing exception { cube desc desc = deserialize cube desc ( cube request ) ; if ( desc = = null ) { return cube request ; } final string cube name = cube request . get cube name ( ) ; if ( string utils . is empty ( cube name ) ) { return error request ( cube request , str ) ; } metadata manager metadata manager = metadata manager . get instance ( cube service . get config ( ) ) ; data model desc model desc = null ; data model desc old model desc = null ; if ( string utils . is not empty ( cube request . get model desc data ( ) ) ) { model desc = deserialize data model desc ( cube request ) ; if ( model desc = = null ) { return cube request ; } final string mode name = model desc . get name ( ) ; if ( ! string utils . equals ( desc . get model name ( ) , mode name ) ) { return error request ( cube request , str + desc . get model name ( ) + str + mode name ) ; } old model desc = metadata manager . get data model desc ( mode name ) ; if ( old model desc = = null ) { return error request ( cube request , str + mode name + str ) ; } } if ( ! cube service . is cube desc editable ( desc ) ) { string error = str + desc . get name ( ) . to upper case ( ) + str ; return error request ( cube request , error ) ; } boolean update model success = false , update cube success = false ; try { if ( model desc ! = null ) { metadata manager . update data model desc ( model desc ) ; update model success = true ; } cube instance cube = cube service . get cube manager ( ) . get cube ( cube name ) ; string project name = ( null = = cube request . get project ( ) ) ? project instance . default _ project _ name : cube request . get project ( ) ; desc = cube service . update cube and desc ( cube , desc , project name ) ; project manager project manager = cube service . get project manager ( ) ; if ( ! cube service . is cube in project ( project name , cube ) ) { string owner = security context holder . get context"}
{"source": "whether the segments matches ( in sense of \" be mergable \" ) . <s> private boolean match ( segment ls1 , segment ls2 ) { if ( ls1 . id = = ls2 . id & & ls1 . id ! = num ) return true ; if ( ls1 . incomplete | | ls2 . incomplete ) return false ; return match ( ls1 . from , ls2 . from ) & & match ( ls1 . to , ls2 . to ) ; } <s> private boolean match ( way w1 , way w2 ) { if ( w1 . id = = num | | w2 . id = = num ) { if ( w1 . nodes . size ( ) ! = w2 . nodes . size ( ) ) return false ; iterator < node > it = w1 . nodes . iterator ( ) ; for ( node n : w2 . nodes ) if ( ! match ( n , it . next ( ) ) ) return false ; return true ; } return w1 . id = = w2 . id ; }"}
{"source": "clazzes or null if no color classes were applied <s> public string process code ( string code ) { if ( code = = null | | code . length ( ) < num ) return null ; if ( code . char at ( num ) ! = str & & code . char at ( code . length ( ) - num ) ! = str ) return null ; if ( code . length ( ) = = num ) { clazzes _ . clear ( ) ; return null ; } int extended color = num ; boolean extended marker seen = false ; boolean extended rgbmarker seen = false ; int extended rgbcolors seen = num ; string [ ] tokens = code . substring ( num , code . length ( ) - num ) . split ( str ) ; for ( string token : tokens ) { int code val = string util . parse int ( token , - num ) ; if ( code val = = - num ) continue ; if ( extended color > num ) { if ( ! extended marker seen & & ! extended rgbmarker seen ) { if ( code val = = ext _ by _ index ) { extended marker seen = true ; continue ; } else if ( code val = = ext _ by _ rgb ) { extended rgbmarker seen = true ; extended rgbcolors seen = num ; } else { clazzes _ . clear ( ) ; return null ; } } else { if ( extended rgbmarker seen ) { extended rgbcolors seen + + ; if ( extended rgbcolors seen = = num ) { extended color = num ; extended rgbmarker seen = false ; extended rgbcolors seen = num ; } } else { if ( extended color = = foreground _ ext ) { if ( code val > = num & & code val < = num ) { current color _ . set extended ( code val ) ; reset foreground ( ) ; clazzes _ . add ( color . clazz for color index ( code val , false ) ) ; } } else { if ( code val > = num & & code val < = num ) { current bg color _ . set extended ( code val ) ; reset background ( ) ; clazzes _ . add ( color . clazz for color index ( code val , true ) ) ; } } extended color = num ; extended marker seen = false ; } } } else if ( code val = = reset ) { inverted _ = false ; current color _ . reset ( ) ; current bg <s> public ansi clazzes process code ( string code ) { if ( code = = null | | code . length ( ) < num ) return null ; if ( code . char at ( num ) ! = str & & code . char at ( code . length ( ) - num ) ! = str ) return null ; if ( code . length ( ) = = num ) { clazzes _ . clear ( ) ; block clazzes _ . clear ( ) ; return null ; } int extended color = num ; boolean extended marker seen = false ; boolean extended rgbmarker seen = false ; int extended rgbcolors seen = num ; string [ ] tokens = code . substring ( num , code . length ( ) - num ) . split ( str ) ; for ( string token : tokens ) { int code val = string util . parse int ( token , - num ) ; if ( code val = = - num ) continue ; if ( extended color > num ) { if ( ! extended marker seen & & ! extended rgbmarker seen ) { if ( code val = = ext _ by _ index ) { extended marker seen = true ; continue ; } else if ( code val = = ext _ by _ rgb ) { extended rgbmarker seen = true ; extended rgbcolors seen = num ; } else { clazzes _ . clear ( ) ; block clazzes _ . clear ( ) ; return null ; } } else { if ( extended rgbmarker seen ) { extended rgbcolors seen + + ; if ( extended rgbcolors seen = = num ) { extended color = num ; extended rgbmarker seen = false ; extended rgbcolors seen = num ; } } else { if ( extended color = = foreground _ ext ) { if ( code val > = num & & code val < = num ) { current color _ . set extended ( code val ) ; reset foreground ( ) ; clazzes _ . add ( color . clazz for color index ( code val , false ) ) ; } } else { if ( code val > = num & & code val < = num ) { current bg color _ . set extended ( code val ) ; reset background ( ) ; clazzes _ . add ( color . clazz for color index ( code val , true ) ) ; } } extended color = num ; extended marker seen = false ; } } } else if ( code val"}
{"source": "list of set bits <s> public static integer [ ] to array ( final bit set bit set ) { final list < integer > list = to list ( bit set ) ; return list . to array ( new integer [ list . size ( ) ] ) ; } <s> public static int [ ] to array ( final bit set bit set ) { final int [ ] integers = new int [ bit set . cardinality ( ) ] ; int j = num ; for ( int i = bit set . next set bit ( num ) ; i > = num ; i = bit set . next set bit ( i + num ) ) { integers [ j + + ] = i ; } return integers ; }"}
{"source": "the resulting graph <s> @ deprecated public graph execute sparql query ( construct query query , triple collection default graph ) { return ( graph ) execute sparql query ( ( query ) query , default graph ) ; } <s> @ deprecated public immutable graph execute sparql query ( construct query query , graph default graph ) { return ( immutable graph ) execute sparql query ( ( query ) query , default graph ) ; }"}
{"source": "profiler context <s> public static your kit context start profile ( giraph configuration conf ) { controller controller = null ; try { controller = new controller ( ) ; controller . enable stack telemetry ( ) ; controller . start cpuprofiling ( profiling modes . cpu _ sampling , controller . default _ filters ) ; log . debug ( str ) ; } catch ( exception e ) { log . debug ( str , e ) ; } return new your kit context ( controller ) ; } <s> public static your kit context start profile ( boolean enable stack telemetry , boolean enable cpuprofilling , boolean enable allocation recording ) { controller controller ; try { controller = new controller ( ) ; } catch ( exception e ) { log . info ( str , e ) ; return null ; } try { if ( enable stack telemetry ) { controller . enable stack telemetry ( ) ; log . info ( str ) ; } } catch ( exception e ) { log . info ( str , e ) ; } try { if ( enable cpuprofilling ) { controller . start cpuprofiling ( profiling modes . cpu _ sampling , controller . default _ filters , controller . default _ walltime _ spec ) ; log . info ( str ) ; } } catch ( exception e ) { log . info ( str , e ) ; } try { if ( enable allocation recording ) { controller . start allocation recording ( true , allocation _ recording _ interval , false , - num , true , false ) ; log . info ( str ) ; } } catch ( exception e ) { log . info ( str , e ) ; } return new your kit context ( controller ) ; }"}
{"source": "the list of init params defined in web . xml or application . xml <s> public string get init parameter ( string name ) { try { return framework . get servlet config ( ) . get init parameter ( name ) ; } catch ( throwable ex ) { return null ; } } <s> public string get init parameter ( string name ) { try { string value = framework . get servlet config ( ) . get init parameter ( name ) ; if ( value = = null & & use servlet context parameters ) { value = framework . get servlet context ( ) . get init parameter ( name ) ; } return value ; } catch ( throwable ex ) { return null ; } }"}
{"source": "sentence index or const # nonexist if stack doesn ' t have an element at this index <s> public int get stack ( int k ) { int n stack = get stack size ( ) ; return ( k > = num & & k < n stack ) ? stack . get ( n stack - num - k ) : const . nonexist ; } <s> public int get stack ( int k ) { int n stack = get stack size ( ) ; return ( k > = num & & k < n stack ) ? stack . get ( n stack - num - k ) : config . nonexist ; }"}
{"source": "true if the socket was available , false if we timed - out . <s> private boolean wait for socket ( launcher launcher , int port , int timeout ) { try { local port open task task = new local port open task ( port , timeout ) ; return launcher . get channel ( ) . call ( task ) ; } catch ( interrupted exception ex ) { } catch ( ioexception e ) { } return false ; } <s> private int wait for socket ( launcher launcher , int port , int timeout ) { try { local port receive adb port task task = new local port receive adb port task ( port , timeout ) ; return launcher . get channel ( ) . call ( task ) ; } catch ( interrupted exception ex ) { } catch ( ioexception e ) { } return - num ; }"}
{"source": "true the serive is started <s> public boolean start ( ) { if ( ! is released ( ) ) return native start ( ) ; else return false ; } <s> public boolean start ( ) { if ( is released ( ) ) throw new illegal state exception ( str ) ; return native start ( ) ; }"}
{"source": "the stored value or null if it doesn ' t exist in specified form . <s> public double get extra int ( string key ) { return m extra data . opt int ( key ) ; } <s> public int get extra int ( string key ) throws jsonexception { return m extra data . get int ( key ) ; }"}
{"source": "a list of the combined bullet record so far . the list has a size that is at most the maximum specified by the aggregation . <s> @ override public list < bullet record > get aggregation ( ) { return aggregate ; } <s> @ override public clip get aggregation ( ) { return clip . of ( aggregate ) ; }"}
{"source": "the user account name . \" & lt ; anonymous & gt ; \" is returned if # set user account name ( string ) was never called . <s> public string get user account name ( ) { return username ; } <s> public string get user account name ( ) { return ( ( username ! = null ) ? username : anonymous _ user ) ; }"}
{"source": "the validated collection ( never null for chaining ) <s> public static < t extends collection < ? > > t valid index ( final t collection , final int index , final string message , final object . . . values ) { validate . not null ( collection ) ; if ( index < num | | index > = collection . size ( ) ) { throw new index out of bounds exception ( string . format ( message , values ) ) ; } return collection ; } <s> public static < t extends char sequence > t valid index ( final t chars , final int index , final string message , final object . . . values ) { validate . not null ( chars ) ; if ( index < num | | index > = chars . length ( ) ) { throw new index out of bounds exception ( string . format ( message , values ) ) ; } return chars ; }"}
{"source": "true if the parquet file has nulls false if the parquet file hasn ' t nulls . <s> static boolean has no nulls ( statistics stat ) { return ! stat . is num nulls set ( ) | | stat . get num nulls ( ) = = num ; } <s> static boolean has no nulls ( statistics stat ) { return stat . get num nulls ( ) < = num ; }"}
{"source": "the mapping that was removed or null if the resource was not subscribed to this channel <s> public resource channel remove resource ( resource resource ) { if ( ( this . resource channels = = null ) | | ( resource = = null ) ) { return null ; } resource channel doomed = null ; for ( resource channel rc : this . resource channels ) { if ( resource . equals ( rc . get resource channel pk ( ) . get resource ( ) ) ) { doomed = rc ; break ; } } if ( doomed ! = null ) { this . resource channels . remove ( doomed ) ; } return doomed ; } <s> public resource repo remove resource ( resource resource ) { if ( ( this . resource repos = = null ) | | ( resource = = null ) ) { return null ; } resource repo doomed = null ; for ( resource repo rc : this . resource repos ) { if ( resource . equals ( rc . get resource repo pk ( ) . get resource ( ) ) ) { doomed = rc ; break ; } } if ( doomed ! = null ) { this . resource repos . remove ( doomed ) ; } return doomed ; }"}
{"source": "the annotation type value , or null if the supplied destination is null or can ' t be classified <s> private object to type annotation ( jms destination destination ) { if ( destination = = null ) { return null ; } if ( destination . is queue ( ) ) { if ( destination . is temporary ( ) ) { return temp _ queue _ type ; } else { return queue _ type ; } } else if ( destination . is topic ( ) ) { if ( destination . is temporary ( ) ) { return temp _ topic _ type ; } else { return topic _ type ; } } return null ; } <s> private byte to type annotation ( jms destination destination ) { if ( destination = = null ) { return unknown _ type ; } if ( destination . is queue ( ) ) { if ( destination . is temporary ( ) ) { return temp _ queue _ type ; } else { return queue _ type ; } } else if ( destination . is topic ( ) ) { if ( destination . is temporary ( ) ) { return temp _ topic _ type ; } else { return topic _ type ; } } return unknown _ type ; }"}
{"source": "a hashtable representation of a workflow instance . <s> public static hashtable get xml rpc workflow instance ( workflow instance w inst ) { hashtable workflow instance = new hashtable ( ) ; workflow instance . put ( str , w inst . get current task id ( ) ) ; workflow instance . put ( str , w inst . get status ( ) ) ; workflow instance . put ( str , w inst . get id ( ) ) ; workflow instance . put ( str , get xml rpc workflow ( w inst . get workflow ( ) ) ) ; workflow instance . put ( str , w inst . get start date time iso str ( ) ! = null ? w inst . get start date time iso str ( ) : str ) ; workflow instance . put ( str , w inst . get end date time iso str ( ) ! = null ? w inst . get end date time iso str ( ) : str ) ; workflow instance . put ( str , w inst . get current task start date time iso str ( ) ! = null ? w inst . get current task start date time iso str ( ) : str ) ; workflow instance . put ( str , w inst . get current task end date time iso str ( ) ! = null ? w inst . get current task end date time iso str ( ) : str ) ; workflow instance . put ( str , w inst . get shared context ( ) ! = null ? w inst . get shared context ( ) . get map ( ) : new hashtable ( ) ) ; workflow instance . put ( str , w inst . get priority ( ) ! = null ? string . value of ( w inst . get priority ( ) . get value ( ) ) : string . value of ( priority . get default ( ) . get value ( ) ) ) ; return workflow instance ; } <s> public static hash map get xml rpc workflow instance ( workflow instance w inst ) { hash map workflow instance = new hash map ( ) ; workflow instance . put ( str , w inst . get current task id ( ) ) ; workflow instance . put ( str , w inst . get status ( ) ) ; workflow instance . put ( str , w inst . get id ( ) ) ; workflow instance . put ( str , get xml rpc workflow ( w inst . get workflow ( ) ) ) ; workflow instance . put ( str , w inst . get start date time iso str ( ) ! = null ? w inst . get start date time iso str ( ) : str ) ; workflow instance . put ( str , w inst . get end date time iso str ( ) ! = null ? w inst . get end date time iso str ( ) : str ) ; workflow instance . put ( str , w inst . get current task start date time iso str ( ) ! = null ? w inst . get current task start date time iso str ( ) : str ) ; workflow instance . put ( str , w inst . get current task end date time iso str ( ) ! = null ? w inst . get current task end date time iso str ( ) : str ) ; workflow instance . put ( str , w inst . get shared context ( ) ! = null ? w inst . get shared context ( ) . get map ( ) : new hash map ( ) ) ; workflow instance . put ( str , w inst . get priority ( ) ! = null ? string . value of ( w inst . get priority ( ) . get value ( ) ) : string . value of ( priority . get default ( ) . get value ( ) ) ) ; return workflow instance ; }"}
{"source": "a boolean that is true if this is a time based query window . <s> public boolean should buffer ( ) { window window = running query . get query ( ) . get window ( ) ; return window = = null | | window . is time based ( ) ; } <s> public boolean should buffer ( ) { window window = running query . get query ( ) . get window ( ) ; boolean no window = window = = null ; if ( no window & & is raw ( ) ) { return running query . is timed out ( ) ; } return no window | | window . is time based ( ) ; }"}
{"source": "a json array with the result of the cat nodes request . <s> private json array cat nodes ( string . . . fields ) { final string field names = string . join ( str , fields ) ; final cat request = new cat . nodes builder ( ) . set parameter ( str , field names ) . set parameter ( str , true ) . build ( ) ; final cat result response = jest utils . execute ( jest client , request , ( ) - > str ) ; return gson utils . as json array ( response . get json object ( ) . get ( str ) ) ; } <s> private json node cat nodes ( string . . . fields ) { final string field names = string . join ( str , fields ) ; final cat request = new cat . nodes builder ( ) . set parameter ( str , field names ) . set parameter ( str , true ) . build ( ) ; final cat result response = jest utils . execute ( jest client , request , ( ) - > str ) ; return response . get json object ( ) . path ( str ) ; }"}
{"source": "bundle pause start service . <s> @ override public class < ? extends service > get interface ( ) { return bundle pause start service . class ; } <s> @ override public class < ? extends service > get interface ( ) { return pause transit service . class ; }"}
{"source": "a ravioli <s> public ravioli build ( ) { return new ravioli ( this ) ; } <s> public lob build ( ) { return new lob ( this ) ; }"}
{"source": "the roll cycle <s> public roll cycle get roll cycle ( ) { return roll cycle ; } <s> public roll cycle get roll cycle ( ) { return queue . roll cycle ( ) ; }"}
{"source": "maximum value ( without checking d , d conditions ) <s> private attribute details max deque iterator ( attribute details val object ) { if ( value removed ! = null ) { for ( iterator < attribute details > iterator = max deque . descending iterator ( ) ; iterator . has next ( ) ; ) { double possible max value = iterator . next ( ) . get value ( ) ; if ( possible max value < val object . get value ( ) | | possible max value < = value removed . get value ( ) ) { if ( possible max value < val object . get value ( ) ) { iterator . remove ( ) ; } else if ( value removed . get value ( ) = = possible max value ) { iterator . remove ( ) ; break ; } } else { break ; } } } else { for ( iterator < attribute details > iterator = max deque . descending iterator ( ) ; iterator . has next ( ) ; ) { if ( iterator . next ( ) . get value ( ) < val object . get value ( ) ) { iterator . remove ( ) ; } else { break ; } } } val object . set max threshold ( ) ; max deque . add last ( val object ) ; return max deque . peek ( ) ; } <s> private attribute details max deque iterator ( attribute details val object ) { if ( value removed ! = null ) { for ( iterator < attribute details > iterator = max deque . descending iterator ( ) ; iterator . has next ( ) ; ) { attribute details possible max value = iterator . next ( ) ; if ( possible max value . get value ( ) < val object . get value ( ) | | possible max value . get value ( ) < = value removed . get value ( ) ) { if ( possible max value . get value ( ) < val object . get value ( ) ) { iterator . remove ( ) ; } else if ( value removed . equals ( possible max value ) ) { iterator . remove ( ) ; } } else { break ; } } } else { for ( iterator < attribute details > iterator = max deque . descending iterator ( ) ; iterator . has next ( ) ; ) { if ( iterator . next ( ) . get value ( ) < val object . get value ( ) ) { iterator . remove ( ) ; } else { break ; } } } val object . set max threshold ( ) ; max deque . add last ( val object ) ; return max deque . peek ( ) ; }"}
{"source": "java . rmi . remote . . . <s> public remote get port ( qname port name , class proxy interface ) throws service exception { return get port ( null , port name , proxy interface ) ; } <s> public remote get port ( qname port name , class proxy interface ) throws service exception { remote stub = get generated stub ( port name , proxy interface ) ; return stub ! = null ? stub : get port ( null , port name , proxy interface ) ; }"}
{"source": "the session ' s accessing time in milli seconds since 12 . 00 pm , january 1st , 1970 <s> public long get last accessed time ( ) { if ( last accessed time = = num ) return nativegetcreationtime ( ) ; else return last accessed time ; } <s> public long get last accessed time ( ) { return ( last accessed time = = num ) ? get creation time ( ) : last accessed time ; }"}
{"source": "the validated collection ( never null method for chaining ) <s> public static < t extends collection < ? > > t not empty ( final t collection , final string message , final object . . . values ) { if ( collection = = null ) { throw new null pointer exception ( string . format ( message , values ) ) ; } if ( collection . is empty ( ) ) { throw new illegal argument exception ( string . format ( message , values ) ) ; } return collection ; } <s> public static < t extends char sequence > t not empty ( final t chars , final string message , final object . . . values ) { if ( chars = = null ) { throw new null pointer exception ( string . format ( message , values ) ) ; } if ( chars . length ( ) = = num ) { throw new illegal argument exception ( string . format ( message , values ) ) ; } return chars ; }"}
{"source": "string array of misspelt words <s> public string [ ] check all words ( string words ) { list < string > misspelt words = new array list < string > ( ) ; string word tokenizer tokenizer = new string word tokenizer ( words ) ; while ( tokenizer . has more words ( ) ) { string word = tokenizer . next word ( ) ; if ( ! is word correct ( word , tokenizer . is new sentence ( ) ) ) { misspelt words . add ( word ) ; } } return misspelt words . to array ( new string [ num ] ) ; } <s> public string [ ] check all words ( string words ) { list < string > misspelled words = new array list < string > ( ) ; string word tokenizer tokenizer = new string word tokenizer ( words ) ; while ( tokenizer . has more words ( ) ) { string word = tokenizer . next word ( ) ; if ( ! is word correct ( word , tokenizer . is new sentence ( ) ) ) { misspelled words . add ( word ) ; } } return misspelled words . to array ( new string [ num ] ) ; }"}
{"source": "true if this persistent resource ' s entity has the @ shareable annotation <s> private boolean is shareable ( ) { return get request scope ( ) . get dictionary ( ) . get annotation ( obj . get class ( ) , shareable . class ) ! = null ; } <s> private boolean is shareable ( ) { return get request scope ( ) . get dictionary ( ) . is sharable ( obj . get class ( ) ) ; }"}
{"source": "the count satisfying the above requirements <s> @ transactional ( read only = true ) @ override public int get count ( final list < batch instance status > batch inst status list , final list < batch priority > batch priorities , final boolean is curr usr not req , final string current user , final set < string > current role ) { return batch instance dao . get count ( batch inst status list , batch priorities , is curr usr not req , current role , current user ) ; } <s> @ transactional ( read only = true ) @ override public int get count ( final list < batch instance status > batch inst status list , final list < batch priority > batch priorities , final boolean is curr usr not req , final string current user , final set < string > user roles , ephesoft user ephesoft user ) { return batch instance dao . get count ( batch inst status list , batch priorities , is curr usr not req , user roles , current user , ephesoft user ) ; }"}
{"source": "the symbol drawn at the center of the range fan . may be null . <s> public tactical symbol get symbol ( ) { return this . symbol ; } <s> public string get symbol ( ) { return this . symbol ! = null ? this . symbol . get identifier ( ) : null ; }"}
{"source": "caption for that handle <s> public string get caption ( string handle ) { return get metadata for handle ( handle ) . caption _ ; } <s> public string get caption ( string handle ) { terminal metadata data = get metadata for handle ( handle ) ; if ( data = = null ) { return null ; } return data . caption _ ; }"}
{"source": "vir domain object <s> public vir domain get dom ( ) throws vir error exception { throw new vir error exception ( str ) ; } <s> public domain get dom ( ) throws error exception { throw new error exception ( str ) ; }"}
{"source": "this cloned object <s> @ override public object clone ( ) { try { dbtable clone = ( dbtable ) super . clone ( ) ; class < ? > col class = columns . get ( num ) . get class ( ) ; class < ? > col base = col class . get superclass ( ) ; clone . columns = new array list < dbcolumn > ( ) ; field [ ] fields = get class ( ) . get declared fields ( ) ; for ( int i = num ; i < columns . size ( ) ; i + + ) { dbtable column src col = ( dbtable column ) columns . get ( i ) ; dbtable column new col = new dbtable column ( clone , src col ) ; for ( int j = num ; j < fields . length ; j + + ) { class < ? > type = fields [ j ] . get type ( ) ; if ( type = = col class | | type = = col base ) { try { if ( fields [ j ] . get ( clone ) = = src col ) fields [ j ] . set ( clone , new col ) ; } catch ( exception e ) { log . error ( str + fields [ j ] . get name ( ) + str + e . get message ( ) ) ; } } } } clone . alias = str + string . value of ( table count . increment and get ( ) ) ; log . info ( str + name + str + alias + str + clone . alias ) ; return clone ; } catch ( clone not supported exception e ) { return null ; } } <s> @ override public object clone ( ) { try { dbtable clone = ( dbtable ) super . clone ( ) ; class < ? > col class = columns . get ( num ) . get class ( ) ; class < ? > col base = col class . get superclass ( ) ; clone . columns = new array list < dbcolumn > ( ) ; field [ ] fields = get class ( ) . get fields ( ) ; for ( int i = num ; i < columns . size ( ) ; i + + ) { dbtable column src col = ( dbtable column ) columns . get ( i ) ; dbtable column new col = new dbtable column ( clone , src col ) ; for ( int j = num ; j < fields . length ; j + + ) { class < ? > type = fields [ j ] . get type ( ) ; if ( type = = col class | | type = = col base ) { try { if ( fields [ j ] . get ( clone ) = = src col ) fields [ j ] . set ( clone , new col ) ; } catch ( exception e ) { string field name = fields [ j ] . get name ( ) ; log . error ( str + field name + str + e . get message ( ) ) ; clone not supported exception cnse = new clone not supported exception ( str + field name ) ; cnse . init cause ( e ) ; throw cnse ; } } } } clone . alias = str + string . value of ( table count . increment and get ( ) ) ; log . info ( str + name + str + alias + str + clone . alias ) ; return clone ; } catch ( clone not supported exception e ) { log . error ( str + get name ( ) ) ; throw new runtime exception ( e ) ; } }"}
{"source": "the extended fluent pipeline <s> public t id ( ) { return this . add ( new id pipe ( ) ) ; } <s> public gremlin pipeline id ( ) { return this . add ( new id pipe ( ) ) ; }"}
{"source": "a read - only view of the additional http headers . <s> public map < string , string > get additional http headers ( ) { return collections . unmodifiable map ( additional http headers ) ; } <s> public map < string , string > get additional http headers ( ) { return additional http headers = = null ? null : collections . unmodifiable map ( additional http headers ) ; }"}
{"source": "a matching method or null <s> public static method find method ( operation < ? > operation , method [ ] methods ) { for ( method method : methods ) { if ( match ( operation , method ) ) { return method ; } } return null ; } <s> public static < t > method find method ( class < ? > impl class , operation < t > operation ) throws no such method exception { string name = operation . get name ( ) ; class < ? > [ ] param types = get physical types ( operation ) ; return impl class . get method ( name , param types ) ; }"}
{"source": "the integer value of the method <s> public int get method ( ) { return method ; } <s> public method get method ( ) { return method ; }"}
{"source": "returns the field accessor <s> field accessor get field accessor ( ) { return this . accessor ; } <s> public class field accessor get field accessor ( ) { return this . accessor ; }"}
{"source": "a hashtable which contains all datatypes <s> public hashtable get built in types ( ) { hashtable to return = ( hashtable ) f built in types . clone ( ) ; enumeration xml11 keys = f xml11 built in types . keys ( ) ; while ( xml11 keys . has more elements ( ) ) { object key = xml11 keys . next element ( ) ; to return . put ( key , f xml11 built in types . get ( key ) ) ; } return to return ; } <s> @ override public map < string , datatype validator > get built in types ( ) { final hash map < string , datatype validator > to return = new hash map < > ( f built in types ) ; to return . put all ( xml11 builtintypes ) ; return to return ; }"}
{"source": "item in given position <s> public float get real ( final int i ) { return ( float ) get first value ( i ) ; } <s> public float get real ( ) { return ( float ) get first value ( ) ; }"}
{"source": "the aggregation count <s> public long adder get aggregation count ( ) { return aggregation count ; } <s> @ managed attribute ( description = str ) public long get aggregation count ( ) { return aggregation count . long value ( ) ; }"}
{"source": "the id _ category <s> public long get id ( ) { return id _ category ; } <s> public long get id ( ) { return id ; }"}
{"source": "action forward where the action should flow <s> @ override public action forward execute ( final action mapping mapping , final action form form , final http servlet request request , final http servlet response response ) throws exception { auth form auth form = ( auth form ) form ; string id = auth form . get id ( ) ; social auth manager manager ; if ( auth form . get social auth manager ( ) ! = null ) { manager = auth form . get social auth manager ( ) ; if ( str . equals ( request . get parameter ( str ) ) ) { manager . disconnect provider ( id ) ; return mapping . find forward ( str ) ; } } else { input stream in = social authentication action . class . get class loader ( ) . get resource as stream ( str ) ; social auth config conf = social auth config . get default ( ) ; conf . load ( in ) ; manager = new social auth manager ( ) ; manager . set social auth config ( conf ) ; auth form . set social auth manager ( manager ) ; } string return to url = request utils . absolute url ( request , str ) . to string ( ) ; string url = manager . get authentication url ( id , return to url ) ; log . info ( str + url ) ; if ( url ! = null ) { action forward fwd = new action forward ( str , url , true ) ; return fwd ; } return mapping . find forward ( str ) ; } <s> @ action ( value = str ) public string execute ( ) throws exception { log . info ( str + id ) ; social auth manager manager ; if ( user session . get ( str ) ! = null ) { manager = ( social auth manager ) user session . get ( str ) ; if ( str . equals ( mode ) ) { manager . disconnect provider ( id ) ; return str ; } } else { input stream in = social authentication action . class . get class loader ( ) . get resource as stream ( str ) ; social auth config conf = social auth config . get default ( ) ; conf . load ( in ) ; manager = new social auth manager ( ) ; manager . set social auth config ( conf ) ; user session . put ( str , manager ) ; } string return to url = request utils . get servlet path ( request ) ; system . out . println ( return to url ) ; return to url = url helper . build url ( str , request , response , null , null , true , true , true ) ; url = manager . get authentication url ( id , return to url ) ; log . info ( str + url ) ; if ( url ! = null ) { return str ; } return str ; }"}
{"source": "the parsed test suite or null if no test suite was found . <s> public test suite get suite ( ) { return this . test suite ; } <s> public list < test suite > get suite ( ) { return this . test suites ; }"}
{"source": "this item ' s command , or null if none exists <s> public command get command ( ) { return command ; } <s> @ deprecated public command get command ( ) { command rtn val ; if ( command = = null ) { rtn val = null ; } else if ( command instanceof command ) { rtn val = ( command ) command ; } else { rtn val = new command ( ) { @ override public void execute ( ) { if ( command ! = null ) { command . execute ( ) ; } } } ; } return rtn val ; }"}
{"source": "the test suite . <s> public static test suite ( string name ) { return new test suite ( jtds data source unit test . test _ jtds data source _ get connection . class , name ) ; } <s> public static final test suite ( ) { return null ; }"}
{"source": "the result as a int value , if no result the int value 0 <s> public final int query single int ( string sql cmd , int def val , connection conn ) { object value = query single value ( sql cmd , conn ) ; return object utils . get integer ( value , def val ) ; } <s> public final int query single int ( string sql cmd , int def val , connection conn ) { return query single int ( sql cmd , null , def val , conn ) ; }"}
{"source": "the ddl for all autoincrement columns has been written to the received string buffer . * * <s> public static void reinstate auto increment ( string col name , string table id , string buffer col def ) throws sqlexception { get auto inc stmt . set string ( num , dblook . strip quotes ( col name ) ) ; get auto inc stmt . set string ( num , table id ) ; result set auto inc cols = get auto inc stmt . execute query ( ) ; if ( auto inc cols . next ( ) ) { long start = auto inc cols . get long ( num ) ; if ( ! auto inc cols . was null ( ) ) { col def . append ( str ) ; col def . append ( auto inc cols . get object ( num ) = = null ? str : str ) ; col def . append ( str ) ; col def . append ( auto inc cols . get long ( num ) ) ; col def . append ( str ) ; col def . append ( auto inc cols . get long ( num ) ) ; col def . append ( str ) ; } } return ; } <s> public static boolean reinstate auto increment ( string col name , string table id , string buffer col def ) throws sqlexception { get auto inc stmt . set string ( num , dblook . strip quotes ( col name ) ) ; get auto inc stmt . set string ( num , table id ) ; result set auto inc cols = get auto inc stmt . execute query ( ) ; if ( auto inc cols . next ( ) ) { long start = auto inc cols . get long ( num ) ; if ( ! auto inc cols . was null ( ) ) { col def . append ( str ) ; col def . append ( auto inc cols . get object ( num ) = = null ? str : str ) ; col def . append ( str ) ; col def . append ( auto inc cols . get long ( num ) ) ; col def . append ( str ) ; col def . append ( auto inc cols . get long ( num ) ) ; col def . append ( str ) ; return true ; } } return false ; }"}
{"source": "the id of the last baseline build . <s> public static string get last baseline build ( ) { if ( builds = = null ) { query all variations ( str ) ; } return last _ baseline _ build ; } <s> public static string get last baseline build ( string date ) { if ( builds = = null ) { query all variations ( str ) ; } if ( date = = null ) return last _ baseline _ build ; string last baseline build = null ; for ( int i = num ; i < builds _ length ; i + + ) { string build = builds [ i ] ; if ( build . starts with ( abstract results . version _ ref ) ) { string build date = build . substring ( build . index of ( str ) + num ) ; if ( build date . compare to ( date ) < num ) { if ( last baseline build = = null | | build . compare to ( last baseline build ) > num ) { last baseline build = build ; } } } } return last baseline build ; }"}
{"source": "item in given position <s> @ suppress warnings ( str ) public double get real ( final int i ) { return ( double ) get first value ( i ) ; } <s> @ suppress warnings ( str ) public double get real ( ) { return ( double ) get first value ( ) ; }"}
{"source": "map of healthy worker list to jsonarray ( hostname , port ) <s> private map < string , jsonarray > check workers ( ) { boolean fail job = true ; int poll attempt = num ; list < string > healthy worker list = new array list < string > ( ) ; list < string > unhealthy worker list = new array list < string > ( ) ; int total responses = - num ; while ( poll attempt < max poll attempts ) { get workers ( get superstep ( ) , healthy worker list , unhealthy worker list ) ; total responses = healthy worker list . size ( ) + unhealthy worker list . size ( ) ; if ( ( total responses * num / max workers ) > = min percent responded ) { fail job = false ; break ; } get context ( ) . set status ( get graph mapper ( ) . get map functions ( ) + str + str + total responses + str + max workers + str + get superstep ( ) ) ; if ( get worker health registration changed event ( ) . wait msecs ( msecs poll period ) ) { if ( log . is debug enabled ( ) ) { log . debug ( str + str ) ; } get worker health registration changed event ( ) . reset ( ) ; continue ; } if ( log . is info enabled ( ) ) { log . info ( str + total responses + str + max workers + str + get superstep ( ) + str + msecs poll period + str + poll attempt + str + max poll attempts + str ) ; if ( ( max workers - total responses ) < = partition long tail min print ) { set < integer > partition set = new tree set < integer > ( ) ; for ( string hostname partition id : healthy worker list ) { int last index = hostname partition id . last index of ( str ) ; integer partition = integer . parse int ( hostname partition id . substring ( last index + num ) ) ; partition set . add ( partition ) ; } for ( string hostname partition id : unhealthy worker list ) { int last index = hostname partition id . last index of ( str ) ; integer partition = integer . parse int ( hostname partition id . substring ( last index + num ) ) ; partition set . add ( partition ) ; } for ( int i = num ; i < = max workers ; + + i ) { if ( partition set . contains <s> private list < worker info > check workers ( ) { boolean fail job = true ; int poll attempt = num ; list < worker info > healthy worker info list = new array list < worker info > ( ) ; list < worker info > unhealthy worker info list = new array list < worker info > ( ) ; int total responses = - num ; while ( poll attempt < max poll attempts ) { get all worker infos ( get superstep ( ) , healthy worker info list , unhealthy worker info list ) ; total responses = healthy worker info list . size ( ) + unhealthy worker info list . size ( ) ; if ( ( total responses * num / max workers ) > = min percent responded ) { fail job = false ; break ; } get context ( ) . set status ( get graph mapper ( ) . get map functions ( ) + str + str + total responses + str + max workers + str + get superstep ( ) ) ; if ( get worker health registration changed event ( ) . wait msecs ( msecs poll period ) ) { if ( log . is debug enabled ( ) ) { log . debug ( str + str ) ; } get worker health registration changed event ( ) . reset ( ) ; continue ; } if ( log . is info enabled ( ) ) { log . info ( str + total responses + str + max workers + str + get superstep ( ) + str + msecs poll period + str + poll attempt + str + max poll attempts + str ) ; if ( ( max workers - total responses ) < = partition long tail min print ) { set < integer > partition set = new tree set < integer > ( ) ; for ( worker info worker info : healthy worker info list ) { partition set . add ( worker info . get partition id ( ) ) ; } for ( worker info worker info : unhealthy worker info list ) { partition set . add ( worker info . get partition id ( ) ) ; } for ( int i = num ; i < = max workers ; + + i ) { if ( partition set . contains ( new integer ( i ) ) ) { continue ; } else if ( i = = get task partition ( ) ) { continue ; } else { log . info ( str + str + i + str ) ; } } }"}
{"source": "the list of cassandra instances <s> @ get public list < cassandra instance > find all ( ) { return service . find all ( ) ; } <s> @ get public set < cassandra instance > find all ( ) { return service . find all ( ) ; }"}
{"source": "the map topic configs <s> public map < string , topic config > get topic configs ( ) { return collections . unmodifiable map ( map topic configs ) ; } <s> public map < string , topic config > get topic configs ( ) { return collections . unmodifiable map ( topic configs ) ; }"}
{"source": "row id or - 1 if error todo : is this where csv data is populating the opencellid table ? <s> long insert open cell ( double latitude , double longitude , int mcc , int mnc , int lac , int cell id , int avg sig str , int range , int samples , int is gpsexact , string rat ) { content values cell idvalues = new content values ( ) ; cell idvalues . put ( str , latitude ) ; cell idvalues . put ( str , longitude ) ; cell idvalues . put ( str , mcc ) ; cell idvalues . put ( str , mnc ) ; cell idvalues . put ( str , lac ) ; cell idvalues . put ( str , cell id ) ; cell idvalues . put ( str , avg sig str ) ; cell idvalues . put ( str , range ) ; cell idvalues . put ( str , samples ) ; cell idvalues . put ( str , is gpsexact ) ; cell idvalues . put ( str , rat ) ; if ( open cell exists ( cell id ) ) { log . v ( tag , str + cell id ) ; return num ; } else { return m db . insert ( opencellid _ table , null , cell idvalues ) ; } } <s> long insert open cell ( double latitude , double longitude , int mcc , int mnc , int lac , int cell id , int avg sig str , int range , int samples , int is gpsexact , string rat ) { content values cell idvalues = new content values ( ) ; cell idvalues . put ( str , latitude ) ; cell idvalues . put ( str , longitude ) ; cell idvalues . put ( str , mcc ) ; cell idvalues . put ( str , mnc ) ; cell idvalues . put ( str , lac ) ; cell idvalues . put ( str , cell id ) ; cell idvalues . put ( str , avg sig str ) ; cell idvalues . put ( str , range ) ; cell idvalues . put ( str , samples ) ; cell idvalues . put ( str , is gpsexact ) ; cell idvalues . put ( str , rat ) ; if ( open cell exists ( cell id ) ) { log . v ( tag , m tag + str + cell id ) ; return num ; } else { return m db . insert ( opencellid _ table , null , cell idvalues ) ; } }"}
{"source": "true if evaluation returned at least one item , false otherwise . <s> protected boolean eval xqexpression ( xmldata value xml context ) throws exception { if ( sanity manager . debug ) { sanity manager . assert ( ( query ! = null ) & & ( query . get expression ( ) ! = null ) , str ) ; } document doc node = null ; doc node = d builder . parse ( new input source ( new string reader ( xml context . get string ( ) ) ) ) ; get xpath context ( ) ; xp context . reset ( ) ; xobject x ob = query . execute ( xp context , doc node , null ) ; if ( ( x ob instanceof xnode set ) & & ( ( ( xnode set ) x ob ) . nodelist ( ) . get length ( ) > num ) ) { return true ; } else if ( ! ( x ob instanceof xnode set ) ) return true ; return false ; } <s> protected array list eval xqexpression ( xmldata value xml context , boolean return results , int [ ] result xtype ) throws exception { if ( sanity manager . debug ) { sanity manager . assert ( ( query ! = null ) & & ( query . get expression ( ) ! = null ) , str ) ; } if ( xml context . get xtype ( ) ! = xml . xml _ doc _ any ) { throw standard exception . new exception ( sqlstate . lang _ invalid _ xml _ context _ item , ( return results ? str : str ) ) ; } document doc node = null ; doc node = d builder . parse ( new input source ( new string reader ( xml context . get string ( ) ) ) ) ; get xpath context ( ) ; xp context . reset ( ) ; xobject x ob = query . execute ( xp context , doc node , null ) ; if ( ! return results ) { if ( ( x ob instanceof xnode set ) & & ( ( ( xnode set ) x ob ) . nodelist ( ) . get length ( ) > num ) ) { return new array list ( num ) ; } else if ( ! ( x ob instanceof xnode set ) ) return new array list ( num ) ; else { return null ; } } node list node list = null ; int num items = num ; if ( ! ( x ob instanceof xnode set ) ) num items = num ; else { node list = x ob . nodelist ( ) ; num items = node list . get length ( ) ; } array list item refs = new array list ( ) ; if ( node list = = null ) item refs . add ( x ob . str ( ) ) ; else { for ( int i = num ; i < num items ; i + + ) item refs . add ( node list . item ( i ) ) ; } node list = null ; if ( ( num items = = num ) & & ( ( item refs . get ( num ) instanceof document ) | | ( item refs . get ( num ) instanceof element ) ) ) { result xtype [ num ] = xml . xml _ doc _ any ; } else result xtype [ num ] = xml . xml _ sequence ; return item refs ; }"}
{"source": "the application config object <s> public static application config get module config ( http servlet request request , servlet context context ) { application config app config = ( application config ) request . get attribute ( globals . module _ key ) ; if ( app config = = null ) { app config = ( application config ) context . get attribute ( globals . module _ key ) ; } return app config ; } <s> public static module config get module config ( http servlet request request , servlet context context ) { module config module config = ( module config ) request . get attribute ( globals . module _ key ) ; if ( module config = = null ) { module config = ( module config ) context . get attribute ( globals . module _ key ) ; } return module config ; }"}
{"source": "true if the value was set , false otherwise . <s> boolean set fwk metadata ( string name , string value , boolean create table ) throws sqlexception { if ( boolean . get boolean ( noauto _ create _ metadata ) ) return false ; synchronized ( this . get tree mutex ( ) ) { final boolean should refresh ; if ( create table & & ! this . contains ( metadata _ tablename ) ) { final sqlcreate moveable table create = get create metadata ( get server ( ) . get sqlsystem ( ) . get syntax ( ) ) ; this . get base ( ) . get data source ( ) . execute ( create . as string ( get dbroot ( ) . get name ( ) ) ) ; should refresh = true ; } else should refresh = false ; final boolean res ; if ( create table | | this . contains ( metadata _ tablename ) ) { final sqlname table name = new sqlname ( this . get base ( ) . get name ( ) , this . get name ( ) , metadata _ tablename ) ; final string del = sqlselect . quote ( str , table name , str , name ) ; final string ins = sqlselect . quote ( str , table name , str , str , name , value ) ; sqlutils . execute atomic ( this . get base ( ) . get data source ( ) , new sqlfactory < object > ( ) { public object create ( ) throws sqlexception { get base ( ) . get data source ( ) . execute ( del ) ; get base ( ) . get data source ( ) . execute ( ins ) ; return null ; } } ) ; res = true ; } else res = false ; if ( should refresh ) this . fetch table ( metadata _ tablename ) ; return res ; } } <s> tuple2 < boolean , string > set fwk metadata ( string name , string sql expr , boolean create table ) throws sqlexception { if ( boolean . get boolean ( noauto _ create _ metadata ) ) return tuple2 . create ( false , null ) ; final sqlsystem sys = get server ( ) . get sqlsystem ( ) ; final sqlsyntax syntax = sys . get syntax ( ) ; final sqldata source ds = this . get dbsystem root ( ) . get data source ( ) ; synchronized ( this . get tree mutex ( ) ) { final boolean should refresh ; if ( create table & & ! this . contains ( metadata _ tablename ) ) { final sqlcreate moveable table create = get create metadata ( syntax ) ; ds . execute ( create . as string ( get dbroot ( ) . get name ( ) ) ) ; should refresh = true ; } else { should refresh = false ; } final tuple2 < boolean , string > res ; if ( create table | | this . contains ( metadata _ tablename ) ) { final list < string > queries = new array list < string > ( ) ; final sqlname table name = new sqlname ( this . get base ( ) . get name ( ) , this . get name ( ) , metadata _ tablename ) ; final string where = str + sqlbase . quote identifier ( str ) + str + get base ( ) . quote string ( name ) ; queries . add ( str + table name . quote ( ) + where ) ; final string returning = sys = = sqlsystem . postgresql ? str + sqlbase . quote identifier ( str ) : str ; final string ins = syntax . get insert one ( table name , arrays . as list ( str , str ) , get base ( ) . quote string ( name ) , sql expr ) + returning ; queries . add ( ins ) ; final list < ? extends result set handler > handlers ; if ( returning . length ( ) = = num ) { queries . add ( str + sqlbase . quote identifier ( str ) + str + table name . quote ( ) + where ) ; handlers = arrays . as list ( null , null , sqldata source . scalar _ handler ) ; } else { handlers = arrays . as list ( null , sqldata source . scalar _ handler ) ; } final list < ? >"}
{"source": "rx java observable with connectivity status <s> public observable < connectivity status > observe network connectivity ( final context context ) { final intent filter filter = new intent filter ( ) ; filter . add action ( connectivity manager . connectivity _ action ) ; return observable . create ( new observable . on subscribe < connectivity status > ( ) { @ override public void call ( final subscriber < ? super connectivity status > subscriber ) { final broadcast receiver receiver = new broadcast receiver ( ) { @ override public void on receive ( context context , intent intent ) { final connectivity status new status = get connectivity status ( context ) ; if ( new status ! = status ) { status = new status ; subscriber . on next ( new status ) ; } } } ; context . register receiver ( receiver , filter ) ; subscriber . add ( unsubscribe in ui thread ( new action0 ( ) { @ override public void call ( ) { context . unregister receiver ( receiver ) ; } } ) ) ; } } ) . default if empty ( connectivity status . offline ) ; } <s> public observable < connectivity > observe network connectivity ( final context context ) { final intent filter filter = new intent filter ( ) ; filter . add action ( connectivity manager . connectivity _ action ) ; return observable . create ( new observable . on subscribe < connectivity > ( ) { @ override public void call ( final subscriber < ? super connectivity > subscriber ) { final broadcast receiver receiver = new broadcast receiver ( ) { @ override public void on receive ( context context , intent intent ) { subscriber . on next ( connectivity . create ( context ) ) ; } } ; context . register receiver ( receiver , filter ) ; subscriber . add ( unsubscribe in ui thread ( new action0 ( ) { @ override public void call ( ) { context . unregister receiver ( receiver ) ; } } ) ) ; } } ) . default if empty ( connectivity . create ( ) ) ; }"}
{"source": "the map of action instances to persist , keyed by the class of action . keys with null values indicate actions that should be removed if present . <s> @ non null protected map < class < ? extends action > , action > retrieve actions ( @ non null scmhead head , @ non null task listener listener ) throws ioexception , interrupted exception { return collections . empty map ( ) ; } <s> @ non null protected list < action > retrieve actions ( @ non null scmhead head , @ non null scmhead event event , @ non null task listener listener ) throws ioexception , interrupted exception { return collections . empty list ( ) ; }"}
{"source": "the com . crowdmap . java . sdk . json . maps json response for the specific post <s> public maps json get post maps ( string id ) { return get ( id , segment _ maps , maps json . class ) ; } <s> public maps get post maps ( string id ) { return get ( id , segment _ maps , maps . class ) ; }"}
{"source": "the created project , or null if file was not writable . <s> public static project create thermal project ( file file ) { return create project ( file , type . thermal ) ; } <s> public static project create thermal project ( file file ) { return create project ( file , thermal ) ; }"}
{"source": "the extended fluent pipeline <s> public t in v ( ) { return this . add ( new in vertex pipe ( ) ) ; } <s> public gremlin pipeline < s , vertex > in v ( ) { return this . add ( new in vertex pipe ( ) ) ; }"}
{"source": "the number of the setter . returns a new setter injection component adapter . <s> public component adapter create component adapter ( component characteristic registeration characteristic , object component key , class component implementation , parameter . . . parameters ) throws pico introspection exception , assignability registration exception , not concrete registration exception { return new setter injection component adapter ( component key , component implementation , parameters , current monitor ( ) , lifecycle strategy ) ; } <s> public component adapter create component adapter ( component monitor component monitor , lifecycle strategy lifecycle strategy , component characteristic registeration characteristic , object component key , class component implementation , parameter . . . parameters ) throws pico introspection exception , assignability registration exception , not concrete registration exception { return new setter injection component adapter ( component key , component implementation , parameters , component monitor , lifecycle strategy ) ; }"}
{"source": "the value of this attribute if this attribute is present in the map . otherwise # get default value ( ) <s> public boolean get ( with attributes attributes ) { return attributes . get attributes ( ) . get ( this ) ; } <s> public boolean get ( with attributes with attributes ) { return with attributes . get attributes ( ) . get ( this ) ; }"}
{"source": "the remaining bytes left to be read from the stream <s> public final int get limit ( ) { return remaining bytes ; } <s> public final int get limit ( ) { return remaining characters ; }"}
{"source": "action forward where the action should flow <s> @ override public action forward execute ( final action mapping mapping , final action form form , final http servlet request request , final http servlet response response ) throws exception { sasfhelper helper = sasfstatic helper . get helper ( request ) ; auth form auth form = ( auth form ) form ; string id = auth form . get id ( ) ; string mode = request . get parameter ( str ) ; action forward fwd = null ; if ( mode = = null ) { string filter url = str + id ; fwd = new action forward ( str , filter url , true ) ; } else if ( mode . equals ( str ) ) { social auth manager manager = null ; if ( helper ! = null ) { manager = helper . get auth manager ( ) ; if ( manager ! = null ) manager . disconnect provider ( id ) ; } fwd = mapping . find forward ( str ) ; } return fwd ; } <s> @ action ( value = str ) public string execute ( ) throws exception { log . info ( str + id ) ; sasfhelper helper = sasfstatic helper . get helper ( request ) ; if ( mode = = null ) { url = str + id ; return str ; } else if ( str . equals ( mode ) ) { social auth manager manager = null ; if ( helper ! = null ) { manager = helper . get auth manager ( ) ; if ( manager ! = null ) { manager . disconnect provider ( id ) ; } } return str ; } return str ; }"}
{"source": "# format key ( string , boolean , boolean , boolean ) format colon = false , format at = false , format hyphen = true , first case = true <s> public static string format array key ( string key ) { if ( is array key ( key ) ) { key = string util . add suffix ( key . substring ( num , key . length ( ) - num ) , str ) ; } int index = key = = null ? - num : key . index of ( str ) ; if ( index > = num ) { return key . substring ( index + num ) ; } return format key ( key , false , false , true , true ) ; } <s> public static string format array key ( string key ) { if ( is array key ( key ) ) { key = string util . add suffix ( key . substring ( num , key . length ( ) - num ) , str ) ; } int index = key = = null ? - num : key . index of ( str ) ; if ( index > = num ) { return key . substring ( index + num ) ; } return format key ( key , false , true , true , true ) ; }"}
{"source": "the naemspace uri mapped to the prefix . <s> public string translate namespace prefix to uri ( string prefix ) { namespace context context = get namespace context ( ) ; if ( context ! = null ) { return context . translate namespace prefix to uri ( prefix ) ; } return null ; } <s> public string translate namespace prefix to uri ( string prefix ) { if ( str . equals ( prefix ) ) { return str ; } namespace context context = get namespace context ( ) ; if ( context ! = null ) { return context . translate namespace prefix to uri ( prefix ) ; } return null ; }"}
{"source": "the value of this attribute if this attribute is present in the map . otherwise # get default value ( ) <s> public char get ( with attributes attributes ) { return attributes . get attributes ( ) . get ( this ) ; } <s> public char get ( with attributes with attributes ) { return with attributes . get attributes ( ) . get ( this ) ; }"}
{"source": "the adapter to test <s> private component adapter prep res _ lifecycle manager honors instantiation sequence ( mutable pico container pico container ) { pico container . component ( recording lifecycle . one . class ) ; pooling component adapter pooling component adapter = new pooling component adapter ( new constructor injection component adapter ( recording lifecycle . recorder . class , recording lifecycle . two . class ) ) ; return pico container . adapter ( pooling component adapter ) . last ca ( ) ; } <s> private component adapter prep res _ lifecycle manager honors instantiation sequence ( mutable pico container pico container ) { pico container . add component ( recording lifecycle . one . class ) ; pooling component adapter pooling component adapter = new pooling component adapter ( new constructor injection component adapter ( recording lifecycle . recorder . class , recording lifecycle . two . class ) ) ; return pico container . add adapter ( pooling component adapter ) . last ca ( ) ; }"}
{"source": "if the node is part of exactly one way , return this . null otherwise . <s> private way get way for node ( node n ) { way way = null ; for ( way w : main . ds . ways ) { for ( segment s : w . segments ) { if ( s . from = = n | | s . to = = n ) { if ( way ! = null ) return null ; if ( s . from = = s . to ) return null ; way = w ; } } } return way ; } <s> private way get way for node ( node n ) { way way = null ; for ( way w : main . ds . ways ) { int i = w . nodes . index of ( n ) ; if ( i = = - num ) continue ; if ( i = = num | | i = = w . nodes . size ( ) - num ) { if ( way ! = null ) return null ; way = w ; } } return way ; }"}
{"source": "the first ( source ) graph item <s> public node item get first node ( ) { return m _ node1 ; } <s> public node get first node ( ) { return m _ node1 ; }"}
{"source": "list of persistent resource objects <s> private set < persistent resource > upsert objects ( environment context ) { if ( context . ids . is present ( ) ) { throw new bad request exception ( str ) ; } if ( ! context . data . is present ( ) ) { throw new bad request exception ( str ) ; } class < ? > entity class ; entity dictionary dictionary = context . request scope . get dictionary ( ) ; if ( context . is root ( ) ) { entity class = dictionary . get entity class ( context . field . get name ( ) ) ; } else { entity class = dictionary . get parameterized type ( context . parent resource . get resource class ( ) , context . field . get name ( ) ) ; } optional < entity > parent entity ; if ( ! context . is root ( ) ) { parent entity = optional . of ( new entity ( optional . empty ( ) , null , context . parent resource . get resource class ( ) , context . request scope ) ) ; } else { parent entity = optional . empty ( ) ; } linked hash set < entity > entity set = new linked hash set < > ( ) ; for ( map < string , object > input : context . data . get ( ) ) { entity set . add ( new entity ( parent entity , input , entity class , context . request scope ) ) ; } for ( entity entity : entity set ) { graph walker ( entity , this : : upsert object ) ; } for ( entity entity : entity set ) { graph walker ( entity , this : : update relationship ) ; if ( ! context . is root ( ) ) { context . parent resource . add relation ( context . field . get name ( ) , entity . to persistent resource ( ) ) ; } } return entity set . stream ( ) . map ( entity : : to persistent resource ) . collect ( collectors . to collection ( linked hash set : : new ) ) ; } <s> private connection container upsert objects ( environment context ) { if ( context . ids . is present ( ) ) { throw new bad request exception ( str ) ; } if ( ! context . data . is present ( ) ) { throw new bad request exception ( str ) ; } class < ? > entity class ; entity dictionary dictionary = context . request scope . get dictionary ( ) ; if ( context . is root ( ) ) { entity class = dictionary . get entity class ( context . field . get name ( ) ) ; } else { entity class = dictionary . get parameterized type ( context . parent resource . get resource class ( ) , context . field . get name ( ) ) ; } optional < entity > parent entity ; if ( ! context . is root ( ) ) { parent entity = optional . of ( new entity ( optional . empty ( ) , null , context . parent resource . get resource class ( ) , context . request scope ) ) ; } else { parent entity = optional . empty ( ) ; } linked hash set < entity > entity set = new linked hash set < > ( ) ; for ( map < string , object > input : context . data . get ( ) ) { entity set . add ( new entity ( parent entity , input , entity class , context . request scope ) ) ; } for ( entity entity : entity set ) { graph walker ( entity , ( e ) - > upsert object ( context , e ) ) ; } for ( entity entity : entity set ) { graph walker ( entity , this : : update relationship ) ; if ( ! context . is root ( ) ) { context . parent resource . add relation ( context . field . get name ( ) , entity . to persistent resource ( ) ) ; } } string entity name = dictionary . get json alias for ( entity class ) ; set < persistent resource > resources = entity set . stream ( ) . map ( entity : : to persistent resource ) . collect ( collectors . to collection ( linked hash set : : new ) ) ; return new connection container ( resources , optional . empty ( ) , entity name ) ; }"}
{"source": "an option of the first object of the iteration <s> @ override public optional < type > first ( ) { optional result = optional . empty ( ) ; list < type > list = first ( num ) . as list ( ) ; if ( ! list . is empty ( ) ) { result = optional . of ( list . get ( num ) ) ; } return result ; } <s> @ override public optional < type > first ( ) { iterator < type > result iterator = first ( num ) . iterator ( ) ; return result iterator . has next ( ) ? optional . of ( result iterator . next ( ) ) : optional . empty ( ) ; }"}
{"source": "the adapter to test <s> private component adapter prep def _ lifecycle manager support ( mutable pico container pico container ) { pico container . component ( recording lifecycle . one . class ) ; pooling component adapter pooling component adapter = new pooling component adapter ( new constructor injection component adapter ( recording lifecycle . recorder . class , recording lifecycle . two . class ) ) ; return pico container . adapter ( pooling component adapter ) . last ca ( ) ; } <s> private component adapter prep def _ lifecycle manager support ( mutable pico container pico container ) { pico container . add component ( recording lifecycle . one . class ) ; pooling component adapter pooling component adapter = new pooling component adapter ( new constructor injection component adapter ( recording lifecycle . recorder . class , recording lifecycle . two . class ) ) ; return pico container . add adapter ( pooling component adapter ) . last ca ( ) ; }"}
{"source": "the jenkins job name for the given build config and default namespace <s> public static string jenkins job name ( build config bc , string default namespace ) { string namespace = bc . get metadata ( ) . get namespace ( ) ; string name = bc . get metadata ( ) . get name ( ) ; return jenkins job name ( namespace , name , default namespace ) ; } <s> public static string jenkins job name ( build config bc ) { string namespace = bc . get metadata ( ) . get namespace ( ) ; string name = bc . get metadata ( ) . get name ( ) ; return jenkins job name ( namespace , name ) ; }"}
{"source": "the extension class instance . might be null if the instanciation fails . <s> @ suppress warnings ( str ) public v get instance ( ) { if ( f instance = = null ) { iconfiguration element element = get configuration element ( ) ; assert element ! = null ; if ( element ! = null & & element . get attribute ( str ) ! = null ) { try { f instance = ( v ) element . create executable extension ( str ) ; } catch ( exception e ) { istatus status = new status ( istatus . error , activator . plugin _ id , nls . bind ( tcf plugin messages . extension _ error _ invalid extension point , element . get declaring extension ( ) . get unique identifier ( ) ) , e ) ; activator . get default ( ) . get log ( ) . log ( status ) ; } } } return f instance ; } <s> @ suppress warnings ( str ) public v get instance ( ) { if ( instance = = null & & element . get attribute ( str ) ! = null ) { try { instance = ( v ) element . create executable extension ( str ) ; } catch ( exception e ) { istatus status = new status ( istatus . error , activator . plugin _ id , nls . bind ( tcf plugin messages . extension _ error _ invalid extension point , element . get declaring extension ( ) . get unique identifier ( ) ) , e ) ; activator . get default ( ) . get log ( ) . log ( status ) ; } } return instance ; }"}
{"source": "the istext expert instance . <s> static public istext expert get stateful expert ( stext type handler handler , stext environment environment ) { if ( environment = = null ) environment = stext environment . default ; return new stext impl ( handler , environment , true ) ; } <s> static public istructured text expert get stateful expert ( structured text type handler handler , structured text environment environment ) { if ( environment = = null ) environment = structured text environment . default ; return new structured text impl ( handler , environment , true ) ; }"}
{"source": "list of input splits <s> private list < input split > generate input splits ( int num workers ) { vertex input format < i , v , e , m > vertex input format = get configuration ( ) . create vertex input format ( ) ; list < input split > splits ; try { splits = vertex input format . get splits ( get context ( ) , num workers ) ; float sample percent = get configuration ( ) . get float ( giraph configuration . input _ split _ sample _ percent , giraph configuration . input _ split _ sample _ percent _ default ) ; if ( sample percent ! = giraph configuration . input _ split _ sample _ percent _ default ) { int last index = ( int ) ( sample percent * splits . size ( ) / num ) ; list < input split > sample splits = splits . sub list ( num , last index ) ; log . warn ( str + str + sample splits . size ( ) + str + splits . size ( ) + str ) ; return sample splits ; } else { if ( log . is info enabled ( ) ) { log . info ( str + splits . size ( ) + str + num workers + str ) ; } return splits ; } } catch ( ioexception e ) { throw new illegal state exception ( str , e ) ; } catch ( interrupted exception e ) { throw new illegal state exception ( str , e ) ; } } <s> private list < input split > generate input splits ( giraph input format input format , int num workers , string input split type ) { string log prefix = str + input split type + str ; list < input split > splits ; try { splits = input format . get splits ( get context ( ) , num workers ) ; } catch ( ioexception e ) { throw new illegal state exception ( log prefix + str , e ) ; } catch ( interrupted exception e ) { throw new illegal state exception ( log prefix + str , e ) ; } float sample percent = get configuration ( ) . get float ( giraph configuration . input _ split _ sample _ percent , giraph configuration . input _ split _ sample _ percent _ default ) ; if ( sample percent ! = giraph configuration . input _ split _ sample _ percent _ default ) { int last index = ( int ) ( sample percent * splits . size ( ) / num ) ; list < input split > sample splits = splits . sub list ( num , last index ) ; log . warn ( log prefix + str + sample splits . size ( ) + str + splits . size ( ) + str ) ; return sample splits ; } else { if ( log . is info enabled ( ) ) { log . info ( log prefix + str + splits . size ( ) + str + num workers + str ) ; } return splits ; } }"}
{"source": "result for error in gem fire while executing command . <s> public static result create gem fire error result ( string message ) { return create error result ( errorcode _ gemfire _ error , str + message ) ; } <s> public static result create gem fire error result ( string message ) { return create error result ( errorcode _ geode _ error , str + message ) ; }"}
{"source": "a repository metadata initializer corresponding to the repo class parameter . <s> public repository metadata lookup component ( class < ? > repo class ) { if ( repositories metadata . contains key ( repo class ) ) { return repositories metadata . get ( repo class ) ; } throw new runtime exception ( str + repo class . get name ( ) ) ; } <s> public repository metadata lookup component ( class < ? > repository class ) { if ( repositories metadata . contains key ( repository class ) ) { return repositories metadata . get ( repository class ) ; } throw new runtime exception ( str + repository class . get name ( ) ) ; }"}
{"source": "a response to the given request . <s> @ deprecated protected response serve ( ihttpsession session ) { return response . new fixed length response ( status . not _ found , nano httpd . mime _ plaintext , str ) ; } <s> public response serve ( ihttpsession session ) { map < string , string > files = new hash map < string , string > ( ) ; method method = session . get method ( ) ; if ( method . put . equals ( method ) | | method . post . equals ( method ) ) { try { session . parse body ( files ) ; } catch ( ioexception ioe ) { return response . new fixed length response ( status . internal _ error , nano httpd . mime _ plaintext , str + ioe . get message ( ) ) ; } catch ( response exception re ) { return response . new fixed length response ( re . get status ( ) , nano httpd . mime _ plaintext , re . get message ( ) ) ; } } map < string , string > parms = session . get parms ( ) ; parms . put ( nano httpd . query _ string _ parameter , session . get query parameter string ( ) ) ; return serve ( session . get uri ( ) , method , session . get headers ( ) , parms , files ) ; }"}
{"source": "array list with the views found in the current activity <s> public array list < view > get views ( ) { activity activity = solo activity . get current activity ( ) ; inst . wait for idle sync ( ) ; final window window ; final dialog current dialog = get current dialog ( activity ) ; try { if ( current dialog ! = null ) { window = current dialog . get window ( ) ; } else { window = activity . get window ( ) ; } view decor view = window . get decor view ( ) ; view list . clear ( ) ; get views ( get top parent ( decor view ) ) ; return view list ; } catch ( throwable e ) { e . print stack trace ( ) ; } return null ; } <s> public array list < view > get views ( ) { final activity activity = solo activity . get current activity ( ) ; final dialog current dialog = dialog utils . get current dialog ( ) ; inst . wait for idle sync ( ) ; final window window ; try { if ( current dialog ! = null ) { window = current dialog . get window ( ) ; } else { window = activity . get window ( ) ; } view decor view = window . get decor view ( ) ; view list . clear ( ) ; get views ( get top parent ( decor view ) ) ; return view list ; } catch ( throwable e ) { e . print stack trace ( ) ; } return null ; }"}
{"source": "a list of all actions associated with this branch ( by default , an unmodifiable list searching transient action factorys ) <s> @ non null @ exported ( name = str ) public list < ? extends action > get all actions ( ) { list < action > actions = new array list < action > ( ) ; for ( transient action factory < ? > taf : extension list . lookup ( transient action factory . class ) ) { if ( taf . type ( ) . is instance ( this ) ) { try { actions . add all ( create for ( taf ) ) ; } catch ( exception e ) { logger . log ( level . severe , str + taf + str + this , e ) ; } } } return collections . unmodifiable list ( actions ) ; } <s> @ restricted ( do not use . class ) @ deprecated @ non null public list < ? extends action > get all actions ( ) { return collections . empty list ( ) ; }"}
{"source": "null as the method is not supported <s> public result set meta data get meta data ( ) throws sqlexception { try { debug code call ( str ) ; check closed ( ) ; return null ; } catch ( throwable e ) { throw log and convert ( e ) ; } } <s> public result set meta data get meta data ( ) throws sqlexception { try { debug code call ( str ) ; check closed ( ) ; result interface result = command . get meta data ( ) ; if ( result = = null ) { return null ; } int id = get next id ( trace object . result _ set _ meta _ data ) ; if ( debug ( ) ) { debug code assign ( str , trace object . result _ set _ meta _ data , id ) ; debug code call ( str ) ; } jdbc result set meta data meta = new jdbc result set meta data ( null , this , result , session . get trace ( ) , id ) ; return meta ; } catch ( throwable e ) { throw log and convert ( e ) ; } }"}
{"source": "true or false ; <s> public static boolean is blank ( string original str ) { if ( null = = original str ) { return true ; } if ( original str . contains ( base constant . word _ separator ) ) { return false ; } return trim to empty ( original str ) . is empty ( ) ; } <s> public static boolean is blank ( string . . . original str array ) { if ( null = = original str array | | num = = original str array . length ) return true ; for ( int i = num ; i < original str array . length ; i + + ) { if ( is blank ( original str array [ i ] ) ) return true ; } return false ; }"}
{"source": "the second ( target ) graph item <s> public node item get second node ( ) { return m _ node2 ; } <s> public node get second node ( ) { return m _ node2 ; }"}
{"source": "the host name or ip . <s> public string get selection host ( ) { iselection selection = get selection ( ) ; final atomic reference < string > result = new atomic reference < string > ( ) ; if ( selection instanceof istructured selection & & ! selection . is empty ( ) ) { object element = ( ( istructured selection ) selection ) . get first element ( ) ; if ( element instanceof ipeer model ) { final ipeer model peer model = ( ipeer model ) element ; if ( protocol . is dispatch thread ( ) ) { result . set ( peer model . get peer ( ) . get attributes ( ) . get ( ipeer . attr _ ip _ host ) ) ; } else { protocol . invoke and wait ( new runnable ( ) { @ override public void run ( ) { result . set ( peer model . get peer ( ) . get attributes ( ) . get ( ipeer . attr _ ip _ host ) ) ; } } ) ; } } } return result . get ( ) ; } <s> public string get selection host ( ) { iselection selection = get selection ( ) ; if ( selection instanceof istructured selection & & ! selection . is empty ( ) ) { object element = ( ( istructured selection ) selection ) . get first element ( ) ; iproperties access service service = service manager . get instance ( ) . get service ( element , iproperties access service . class ) ; if ( service ! = null ) { map < string , string > props = service . get target address ( element ) ; if ( props ! = null & & props . contains key ( iproperties access service constants . prop _ address ) ) { return props . get ( iproperties access service constants . prop _ address ) ; } } } return null ; }"}
{"source": "true if the current access token has the publish _ actions permission , false otherwise . <s> public boolean can share ( ) { if ( this . get share content ( ) = = null ) { return false ; } final access token access token = access token . get current access token ( ) ; if ( access token = = null ) { return false ; } final set < string > permissions = access token . get permissions ( ) ; if ( permissions = = null ) { return false ; } return ( permissions . contains ( str ) ) ; } <s> public boolean can share ( ) { if ( this . get share content ( ) = = null ) { return false ; } final access token access token = access token . get current access token ( ) ; if ( access token = = null ) { return false ; } final set < string > permissions = access token . get permissions ( ) ; if ( permissions = = null | | ! permissions . contains ( str ) ) { log . w ( tag , str + str ) ; } return true ; }"}
{"source": "in enum in <s> @ api model property ( required = true , value = str ) public in enum get in ( ) { return in ; } <s> @ api model property ( required = true , value = str ) public string get in ( ) { return in ; }"}
{"source": "the istext expert instance . <s> static public istext expert get stateful expert ( string type ) { return get stateful expert ( type , stext environment . default ) ; } <s> static public istructured text expert get stateful expert ( string type ) { return get stateful expert ( type , structured text environment . default ) ; }"}
{"source": "a list containing all the maps <s> public maps get maps ( ) { set api key ( method _ get , segment _ maps ) ; string response = client . get ( segment _ maps ) ; maps maps json = from string ( response , maps . class ) ; return maps json ; } <s> public maps get maps ( ) { set api key ( method _ get , segment _ maps ) ; return from string ( client . get ( segment _ maps ) , maps . class ) ; }"}
{"source": "true if the clazz ( or one of its superclasses except for object ) implements the given method . returns false if the method doesn ' t exist anywhere in the class hierarchy or it is abstract . <s> static boolean implements method ( type element clazz , method spec method , types type utils ) { executable element method on class = get method on class ( clazz , method , type utils ) ; if ( method on class = = null ) { return false ; } element implementing class = method on class . get enclosing element ( ) ; if ( implementing class . get simple name ( ) . to string ( ) . equals ( str ) ) { return false ; } set < modifier > modifiers = method on class . get modifiers ( ) ; return ! modifiers . contains ( modifier . abstract ) ; } <s> static boolean implements method ( type element clazz , method spec method , types type utils ) { executable element method on class = get method on class ( clazz , method , type utils ) ; if ( method on class = = null ) { return false ; } set < modifier > modifiers = method on class . get modifiers ( ) ; return ! modifiers . contains ( modifier . abstract ) ; }"}
{"source": "iterator for all available versions <s> public integer [ ] get versions ( ) { return versions . key set ( ) . to array ( new integer [ versions . key set ( ) . size ( ) ] ) ; } <s> public integer [ ] get versions ( ) { return vers ; }"}
{"source": "string with no directional formatting characters . <s> public static string deprocess ( string str , stext processor processor ) { if ( ( str = = null ) | | ( str . length ( ) < = num ) | | ! is processing needed ( ) ) return str ; stext environment env = new stext environment ( null , false , stext environment . orient _ unknown ) ; return stext engine . full to lean text ( processor , env , str , null ) ; } <s> public static string deprocess ( string str , stext processor processor ) { if ( ( str = = null ) | | ( str . length ( ) < = num ) ) return str ; stext environment env = new stext environment ( null , false , stext environment . orient _ unknown ) ; if ( ! env . is processing needed ( ) ) return str ; return stext engine . full to lean text ( processor , env , str , null ) ; }"}
{"source": "true if we have enough data to decode the pi frame fully , false if more data is required <s> public boolean decodable ( markable data input in ) throws ioexception { return ( in . available ( ) > = num ) ; } <s> public int decodable ( qpid byte buffer in ) { return ( in . remaining ( ) > = num ) ? num : num - in . remaining ( ) ; }"}
{"source": "a buffer holding the bytes contained in this message . <s> public buffer get content ( ) { return this . facade . get content ( ) ; } <s> public byte buf get content ( ) { return this . facade . get content ( ) ; }"}
{"source": "the main window monitored by sleak . java <s> public main window get sleak window ( ) { device data data = new device data ( ) ; data . tracking = true ; display display = new display ( data ) ; sleak sleak = new sleak ( ) ; sleak . open ( ) ; shell shell = new shell ( display ) ; window = new main window ( shell ) ; return window ; } <s> public main window base get sleak window ( ) { device data data = new device data ( ) ; data . tracking = true ; display display = new display ( data ) ; sleak sleak = new sleak ( ) ; sleak . open ( ) ; shell shell = new shell ( display ) ; window = new main window base ( shell ) ; return window ; }"}
{"source": "the validated collection ( never null method for chaining ) <s> public static < t extends collection < ? > > t not empty ( final t collection ) { return not empty ( collection , default _ not _ empty _ collection _ ex _ message ) ; } <s> public static < t extends char sequence > t not empty ( final t chars ) { return not empty ( chars , default _ not _ empty _ char _ sequence _ ex _ message ) ; }"}
{"source": "auth value factory if parameter matched type <s> @ override public abstract container request value factory < ? > create value factory ( parameter parameter ) { class < ? > class type = parameter . get raw type ( ) ; if ( class type = = null | | ( ! class type . equals ( clazz ) ) ) { return null ; } return new auth value factory < t > ( ) ; } <s> @ override public abstract container request value factory < ? > create value factory ( parameter parameter ) { if ( ! principal class . equals ( parameter . get raw type ( ) ) ) { return null ; } return new abstract container request value factory < principal > ( ) { public principal provide ( ) { final principal principal = get container request ( ) . get security context ( ) . get user principal ( ) ; if ( principal = = null ) { throw new illegal state exception ( str ) ; } return principal ; } } ; }"}
{"source": "true if a message was removed , false otherwise . <s> public boolean remove active message ( ) { return remove message ( current page ) ; } <s> public int remove active message ( ) { return remove message ( current page ) ; }"}
{"source": "an instance of immutable dfa ; null if the builder haven ' t got enough data to create a valid immutable dfa instance . <s> public immutable dfa build dfa ( ) { immutable dfa instance = null ; if ( initial state ! = null ) { instance = new immutable dfa ( ) ; instance . transitions = new hash map < state , map < object , state > > ( transitions ) ; instance . initial state = initial state ; } return instance ; } <s> public immutable dfa build dfa ( ) { if ( _ cached instance = = null ) { if ( initial state ! = null ) { _ cached instance = new immutable dfa ( ) ; _ cached instance . transitions = new hash map < state , map < object , state > > ( transitions ) ; _ cached instance . initial state = initial state ; } } return _ cached instance ; }"}
{"source": "point f determining position of the passed in view inside all of its view parents . <s> protected point f get position in screen ( view view ) { if ( get parent ( ) = = null ) { return new point f ( ) ; } view group parent ; try { parent = ( view group ) view . get parent ( ) ; } catch ( exception e ) { return new point f ( ) ; } if ( parent = = null ) { return new point f ( ) ; } point f point = get position in screen ( parent ) ; point . offset ( view . get x ( ) , view . get y ( ) ) ; return point ; } <s> protected point get position in screen ( view view ) { if ( get parent ( ) = = null ) { return new point ( ) ; } view group parent ; try { parent = ( view group ) view . get parent ( ) ; } catch ( exception e ) { return new point ( ) ; } if ( parent = = null ) { return new point ( ) ; } point point = get position in screen ( parent ) ; point . offset ( ( int ) view . get x ( ) , ( int ) view . get y ( ) ) ; return point ; }"}
{"source": "a list containing sets with projects <s> public list < set < ? > > get project info ( abstract project context ) { comparator custom comparator = new comparator < abstract project > ( ) { public int compare ( abstract project abstract project1 , abstract project abstract project2 ) { return abstract project1 . get full name ( ) . compare to ( abstract project2 . get full name ( ) ) ; } } ; set < abstract project > dynamic project = new tree set < abstract project > ( custom comparator ) ; set < abstract project > static project = new tree set < abstract project > ( custom comparator ) ; set < abstract project > triggered project = new tree set < abstract project > ( custom comparator ) ; set < string > unresolved project = new tree set < string > ( ) ; iterate builds ( context , projects , dynamic project , static project , triggered project , unresolved project ) ; triggered project . remove all ( dynamic project ) ; triggered project . remove all ( static project ) ; return arrays . as list ( static project , dynamic project , triggered project , unresolved project ) ; } <s> public sub project data get project info ( abstract project context ) { sub project data sub project data = new sub project data ( ) ; iterate builds ( context , projects , sub project data ) ; sub project data . get triggered ( ) . remove all ( sub project data . get dynamic ( ) ) ; sub project data . get triggered ( ) . remove all ( sub project data . get fixed ( ) ) ; return sub project data ; }"}
{"source": "list containing projects . <s> private list < project > get projects ( ) { list < project > result = new array list < project > ( ) ; list < project > projects = hudson . get instance ( ) . get projects ( ) ; for ( project project : projects ) { publisher publisher = project . get publisher ( monitor publisher . descriptor ) ; if ( publisher ! = null ) { result . add ( project ) ; } } return result ; } <s> private list < abstract project > get projects ( ) { list < abstract project > result = new array list < abstract project > ( ) ; list < top level item > top level items = hudson . get instance ( ) . get items ( ) ; for ( top level item top level item : top level items ) { if ( top level item instanceof abstract project ) { abstract project abstract project = ( abstract project ) top level item ; if ( abstract project . get publishers list ( ) . get ( monitor publisher . descriptor ) ! = null ) { result . add ( abstract project ) ; } } } return result ; }"}
{"source": "the row id of the newly created row <s> private long insert data ( content values values , boolean caller is sync adapter ) { long id = num ; m values . clear ( ) ; m values . put all ( values ) ; long raw contact id = m values . get as long ( data . raw _ contact _ id ) ; if ( raw contact id = = null ) { throw new illegal argument exception ( data . raw _ contact _ id + str ) ; } final string package name = m values . get as string ( data . res _ package ) ; if ( package name ! = null ) { m values . put ( data columns . package _ id , m db helper . get ( ) . get package id ( package name ) ) ; } m values . remove ( data . res _ package ) ; final string mime type = m values . get as string ( data . mimetype ) ; if ( text utils . is empty ( mime type ) ) { throw new illegal argument exception ( data . mimetype + str ) ; } m values . put ( data columns . mimetype _ id , m db helper . get ( ) . get mime type id ( mime type ) ) ; m values . remove ( data . mimetype ) ; data row handler row handler = get data row handler ( mime type ) ; final sqlite database db = m db helper . get ( ) . get writable database ( ) ; id = row handler . insert ( db , m transaction context . get ( ) , raw contact id , m values ) ; m transaction context . get ( ) . mark raw contact dirty and changed ( raw contact id , caller is sync adapter ) ; m transaction context . get ( ) . raw contact updated ( raw contact id ) ; return id ; } <s> private long insert data ( content values input values , boolean caller is sync adapter ) { final long raw contact id = input values . get as long ( data . raw _ contact _ id ) ; if ( raw contact id = = null ) { throw new illegal argument exception ( data . raw _ contact _ id + str ) ; } final string mime type = input values . get as string ( data . mimetype ) ; if ( text utils . is empty ( mime type ) ) { throw new illegal argument exception ( data . mimetype + str ) ; } final content values values = new content values ( input values ) ; replace package name by package id ( values ) ; values . put ( data columns . mimetype _ id , m db helper . get ( ) . get mime type id ( mime type ) ) ; values . remove ( data . mimetype ) ; final sqlite database db = m db helper . get ( ) . get writable database ( ) ; final transaction context context = m transaction context . get ( ) ; final long data id = get data row handler ( mime type ) . insert ( db , context , raw contact id , values ) ; context . mark raw contact dirty and changed ( raw contact id , caller is sync adapter ) ; context . raw contact updated ( raw contact id ) ; return data id ; }"}
{"source": "the org . atmosphere . cpr . meta broadcaster <s> public static meta broadcaster meta broadcaster ( ) { return meta broadcaster ; } <s> public static default meta broadcaster meta broadcaster ( ) { return meta broadcaster ; }"}
{"source": "ua . <s> public static string get user agent ( ) { string web user agent = null ; try { class < ? > sys res cls = class . for name ( str ) ; field web user agent field = sys res cls . get declared field ( str ) ; integer res id = ( integer ) web user agent field . get ( null ) ; web user agent = no http . get context ( ) . get string ( res id ) ; } catch ( exception e ) { } if ( text utils . is empty ( web user agent ) ) { web user agent = str ; } locale locale = locale . get default ( ) ; string buffer buffer = new string buffer ( ) ; final string version = build . version . release ; if ( version . length ( ) > num ) { buffer . append ( version ) ; } else { buffer . append ( str ) ; } buffer . append ( str ) ; final string language = locale . get language ( ) ; if ( language ! = null ) { buffer . append ( language . to lower case ( locale ) ) ; final string country = locale . get country ( ) ; if ( ! text utils . is empty ( country ) ) { buffer . append ( str ) ; buffer . append ( country . to lower case ( locale ) ) ; } } else { buffer . append ( str ) ; } if ( str . equals ( build . version . codename ) ) { final string model = build . model ; if ( model . length ( ) > num ) { buffer . append ( str ) ; buffer . append ( model ) ; } } final string id = build . id ; if ( id . length ( ) > num ) { buffer . append ( str ) ; buffer . append ( id ) ; } return string . format ( web user agent , buffer , str ) ; } <s> @ deprecated public static string get user agent ( ) { return instance ( ) ; }"}
{"source": "a duplicated token stream <s> public token stream duplicate ( ) { duplicated token stream duplicate = new duplicated token stream ( input stream ) ; duplicated streams . add ( duplicate ) ; return duplicate ; } <s> public twitter token stream duplicate ( ) { duplicated token stream duplicate = new duplicated token stream ( input stream ) ; duplicated streams . add ( duplicate ) ; return duplicate ; }"}
{"source": "the context column object describing the column . <s> private column descriptor get column ( int column index ) { tree tree = viewer . get tree ( ) ; tree column column = tree . get column ( column index ) ; column descriptor context = ( column descriptor ) column . get data ( ) ; return context ; } <s> private column descriptor get column ( int column index ) { tree tree = viewer . get tree ( ) ; tree column column = tree . get column ( column index ) ; column descriptor descriptor = ( column descriptor ) column . get data ( ) ; return descriptor ; }"}
{"source": "icontext menu object <s> public icontext menu get context menu ( ) { if ( context menu = = null ) { context menu = new icontext menu ( ) ; dom . set element property ( context menu . get element ( ) , str , str ) ; } return context menu ; } <s> public vcontext menu get context menu ( ) { if ( context menu = = null ) { context menu = new vcontext menu ( ) ; dom . set element property ( context menu . get element ( ) , str , str ) ; } return context menu ; }"}
{"source": "default temporary workspace <s> public static abstract schema get temporary workspace ( schema plus default schema , drill config config ) { list < string > temporary schema path = lists . new array list ( config . get string ( exec constants . default _ temporary _ workspace ) ) ; abstract schema temporary schema = resolve to mutable drill schema ( default schema , temporary schema path ) ; if ( ! ( temporary schema instanceof workspace schema factory . workspace schema ) ) { drill runtime exception . format ( str + str , temporary schema path ) ; } return temporary schema ; } <s> public static abstract schema get temporary workspace ( schema plus default schema , drill config config ) { string temporary schema = config . get string ( exec constants . default _ temporary _ workspace ) ; list < string > temporary schema path = lists . new array list ( temporary schema ) ; schema plus schema = find schema ( default schema , temporary schema path ) ; return schema = = null ? null : unwrap as drill schema instance ( schema ) ; }"}
{"source": "the new period count <s> public long adder get new period count ( ) { return new period count ; } <s> @ managed attribute ( description = str ) public long get new period count ( ) { return new period count . long value ( ) ; }"}
{"source": "a hbase message instance with message metadata . <s> public static message < hbase id > message meta from result ( configuration conf , result result ) { hbase message message = null ; flags flags = new flags ( ) ; list < property > prop list = new array list < property > ( ) ; key value [ ] keys = result . raw ( ) ; string media type = null , sub type = null ; long mod seq = null , uid , body octets = null , content octets = null , textual line count = null ; date internal date = null ; int i = num ; if ( bytes . equals ( keys [ i ] . get qualifier ( ) , message _ body _ octets ) ) { body octets = bytes . to long ( keys [ i ] . get value ( ) ) ; i + + ; } if ( bytes . equals ( keys [ i ] . get qualifier ( ) , message _ content _ octets ) ) { content octets = bytes . to long ( keys [ i ] . get value ( ) ) ; i + + ; } if ( bytes . equals ( keys [ i ] . get qualifier ( ) , message _ internaldate ) ) { internal date = new date ( bytes . to long ( keys [ i ] . get value ( ) ) ) ; i + + ; } if ( bytes . equals ( keys [ i ] . get qualifier ( ) , message _ text _ line _ count ) ) { textual line count = bytes . to long ( keys [ i ] . get value ( ) ) ; i + + ; } if ( bytes . equals ( keys [ i ] . get qualifier ( ) , message _ modseq ) ) { mod seq = bytes . to long ( keys [ i ] . get value ( ) ) ; i + + ; } if ( bytes . equals ( keys [ i ] . get qualifier ( ) , message _ media _ type ) ) { media type = bytes . to string ( keys [ i ] . get value ( ) ) ; i + + ; } if ( bytes . equals ( keys [ i ] . get qualifier ( ) , message _ sub _ type ) ) { sub type = bytes . to string ( keys [ i ] . get value ( ) ) ; i + + ; } if ( i < num ) { throw new runtime exception ( str ) ; } while ( i < keys . length ) { if <s> public static mailbox message < hbase id > message meta from result ( configuration conf , result result ) { hbase mailbox message message = null ; flags flags = new flags ( ) ; list < property > prop list = new array list < property > ( ) ; key value [ ] keys = result . raw ( ) ; string media type = null , sub type = null ; long mod seq = null , uid , body octets = null , content octets = null , textual line count = null ; date internal date = null ; int i = num ; if ( bytes . equals ( keys [ i ] . get qualifier ( ) , message _ body _ octets ) ) { body octets = bytes . to long ( keys [ i ] . get value ( ) ) ; i + + ; } if ( bytes . equals ( keys [ i ] . get qualifier ( ) , message _ content _ octets ) ) { content octets = bytes . to long ( keys [ i ] . get value ( ) ) ; i + + ; } if ( bytes . equals ( keys [ i ] . get qualifier ( ) , message _ internaldate ) ) { internal date = new date ( bytes . to long ( keys [ i ] . get value ( ) ) ) ; i + + ; } if ( bytes . equals ( keys [ i ] . get qualifier ( ) , message _ text _ line _ count ) ) { textual line count = bytes . to long ( keys [ i ] . get value ( ) ) ; i + + ; } if ( bytes . equals ( keys [ i ] . get qualifier ( ) , message _ modseq ) ) { mod seq = bytes . to long ( keys [ i ] . get value ( ) ) ; i + + ; } if ( bytes . equals ( keys [ i ] . get qualifier ( ) , message _ media _ type ) ) { media type = bytes . to string ( keys [ i ] . get value ( ) ) ; i + + ; } if ( bytes . equals ( keys [ i ] . get qualifier ( ) , message _ sub _ type ) ) { sub type = bytes . to string ( keys [ i ] . get value ( ) ) ; i + + ; } if ( i < num ) { throw new runtime exception ( str ) ; } while ( i < keys . length )"}
{"source": "iserver state <s> public synchronized int get state ( ) { if ( application ! = null ) { app state state = application . get state ( ) ; switch ( state ) { case started : return iserver . state _ started ; case updating : return iserver . state _ starting ; case stopped : return iserver . state _ stopped ; } } return iserver . state _ unknown ; } <s> public synchronized int get state ( ) { if ( this . application ! = null & & this . application . get state ( ) = = app state . stopped ) { return iserver . state _ stopped ; } instance state instance state = get run state ( ) ; if ( instance state ! = null ) { switch ( instance state ) { case running : return iserver . state _ started ; case starting : return iserver . state _ starting ; case down : return iserver . state _ stopped ; } } return iserver . state _ unknown ; }"}
{"source": "returns all axis mapped to an immutable map <s> public immutable map < string , integer > parameters ( ) { return immutable map . of ( str , this . x , str , this . y , str , this . z ) ; } <s> public map < string , integer > parameters ( ) { hash map < string , integer > values = new hash map < > ( ) ; values . put ( str , this . x ) ; values . put ( str , this . y ) ; values . put ( str , this . z ) ; return collections . unmodifiable map ( values ) ; }"}
{"source": "the node as a string <s> public static < t , n extends tree node < t > > string to string ( final n node , final function < n , string > to string ) { final string new line = string . format ( str ) ; return to string recursive ( node , to string , new line ) ; } <s> @ suppress warnings ( str ) public static < t , n extends tree node < t > > string to string ( final n root ) { final function < n , string > to string ; if ( root instanceof node < ? > ) { final node < ? > node = ( node < ? > ) root ; to string = ( function < n , string > ) node . to string function ( ) ; } else { to string = new function < n , string > ( ) { @ override public string apply ( final n input ) { return objects . first non null ( input . get data ( ) , str ) . to string ( ) ; } } ; } return to string ( root , to string ) ; }"}
{"source": "ordinal of field , or - 1 if not found <s> public static int lookup field ( final rel data type row type , string column name ) { final rel data type field [ ] fields = row type . get fields ( ) ; for ( int i = num ; i < fields . length ; i + + ) { rel data type field field = fields [ i ] ; if ( field . get name ( ) . equals ( column name ) ) { return i ; } } return - num ; } <s> public static rel data type field lookup field ( final rel data type row type , string column name ) { final rel data type field [ ] fields = row type . get fields ( ) ; for ( int i = num ; i < fields . length ; i + + ) { rel data type field field = fields [ i ] ; if ( field . get name ( ) . equals ( column name ) ) { return field ; } } return null ; }"}
{"source": "map : from taskid to componentid <s> public map < integer , task info > mk task component assignments ( map < object , object > conf , string topologyid ) throws ioexception , invalid topology exception , key not found exception { map < object , object > storm conf = storm config . read _ nimbus _ topology _ conf ( topologyid , data . get blob store ( ) ) ; storm topology stopology = storm config . read _ nimbus _ topology _ code ( topologyid , data . get blob store ( ) ) ; storm topology topology = common . system _ topology ( storm conf , stopology ) ; return common . mk task info ( storm conf , topology , topologyid ) ; } <s> public map < integer , task info > mk task component assignments ( map < object , object > conf , string topology id ) throws ioexception , invalid topology exception , key not found exception { map < object , object > storm conf = storm config . read _ nimbus _ topology _ conf ( topology id , data . get blob store ( ) ) ; storm topology raw topology = storm config . read _ nimbus _ topology _ code ( topology id , data . get blob store ( ) ) ; storm topology topology = common . system _ topology ( storm conf , raw topology ) ; return common . mk task info ( storm conf , topology , topology id ) ; }"}
{"source": "false if the object is currently assigned to an mbean or if it is not read only <s> public boolean is profile read only ( ) { return profile read only & & ! is management view ( ) ; } <s> public boolean is profile read only ( ) { return profile read only & & ! is management view ( ) & & get profile name ( ) ! = null ; }"}
{"source": "directory name without preceeding path components <s> public string get name ( ) { string name = path . get file name ( ) . to string ( ) ; if ( string utils . ends with ignore case ( name , aes256 cryptor . folder _ extension ) ) { name = name . substring ( num , name . length ( ) - aes256 cryptor . folder _ extension . length ( ) ) ; } return name ; } <s> public string get name ( ) { return string utils . remove end ( path . get file name ( ) . to string ( ) , vault _ file _ extension ) ; }"}
{"source": "returns the distance <s> public int distance to ( world area other ) { if ( this . get plane ( ) ! = other . get plane ( ) ) { return integer . max _ value ; } point distances = get axis distances ( other ) ; return math . max ( distances . get x ( ) , distances . get y ( ) ) ; } <s> public int distance to ( world point other ) { return distance to ( new world area ( other , num , num ) ) ; }"}
{"source": "the parent <s> public virtual file get parent ( ) throws ioexception { virtual file handler parent = get handler ( ) . get parent ( ) ; return parent . get virtual file ( ) ; } <s> public virtual file get parent ( ) throws ioexception { virtual file handler parent = get handler ( ) . get parent ( ) ; if ( parent ! = null ) return parent . get virtual file ( ) ; return null ; }"}
{"source": "the material whose name is the same as the raw arg , or null if no material has that name <s> public material as material from name ( ) { return material . get material ( arg . to upper case ( ) ) ; } <s> public material as material from name ( ) { return material . get material ( raw . to upper case ( ) ) ; }"}
{"source": "url with query params <s> @ suppress warnings ( str ) public static string append ( string url , final map < string , ? > params ) { if ( params = = null | | params . is empty ( ) ) return url ; string builder result = new string builder ( ) ; if ( ! url . ends with ( str ) ) url + = str ; entry < string , ? > entry ; object value ; iterator < ? > iterator = params . entry set ( ) . iterator ( ) ; entry = ( entry < string , ? > ) iterator . next ( ) ; result . append ( entry . get key ( ) ) ; result . append ( str ) ; value = entry . get value ( ) ; if ( value ! = null ) result . append ( value ) ; while ( iterator . has next ( ) ) { result . append ( str ) ; entry = ( entry < string , ? > ) iterator . next ( ) ; result . append ( entry . get key ( ) ) ; result . append ( str ) ; value = entry . get value ( ) ; if ( value ! = null ) result . append ( value ) ; } return url + str + result . to string ( ) ; } <s> @ suppress warnings ( str ) public static string append ( final string url , final map < string , ? > params ) { if ( params = = null | | params . is empty ( ) ) return url ; final string builder result = new string builder ( url ) ; int first colon = url . index of ( str ) ; int last slash = url . last index of ( str ) ; if ( first colon + num = = last slash ) result . append ( str ) ; result . append ( str ) ; entry < string , ? > entry ; object value ; iterator < ? > iterator = params . entry set ( ) . iterator ( ) ; entry = ( entry < string , ? > ) iterator . next ( ) ; result . append ( entry . get key ( ) ) ; result . append ( str ) ; value = entry . get value ( ) ; if ( value ! = null ) result . append ( value ) ; while ( iterator . has next ( ) ) { result . append ( str ) ; entry = ( entry < string , ? > ) iterator . next ( ) ; result . append ( entry . get key ( ) ) ; result . append ( str ) ; value = entry . get value ( ) ; if ( value ! = null ) result . append ( value ) ; } return result . to string ( ) ; }"}
{"source": "a vector containing all compile error messages <s> public vector get warnings ( ) { return _ parser . get warnings ( ) ; } <s> public array list < error msg > get warnings ( ) { return _ parser . get warnings ( ) ; }"}
{"source": "the id <s> public static string get id ( final widget widget ) { return get adapter ( widget ) . get id ( ) ; } <s> public static string get id ( final widget widget ) { string result = ( string ) widget . get data ( custom _ widget _ id ) ; if ( result = = null ) { result = get adapter ( widget ) . get id ( ) ; } return result ; }"}
{"source": "the primary java . net . inet address of the primary network interface or the loopback address as fallback . <s> public static inet address guess primary network address ( ) throws socket exception { final enumeration < network interface > interfaces = network interface . get network interfaces ( ) ; if ( interfaces ! = null ) { for ( network interface interf : collections . list ( interfaces ) ) { if ( ! interf . is loopback ( ) & & interf . is up ( ) ) { for ( inet address addr : collections . list ( interf . get inet addresses ( ) ) ) { if ( addr instanceof inet4 address ) { return addr ; } } } } } return inet address . get loopback address ( ) ; } <s> public static inet address guess primary network address ( boolean prefer ipv4 ) throws socket exception { final enumeration < network interface > interfaces = network interface . get network interfaces ( ) ; if ( interfaces ! = null ) { for ( network interface interf : collections . list ( interfaces ) ) { if ( ! interf . is loopback ( ) & & interf . is up ( ) ) { for ( inet address addr : collections . list ( interf . get inet addresses ( ) ) ) { if ( prefer ipv4 & & addr instanceof inet4 address ) { return addr ; } if ( ! prefer ipv4 & & addr instanceof inet6 address ) { return addr ; } } } } } return inet address . get loopback address ( ) ; }"}
{"source": "true if contact is associated to a rcs raw contact , else false <s> public boolean is rcs associated ( final string phone number ) { return ! get rcs raw contact id from phone number ( phone number ) . is empty ( ) ; } <s> public boolean is rcs associated ( final string phone number ) { boolean result = false ; cursor cur = ctx . get content resolver ( ) . query ( rich address book data . content _ uri , new string [ ] { rich address book data . key _ contact _ number } , rich address book data . key _ contact _ number + str , new string [ ] { phone number } , null ) ; if ( cur ! = null ) { if ( cur . move to first ( ) ) { result = true ; } cur . close ( ) ; } else { result = false ; } return result ; }"}
{"source": "42 . <s> @ override public int hash code ( ) { assert false : str ; return num ; } <s> @ override public int hash code ( ) { int hash = num ; hash = hash * num + ( ( m group id = = null ) ? num : m group id . hash code ( ) ) ; hash = hash * num + m pw pairs . hash code ( ) ; return hash ; }"}
{"source": "an array of classes for all the services <s> class [ ] get service classes ( final class type , final list issues ) { final list services = new array list ( ) ; final class loader class loader = type . get class loader ( ) ; final attribute [ ] attributes = attributes . get attributes ( type , str ) ; for ( int i = num ; i < attributes . length ; i + + ) { final string classname = attributes [ i ] . get parameter ( str ) ; try { final class clazz = class loader . load class ( classname ) ; services . add ( clazz ) ; } catch ( final throwable t ) { final object [ ] args = new object [ ] { classname , t } ; final string message = get message ( str , args ) ; final verify issue issue = new verify issue ( verify issue . error , message ) ; issues . add ( issue ) ; } } return ( class [ ] ) services . to array ( new class [ services . size ( ) ] ) ; } <s> class [ ] get service classes ( final class type , final list issues ) { final service descriptor set set = ( service descriptor set ) type . get annotation ( service descriptor set . class ) ; if ( null ! = set ) { final service descriptor [ ] descriptors = set . value ( ) ; final class [ ] services = new class [ descriptors . length ] ; for ( int i = num ; i < descriptors . length ; i + + ) { service descriptor descriptor = descriptors [ i ] ; services [ i ] = descriptor . type ( ) ; } return services ; } else { return new class [ num ] ; } }"}
{"source": "cache _ mode the type <s> public static cache _ mode get by id ( int id ) throws fx not found exception { for ( cache _ mode mode : cache _ mode . values ( ) ) { if ( mode . id = = id ) return mode ; } throw new fx not found exception ( str , id ) ; } <s> public static cache mode get by id ( int id ) throws fx not found exception { for ( cache mode mode : cache mode . values ( ) ) { if ( mode . id = = id ) return mode ; } throw new fx not found exception ( str , id ) ; }"}
{"source": "a value greater than 0 . <s> public int get http daemon port ( ) { return port ; } <s> public integer get http daemon port ( ) { return port ; }"}
{"source": "true if the specified year / month / day are within the range set by min date and max date . if one or either have not been set , they are considered as integer . min _ value and integer . max _ value . <s> protected boolean is out of range ( int year , int month , int day ) { if ( is before min ( year , month , day ) ) { return true ; } else if ( is after max ( year , month , day ) ) { return true ; } return false ; } <s> protected boolean is out of range ( int year , int month , int day ) { if ( m controller . get selectable days ( ) ! = null ) { return ! is selectable ( year , month , day ) ; } if ( is before min ( year , month , day ) ) { return true ; } else if ( is after max ( year , month , day ) ) { return true ; } return false ; }"}
{"source": "the nested exception or null if there is no nested exception . <s> public throwable get exception ( ) { return cause ; } <s> public throwable get exception ( ) { return get cause ( ) ; }"}
{"source": "table metadata array <s> @ request mapping ( value = str , method = { request method . post } ) @ response body public cube request save cube desc ( @ request body cube request cube request ) { metadata manager meta manager = metadata manager . get instance ( kylin config . get instance from env ( ) ) ; data model desc model desc = deserialize data model desc ( cube request ) ; if ( model desc = = null | | string utils . is empty ( model desc . get name ( ) ) ) { return cube request ; } try { data model desc existing model = meta manager . get data model desc ( model desc . get name ( ) ) ; if ( existing model = = null ) { meta manager . create data model desc ( model desc ) ; } else { model desc . set last modified ( existing model . get last modified ( ) ) ; meta manager . update data model desc ( model desc ) ; } } catch ( ioexception e ) { logger . error ( str + e . get localized message ( ) , e ) ; throw new internal error exception ( str + e . get localized message ( ) ) ; } cube desc desc = deserialize cube desc ( cube request ) ; if ( desc = = null ) { return cube request ; } string name = cube service . get cube name from desc ( desc . get name ( ) ) ; if ( string utils . is empty ( name ) ) { logger . info ( str ) ; throw new bad request exception ( str ) ; } try { desc . set uuid ( uuid . random uuid ( ) . to string ( ) ) ; string project name = ( null = = cube request . get project ( ) ) ? project instance . default _ project _ name : cube request . get project ( ) ; cube service . create cube and desc ( name , project name , desc ) ; } catch ( exception e ) { logger . error ( str , e ) ; throw new internal error exception ( e . get localized message ( ) , e ) ; } cube request . set uuid ( desc . get uuid ( ) ) ; cube request . set successful ( true ) ; return cube request ; } <s> @ request mapping ( value = str , method = { request method . post } ) @ response body public cube request save cube desc ( @ request body cube request cube request ) { metadata manager meta manager = metadata manager . get instance ( cube service . get config ( ) ) ; data model desc model desc = deserialize data model desc ( cube request ) ; if ( model desc = = null ) { return error request ( cube request , str ) ; } if ( string utils . is empty ( model desc . get name ( ) ) ) { return error request ( cube request , str ) ; } try { data model desc existing model = meta manager . get data model desc ( model desc . get name ( ) ) ; if ( existing model = = null ) { meta manager . create data model desc ( model desc ) ; } else { model desc . set last modified ( existing model . get last modified ( ) ) ; meta manager . update data model desc ( model desc ) ; } } catch ( ioexception e ) { logger . error ( str + e . get localized message ( ) , e ) ; throw new internal error exception ( str + e . get localized message ( ) ) ; } cube desc desc = deserialize cube desc ( cube request ) ; if ( desc = = null ) { return cube request ; } if ( string utils . is empty ( desc . get name ( ) ) ) { logger . info ( str ) ; return error request ( cube request , str ) ; } try { desc . set uuid ( uuid . random uuid ( ) . to string ( ) ) ; string project name = ( null = = cube request . get project ( ) ) ? project instance . default _ project _ name : cube request . get project ( ) ; cube instance created cube = cube service . create cube and desc ( desc . get name ( ) , project name , desc ) ; access service . init ( created cube , acl permission . administration ) ; project instance project = cube service . get project manager ( ) . get project ( project name ) ; access service . inherit ( created cube , project ) ; } catch ( exception e ) { logger . error ( str , e ) ; throw new internal error exception ( e . get localized message ( ) , e ) ; } cube request . set uuid ( desc . get uuid ( ) ) ; cube request . set successful ( true ) ; return cube request ; }"}
{"source": "true if the specified configuration failed the operation and threw an exception during the lifecycle operation <s> public boolean was failed ( artifact configuration id ) { return failed . contains key ( configuration id ) ; } <s> public boolean was failed ( artifact configuration id ) { for ( iterator it = failed . key set ( ) . iterator ( ) ; it . has next ( ) ; ) { artifact fail id = ( artifact ) it . next ( ) ; if ( configuration id . matches ( fail id ) ) { return true ; } } return false ; }"}
{"source": "# format key ( string , boolean , boolean , boolean ) format colon = false , format at = false , format hyphen = false , first case = true <s> public static string format object key ( string key ) { int index = key = = null ? - num : key . index of ( str ) ; if ( index > = num ) { return key . substring ( index + num ) ; } return format key ( key , false , false , false , true ) ; } <s> public static string format object key ( string key ) { int index = key = = null ? - num : key . index of ( str ) ; if ( index > = num ) { return key . substring ( index + num ) ; } return format key ( key , false , true , false , true ) ; }"}
{"source": "the iproject associated with the target <s> private iproject get project ( ) { return managed target . get owner ( ) . get project ( ) ; } <s> private iproject get project ( ) { return ( iproject ) managed project . get owner ( ) ; }"}
{"source": "a fully - configured rx client <s> public < rx extends rx invoker > rx client < rx > build rx ( string name , class < rx > invoker type ) { return rx . from ( build ( name ) , invoker type , executor service ) ; } <s> public < rx extends rx invoker provider > client build rx ( string name , class < rx > invoker type ) { return build ( name ) . register ( invoker type ) ; }"}
{"source": "the month of the year as defined by plain calendar <s> public int get month ( ) { return month ; } <s> public int get month ( ) { return date . get month value ( ) ; }"}
{"source": "a hashtable representation of a workflow . <s> public static hashtable get xml rpc workflow ( workflow w ) { hashtable workflow = new hashtable ( ) ; workflow . put ( str , w . get id ( ) ) ; workflow . put ( str , w . get name ( ) ! = null ? w . get name ( ) : str ) ; workflow . put ( str , get xml rpc workflow tasks ( w . get tasks ( ) ) ) ; workflow . put ( str , get xml rpc workflow conditions ( w . get conditions ( ) ) ) ; return workflow ; } <s> public static hash map get xml rpc workflow ( workflow w ) { hash map workflow = new hash map ( ) ; workflow . put ( str , w . get id ( ) ) ; workflow . put ( str , w . get name ( ) ! = null ? w . get name ( ) : str ) ; workflow . put ( str , get xml rpc workflow tasks ( w . get tasks ( ) ) ) ; workflow . put ( str , get xml rpc workflow conditions ( w . get conditions ( ) ) ) ; return workflow ; }"}
{"source": "a string representation of this map <s> @ override public string to string ( ) { node < k , v > [ ] t ; int f = ( t = table ) = = null ? num : t . length ; traverser < k , v > it = new traverser < k , v > ( t , f , num , f ) ; string builder sb = new string builder ( ) ; sb . append ( str ) ; node < k , v > p ; if ( ( p = it . advance ( ) ) ! = null ) { for ( ; ; ) { k k = p . key ; v v = p . val ; sb . append ( k = = this ? str : k ) ; sb . append ( str ) ; sb . append ( v = = this ? str : v ) ; if ( ( p = it . advance ( ) ) = = null ) { break ; } sb . append ( str ) . append ( str ) ; } } return sb . append ( str ) . to string ( ) ; } <s> @ override public final string to string ( ) { string builder sb = new string builder ( ) ; sb . append ( str ) ; iterator < e > it = iterator ( ) ; if ( it . has next ( ) ) { for ( ; ; ) { object e = it . next ( ) ; sb . append ( e = = this ? str : e ) ; if ( ! it . has next ( ) ) { break ; } sb . append ( str ) . append ( str ) ; } } return sb . append ( str ) . to string ( ) ; }"}
{"source": "a applyer that will convert strings into that type , or null if the given type is not a primitive type <s> protected function get type function ( class a type ) { return ( function ) type functions . get ( a type ) ; } <s> protected function < ? , ? > get type function ( class < ? > a type ) { return ( function < ? , ? > ) default functions . get ( a type ) ; }"}
{"source": "the wrapped lockable mgraph . <s> public lockable mgraph get unsecured mgraph ( ) { check write ( ) ; return wrapped ; } <s> public lockable mgraph get unsecured mgraph ( ) { try { check write ( ) ; return wrapped ; } catch ( access control exception ex ) { check read ( ) ; return new write blocked mgraph ( wrapped ) ; } }"}
{"source": "a collection of all known directly implemented class infos . <s> public collection < class info > get interfaces ( ) { return interfaces ; } <s> public set < class info > get interfaces ( ) { string [ ] names = class gen . get interface names ( ) ; set < class info > interfaces = new hash set < class info > ( names . length ) ; for ( string name : names ) { class info cls = get app info ( ) . get class info ( name ) ; if ( cls ! = null ) { interfaces . add ( cls ) ; } } return interfaces ; }"}
{"source": "a criterion that the field must be equal to the given string , ignoring case . due to a bug in sqlite , this will only work for ascii characters . <s> public criterion eq case insensitive ( string value ) { if ( value = = null ) { return is null ( ) ; } return new binary criterion ( this , operator . eq , value ) { @ override protected void after populate operator ( sql builder builder , boolean for sql validation ) { super . after populate operator ( builder , for sql validation ) ; builder . sql . append ( str ) ; } } ; } <s> public criterion eq case insensitive ( string value ) { if ( value = = null ) { return is null ( ) ; } return new case insensitive equals criterion ( this , operator . eq , value ) ; }"}
{"source": "the number of bits <s> public static function < product item , integer > os bits ( ) { return new function < product item , integer > ( ) { @ override public integer apply ( product item product item ) { check not null ( product item , str ) ; matcher m = os _ bits _ pattern . matcher ( product item . get description ( ) ) ; if ( m . matches ( ) ) { return integer . parse int ( m . group ( num ) ) ; } else { throw new no such element exception ( str + product item ) ; } } } ; } <s> public static function < string , integer > os bits ( ) { return new function < string , integer > ( ) { @ override public integer apply ( string description ) { if ( description ! = null ) { matcher m = os _ bits _ pattern . matcher ( description ) ; if ( m . matches ( ) ) { return integer . parse int ( m . group ( num ) ) ; } } return null ; } } ; }"}
{"source": "array of extension registration elements or null if this container has no contributions . <s> public synchronized iconfiguration element [ ] get container extensions ( string containerid ) { if ( container to extensions = = null ) process proxy extension extension point ( ) ; return ( iconfiguration element [ ] ) container to extensions . get ( containerid ) ; } <s> public synchronized iconfiguration element [ ] get container extensions ( string containerid , string [ ] container paths ) { if ( extensions = = null ) process proxy extension extension point ( ) ; return ( iconfiguration element [ ] ) extensions . container path contributions . get contributors ( containerid , container paths ) ; }"}
{"source": "the new dbcompare col expr object <s> public dbcompare col expr in ( object value ) { return cmp ( dbcmp type . in , list to array ( value ) ) ; } <s> public final dbcompare col expr in ( collection < ? > values ) { if ( values = = null | | values . is empty ( ) ) return cmp ( dbcmp type . equal , null ) ; return cmp ( dbcmp type . in , values ) ; }"}
{"source": "boolean returns a boolean to indicate whether the operation was successful . <s> public boolean remove ( string tag id , string category ) { return is category valid ( category ) & & m selected topics . remove ( tag id ) ; } <s> public boolean remove ( tag tag ) { return m selected topics . remove ( tag ) ; }"}
{"source": "the height of the collapsed bottom sheet . <s> public final int get peek height ( ) { return m peek height ; } <s> public final int get peek height ( ) { return m peek height auto ? peek _ height _ auto : m peek height ; }"}
{"source": "the category <s> public category get category ( ) { return payload . category ; } <s> public category get category ( ) { if ( payload ! = null ) { return payload . category ; } return null ; }"}
{"source": "embed parameter set meta data for the prepared statement . note : there is no separate brokered parameter set meta data . <s> protected embed parameter set meta data get parameter meta data ( ) throws sqlexception { if ( stmt pmeta ! = null ) return stmt pmeta ; embed parameter set meta data pmeta = null ; class [ ] get parameter meta data param = { } ; try { method sh = get prepared statement ( ) . get class ( ) . get method ( str , get parameter meta data param ) ; pmeta = ( embed parameter set meta data ) sh . invoke ( get prepared statement ( ) , null ) ; stmt pmeta = pmeta ; } catch ( exception e ) { handle reflection exception ( e ) ; } return stmt pmeta ; } <s> protected engine parameter meta data get parameter meta data ( ) throws sqlexception { if ( stmt pmeta ! = null ) return stmt pmeta ; stmt pmeta = ( ( engine prepared statement ) ps ) . get embed parameter set meta data ( ) ; return stmt pmeta ; }"}
{"source": "a resul set that contains the data produced by the query <s> public result set execute query ( string sql ) throws sqlexception { if ( type = = result set . type _ forward _ only & & concurrency = = result set . concur _ read _ only ) { return internal execute query ( get tds ( sql ) , sql ) ; } else { return new freetds . cursor result set ( this , sql ) ; } } <s> public result set execute query ( string sql ) throws sqlexception { if ( type = = result set . type _ forward _ only & & concurrency = = result set . concur _ read _ only ) { result set rs = internal execute query ( sql ) ; if ( rs ! = null ) return rs ; else throw new sqlexception ( str ) ; } else return new freetds . cursor result set ( this , sql ) ; }"}
{"source": "the sql to create the synonym . if the dbms is not oracle an empty string <s> public string get synonym source ( string an owner , string a synonym ) { if ( ! this . is oracle ) return str ; string result = null ; try { result = synonym reader . get synonym source ( this . db connection . get sql connection ( ) , an owner , a synonym ) ; } catch ( exception e ) { result = str ; } return result ; } <s> public string get synonym source ( string an owner , string a synonym ) { if ( this . synonym reader = = null ) return str ; string result = null ; try { result = this . synonym reader . get synonym source ( this . db connection . get sql connection ( ) , an owner , a synonym ) ; } catch ( exception e ) { result = str ; } return result ; }"}
{"source": "a new annotation model for the editor input <s> private iannotation model create external search annotation model ( external editor input external input ) { istorage storage = external input . get storage ( ) ; iresource resource to use for marker = null ; ifile resource file = cuiplugin . get workspace ( ) . get root ( ) . get file for location ( storage . get full path ( ) ) ; if ( resource file = = null ) { resource to use for marker = external input . get marker resource ( ) ; if ( null = = resource to use for marker ) { iproject [ ] proj = cuiplugin . get workspace ( ) . get root ( ) . get projects ( ) ; for ( int i = num ; i < proj . length ; i + + ) { if ( proj [ i ] . is open ( ) ) { resource to use for marker = proj [ i ] ; break ; } } } } else { resource to use for marker = resource file . get project ( ) ; } if ( resource to use for marker ! = null ) { external search annotation model model = new external search annotation model ( resource to use for marker , storage ) ; return model ; } return null ; } <s> private iannotation model create external search annotation model ( external editor input external input ) { istorage storage = external input . get storage ( ) ; iresource marker resource = external input . get marker resource ( ) ; return create external search annotation model ( storage , marker resource ) ; }"}
{"source": "parsed git hub repository name or null if it cannot be parsed from the specified url <s> public static git hub repository name create ( final string url ) { logger . log ( level . fine , str , url ) ; for ( pattern p : url _ patterns ) { matcher m = p . matcher ( url . trim ( ) ) ; if ( m . matches ( ) ) { logger . log ( level . fine , str , m ) ; git hub repository name ret = new git hub repository name ( m . group ( num ) , m . group ( num ) , m . group ( num ) ) ; logger . log ( level . fine , str , ret ) ; return ret ; } } logger . log ( level . warning , str , url ) ; return null ; } <s> public static gitlab repository name create ( final string url ) { logger . log ( level . fine , str , url ) ; for ( pattern p : url _ patterns ) { matcher m = p . matcher ( url . trim ( ) ) ; if ( m . matches ( ) ) { logger . log ( level . fine , str , m ) ; gitlab repository name ret = new gitlab repository name ( m . group ( num ) , m . group ( num ) , m . group ( num ) ) ; logger . log ( level . fine , str , ret ) ; return ret ; } } logger . log ( level . warning , str , url ) ; return null ; }"}
{"source": "a map of the values ( for each value that exists ) <s> public map < string , object > get ( string . . . keys ) { final map < string , object > rv = new concurrent hash map < string , object > ( ) ; final atomic integer requests = new atomic integer ( ) ; final synchronization object < atomic integer > sync = new synchronization object < atomic integer > ( requests ) ; get operation . callback cb = new get operation . callback ( ) { public void get complete ( ) { requests . decrement and get ( ) ; sync . set ( requests ) ; } public void got data ( string k , int flags , byte [ ] data ) { rv . put ( k , transcoder . decode ( new cached data ( flags , data ) ) ) ; } } ; map < integer , collection < string > > chunks = new hash map < integer , collection < string > > ( ) ; for ( string key : keys ) { int which = get server for key ( key ) ; collection < string > ks = chunks . get ( which ) ; if ( ks = = null ) { ks = new array list < string > ( ) ; chunks . put ( which , ks ) ; } ks . add ( key ) ; } for ( map . entry < integer , collection < string > > me : chunks . entry set ( ) ) { requests . increment and get ( ) ; add op ( me . get key ( ) , new get operation ( me . get value ( ) , cb ) ) ; } try { sync . wait until true ( new synchronization object . predicate < atomic integer > ( ) { public boolean evaluate ( atomic integer val ) { return val . get ( ) = = num ; } } , long . max _ value , time unit . seconds ) ; } catch ( interrupted exception e ) { throw new runtime exception ( str , e ) ; } catch ( timeout exception e ) { throw new runtime exception ( str , e ) ; } return rv ; } <s> public object get ( long timeout , string key ) throws timeout exception { synchronization object < cached data [ ] > sync = setup get ( key ) ; wait for not null ( timeout , sync ) ; cached data [ ] rv container = sync . get ( ) ; assert rv container . length = = num ; object rv = null ; if ( rv container [ num ] ! = null ) { rv = transcoder . decode ( rv container [ num ] ) ; } return rv ; }"}
{"source": "number of entries that were evicted from the cache <s> public long remove all ( predicate < k > match ) { long num evicted entries = num ; list < cache entry < k , v > > matching entries from eviction queue ; synchronized ( this ) { matching entries from eviction queue = get matching entries from eviction queue ( match ) ; num evicted entries + = matching entries from eviction queue . size ( ) ; for ( cache entry < k , v > cache entry : matching entries from eviction queue ) { remove from eviction queue ( cache entry ) ; remove from cached entries ( cache entry ) ; m memory cache index . remove entry ( cache entry . key , cache entry . value ) ; } list < cache entry < k , v > > matching cached entries = get matching cached entries ( match ) ; num evicted entries + = matching cached entries . size ( ) ; for ( cache entry < k , v > cache entry : matching cached entries ) { move from cached entries to orphans ( cache entry ) ; m memory cache index . remove entry ( cache entry . key , cache entry . value ) ; } } for ( cache entry < k , v > cache entry : matching entries from eviction queue ) { cache entry . value . close ( ) ; } return num evicted entries ; } <s> public int remove all ( predicate < k > predicate ) { array list < entry < k , v > > old entries ; synchronized ( this ) { m exclusive entries . remove all ( predicate ) ; old entries = m cached entries . remove all ( predicate ) ; make orphans ( old entries ) ; } maybe close ( old entries ) ; maybe update cache params ( ) ; maybe evict entries ( ) ; return old entries . size ( ) ; }"}
{"source": "current number of hosts for this bucket <s> private int update redundancy ( ) { int desired redundancy = this . p region . get redundant copies ( ) ; int num bucket hosts = get num initialized buckets ( ) ; if ( is closed ( ) ) { return num bucket hosts ; } int actual redundancy = num bucket hosts - num ; this . redundancy = actual redundancy ; if ( this . redundancy satisfied & & num bucket hosts > num & & actual redundancy < desired redundancy ) { inc low redundancy bucket count ( num ) ; this . redundancy satisfied = false ; } else if ( ! this . redundancy satisfied & & num bucket hosts > num & & actual redundancy > = desired redundancy ) { inc low redundancy bucket count ( - num ) ; this . redundancy satisfied = true ; this . redundancy ever satisfied = true ; } return num bucket hosts ; } <s> private int update redundancy ( ) { int num bucket hosts = get num initialized buckets ( ) ; if ( ! is closed ( ) ) { redundancy tracker . update statistics ( num bucket hosts ) ; } return num bucket hosts ; }"}
{"source": "true if the relations changed in a way that requires an update to the relation owner , false otherwise . <s> boolean store relations ( key registry key registry ) { nucleus logger . general . debug ( str + get object provider ( ) + str + relation store infos . size ( ) ) ; if ( relation store infos . is empty ( ) ) { return false ; } object provider op = get object provider ( ) ; execution context ec = op . get execution context ( ) ; datastore table table = get datastore table ( ) ; if ( datastore entity . get key ( ) ! = null ) { key key = datastore entity . get key ( ) ; abstract class meta data acmd = op . get class meta data ( ) ; int [ ] relation field nums = acmd . get relation member positions ( ec . get class loader resolver ( ) , ec . get meta data manager ( ) ) ; if ( relation field nums ! = null ) { for ( int i = num ; i < relation field nums . length ; i + + ) { abstract member meta data mmd = acmd . get meta data for managed member at absolute position ( relation field nums [ i ] ) ; boolean owned = meta data utils . is owned relation ( mmd ) ; if ( owned ) { object child value = op . provide field ( mmd . get absolute field number ( ) ) ; if ( child value ! = null ) { if ( child value instanceof object [ ] ) { child value = arrays . as list ( ( object [ ] ) child value ) ; } string expected type = get expected child type ( mmd ) ; if ( child value instanceof iterable ) { for ( object element : ( iterable ) child value ) { add to parent key map ( key registry , element , key , op . get execution context ( ) , expected type , true ) ; } } else { add to parent key map ( key registry , child value , key , op . get execution context ( ) , expected type , ! table . is parent key provider ( mmd ) ) ; } } } } } } boolean modified entity = false ; for ( relation store information rel info : relation store infos ) { abstract member meta data mmd = rel info . mmd ; try { java type mapping mapping = table . get member mapping <s> boolean store relations ( key registry key registry ) { if ( relation store infos . is empty ( ) ) { return false ; } object provider op = get object provider ( ) ; execution context ec = op . get execution context ( ) ; datastore table table = get datastore table ( ) ; if ( datastore entity . get key ( ) ! = null ) { key key = datastore entity . get key ( ) ; abstract class meta data acmd = op . get class meta data ( ) ; int [ ] relation field nums = acmd . get relation member positions ( ec . get class loader resolver ( ) , ec . get meta data manager ( ) ) ; if ( relation field nums ! = null ) { for ( int i = num ; i < relation field nums . length ; i + + ) { abstract member meta data mmd = acmd . get meta data for managed member at absolute position ( relation field nums [ i ] ) ; boolean owned = meta data utils . is owned relation ( mmd ) ; if ( owned ) { object child value = op . provide field ( mmd . get absolute field number ( ) ) ; if ( child value ! = null ) { if ( child value instanceof object [ ] ) { child value = arrays . as list ( ( object [ ] ) child value ) ; } string expected type = get expected child type ( mmd ) ; if ( child value instanceof iterable ) { for ( object element : ( iterable ) child value ) { add to parent key map ( key registry , element , key , op . get execution context ( ) , expected type , true ) ; } } else { add to parent key map ( key registry , child value , key , op . get execution context ( ) , expected type , ! table . is parent key provider ( mmd ) ) ; } } } } } } boolean modified entity = false ; for ( relation store information rel info : relation store infos ) { abstract member meta data mmd = rel info . mmd ; try { java type mapping mapping = table . get member mapping in datastore class ( rel info . mmd ) ; if ( mapping instanceof embedded pcmapping | | mapping instanceof serialised pcmapping | |"}
{"source": "array of summary entries <s> public static summary entry [ ] query summaries ( variations variation patterns , boolean global ) { return get default ( ) . internal query summaries ( variation patterns , null ) ; } <s> public static summary entry [ ] query summaries ( variations variation patterns , string scenario pattern ) { return get default ( ) . internal query summaries ( variation patterns , scenario pattern ) ; }"}
{"source": "the removed handle if it was present before the invocation of this method , null otherwise <s> public static process handle remove workflow execution handle ( string model code ) { return workflow execution handles . remove ( model code ) ; } <s> public static process handle remove workflow execution handle ( string model code ) { logger . trace ( str , model code ) ; process handle handle = workflow execution handles . remove ( model code ) ; logger . trace ( str , model code , handle ) ; return handle ; }"}
{"source": "true if the node is an ancestor of the target node . <s> private boolean is ancestor of ( object node , object target ) { if ( target = = null ) return false ; object parent = get parent ( target ) ; if ( parent = = node ) return true ; return is ancestor of ( node , parent ) ; } <s> private boolean is ancestor of ( object object1 , object object2 ) { if ( object2 = = null ) return false ; object parent = get parent ( object2 ) ; if ( parent = = object1 ) return true ; return is ancestor of ( object1 , parent ) ; }"}
{"source": "a presentable object . <s> public presentable get result ( ) { return this . result ; } <s> public object get result ( ) { return this . result ; }"}
{"source": "a bundle with remote animations that controls how the window of the opening targets are displayed . <s> @ override public bundle get activity launch options ( launcher launcher , view v ) { if ( has control remote app transition permission ( ) ) { try { remote animation runner compat runner = new launcher animation runner ( m launcher ) { @ override public void on animation start ( remote animation target compat [ ] targets , runnable finished callback ) { post at front of queue asynchronously ( v . get handler ( ) , ( ) - > { final boolean remove tracking view ; launcher transition animator animator = compose recents launch animator ( v , targets ) ; if ( animator ! = null ) { remove tracking view = false ; } else { animator = compose app launch animator ( v , targets ) ; remove tracking view = true ; } set current animator ( animator ) ; m animator = animator . get animator set ( ) ; m animator . add listener ( new animator listener adapter ( ) { @ override public void on animation end ( animator animation ) { v . set visibility ( view . visible ) ; if ( remove tracking view ) { ( ( view group ) m drag layer . get parent ( ) ) . remove view ( m floating view ) ; } m drag layer . set alpha ( num ) ; m drag layer . set translation y ( num ) ; view apps view = m launcher . get apps view ( ) ; apps view . set alpha ( num ) ; apps view . set translation y ( num ) ; finished callback . run ( ) ; } } ) ; m animator . start ( ) ; m animator . set current play time ( refresh _ rate _ ms ) ; } ) ; } } ; return activity options compat . make remote animation ( new remote animation adapter compat ( runner , num , num ) ) . to bundle ( ) ; } catch ( no class def found error e ) { } } return get default activity launch options ( launcher , v ) ; } <s> @ override public activity options get activity launch options ( launcher launcher , view v ) { if ( has control remote app transition permission ( ) ) { try { remote animation runner compat runner = new launcher animation runner ( m launcher ) { @ override public void on animation start ( remote animation target compat [ ] targets , runnable finished callback ) { post at front of queue asynchronously ( v . get handler ( ) , ( ) - > { final boolean remove tracking view ; launcher transition animator animator = compose recents launch animator ( v , targets ) ; if ( animator ! = null ) { remove tracking view = false ; } else { animator = compose app launch animator ( v , targets ) ; remove tracking view = true ; } set current animator ( animator ) ; m animator = animator . get animator set ( ) ; m animator . add listener ( new animator listener adapter ( ) { @ override public void on animation end ( animator animation ) { v . set visibility ( view . visible ) ; if ( remove tracking view ) { ( ( view group ) m drag layer . get parent ( ) ) . remove view ( m floating view ) ; } m drag layer . set alpha ( num ) ; m drag layer . set translation y ( num ) ; view apps view = m launcher . get apps view ( ) ; apps view . set alpha ( num ) ; apps view . set translation y ( num ) ; finished callback . run ( ) ; } } ) ; m animator . start ( ) ; m animator . set current play time ( refresh _ rate _ ms ) ; } ) ; } } ; return activity options compat . make remote animation ( new remote animation adapter compat ( runner , num , num ) ) ; } catch ( no class def found error e ) { } } return get default activity launch options ( launcher , v ) ; }"}
{"source": "the new partition meta data <s> private partition meta data assemble sar ( final string name , final configuration config , final configuration assembly ) throws loom exception { final configuration [ ] block config = assembly . get children ( str ) ; final component meta data [ ] blocks = build blocks ( block config , config ) ; final partition meta data block partition = new partition meta data ( container constants . block _ partition , new string [ ] { container constants . listener _ partition } , partition meta data . empty _ set , blocks ) ; final configuration [ ] listener config = assembly . get children ( str ) ; final component meta data [ ] listeners = build block listeners ( listener config , config ) ; final partition meta data listener partition = new partition meta data ( container constants . listener _ partition , new string [ num ] , partition meta data . empty _ set , listeners ) ; final partition meta data [ ] partitions = new partition meta data [ ] { block partition , listener partition } ; return new partition meta data ( name , new string [ num ] , partitions , component meta data . empty _ set ) ; } <s> private partition template assemble sar ( final string name , final configuration config , final configuration assembly ) throws loom exception { final configuration [ ] block config = assembly . get children ( str ) ; final component template [ ] blocks = build blocks ( block config , config ) ; final partition template block partition = new partition template ( container constants . block _ partition , new string [ ] { container constants . listener _ partition } , partition template . empty _ set , blocks ) ; final configuration [ ] listener config = assembly . get children ( str ) ; final component template [ ] listeners = build block listeners ( listener config , config ) ; final partition template listener partition = new partition template ( container constants . listener _ partition , new string [ num ] , partition template . empty _ set , listeners ) ; final partition template [ ] partitions = new partition template [ ] { block partition , listener partition } ; return new partition template ( name , new string [ num ] , partitions , component template . empty _ set ) ; }"}
{"source": "the customer with the given id , or null if it doesn ' t exist <s> @ processor public customer get customer ( final string id ) { return get client provider ( ) . get client ( customer . class ) . get by id ( id ) ; } <s> @ processor public customer get customer ( final string resource uri ) { return get client provider ( ) . get client ( customer . class ) . get by resource uri ( resource uri ) ; }"}
{"source": "map ibuild configuration - > incremental project builder if this build command supports multiple configurations . otherwise return the incremental project builder associated with this build command . <s> public object get builders ( ) { synchronized ( builder lock ) { if ( supports configs ( ) ) return builders ; return builder ; } } <s> public object get builders ( ) { synchronized ( builder lock ) { if ( supports configs ( ) ) { return builders = = null ? null : new hash map < > ( builders ) ; } return builder ; } }"}
{"source": "map of all distances for a specific run on a specific year <s> public map get distances map ( group run , string year ) { iwcontext iwc = iwcontext . get instance ( ) ; map dis map = new linked hash map ( ) ; collection distances = null ; collection type = new array list ( ) ; type . add ( iwmarathon constants . group _ type _ run _ distance ) ; iterator years iter = get years ( run ) . iterator ( ) ; while ( years iter . has next ( ) ) { group y = ( group ) years iter . next ( ) ; if ( y . get name ( ) . equals ( year ) ) { try { distances = get group biz ( iwc ) . get child groups recursive result filtered ( y , type , true ) ; } catch ( exception e ) { distances = null ; } } else { distances = null ; } } if ( distances ! = null ) { iterator dis iter = distances . iterator ( ) ; while ( dis iter . has next ( ) ) { group dis = ( group ) dis iter . next ( ) ; dis map . put ( dis . get primary key ( ) . to string ( ) , dis . get name ( ) ) ; } } return dis map ; } <s> public collection get distances map ( group run , string year ) { iwcontext iwc = iwcontext . get instance ( ) ; map dis map = new linked hash map ( ) ; collection distances = null ; collection type = new array list ( ) ; type . add ( iwmarathon constants . group _ type _ run _ distance ) ; iterator years iter = get years ( run ) . iterator ( ) ; while ( years iter . has next ( ) ) { group y = ( group ) years iter . next ( ) ; if ( y . get name ( ) . equals ( year ) ) { try { distances = get group biz ( iwc ) . get child groups recursive result filtered ( y , type , true ) ; } catch ( exception e ) { distances = null ; } } } return distances ; }"}
{"source": "boolean flag indicating if an argument is required <s> public boolean has arg ( ) { return number of args > num | | number of args = = unlimited _ values ; } <s> public builder has arg ( ) { return has arg ( true ) ; }"}
{"source": "the label bounds , in lower - left origin screen coordinates . <s> protected rectangle2 d get label bounds ( draw context dc , ordered placemark opm ) { if ( this . label text = = null ) return null ; double x = ( float ) ( opm . screen point . x + this . dx ) ; double y = ( float ) ( opm . screen point . y + this . dy ) ; double image scale = this . get active attributes ( ) . get scale ( ) ; offset os = this . get active attributes ( ) . get label offset ( ) ; if ( os = = null ) os = default _ label _ offset _ if _ unspecified ; double w = this . active texture ! = null ? this . active texture . get width ( dc ) : num ; double h = this . active texture ! = null ? this . active texture . get height ( dc ) : num ; point . double offset = os . compute offset ( w , h , image scale , image scale ) ; x + = offset . x ; y + = offset . y ; font font = this . get active attributes ( ) . get label font ( ) ; if ( font = = null ) font = point placemark attributes . default _ label _ font ; rectangle2 d bounds ; if ( this . label bounds ! = null & & font = = this . bounds font ) { bounds = new rectangle . double ( x , y , this . label bounds . get width ( ) , this . label bounds . get height ( ) ) ; } else { text renderer text renderer = ogltext renderer . get or create text renderer ( dc . get text renderer cache ( ) , font ) ; bounds = text renderer . get bounds ( this . label text ) ; this . bounds font = font ; this . label bounds = bounds ; } double label scale = this . get active attributes ( ) . get label scale ( ) ; if ( label scale ! = null ) { double tw = label scale * bounds . get width ( ) ; double th = label scale * bounds . get height ( ) ; bounds = new rectangle2 d . double ( x , y , tw , th ) ; } else { bounds = new rectangle2 d . double ( x , y , bounds . get width ( ) , bounds . get height ( ) ) ; } return bounds ; } <s> protected rectangle get label bounds ( draw context dc , ordered placemark opm ) { if ( this . get label text ( ) = = null ) return null ; vec4 label point = this . compute label point ( dc , opm ) ; font font = this . get active attributes ( ) . get label font ( ) ; if ( font = = null ) font = point placemark attributes . default _ label _ font ; text renderer text renderer = ogltext renderer . get or create text renderer ( dc . get text renderer cache ( ) , font ) ; rectangle2 d bounds = text renderer . get bounds ( this . get label text ( ) ) ; double width = bounds . get width ( ) ; double height = bounds . get height ( ) ; double label scale = this . get active attributes ( ) . get label scale ( ) ; if ( label scale ! = null ) { width * = label scale ; height * = label scale ; } int y = ( int ) ( label point . get y ( ) + bounds . get y ( ) / num ) ; return new rectangle ( ( int ) label point . x , y , ( int ) math . ceil ( width ) , ( int ) math . ceil ( height ) ) ; }"}
{"source": "a list of all of the names that have already been used . <s> public simple array map < string , string > get used names ( ) { return m used names ; } <s> public sorted set < string > get used names ( ) { return collections . unmodifiable sorted set ( m used names ) ; }"}
{"source": "the istext expert instance . <s> static public istext expert get expert ( string type , stext environment environment ) { istext expert expert ; if ( environment = = null ) environment = stext environment . default ; synchronized ( shared experts ) { map experts = ( map ) shared experts . get ( type ) ; if ( experts = = null ) { experts = new hash map ( ) ; shared experts . put ( type , experts ) ; } expert = ( istext expert ) experts . get ( environment ) ; if ( expert = = null ) { stext type handler handler = stext type handler factory . get handler ( type ) ; if ( handler = = null ) throw new illegal argument exception ( str ) ; expert = new stext impl ( handler , environment , false ) ; experts . put ( type , expert ) ; } } return expert ; } <s> static public istructured text expert get expert ( string type , structured text environment environment ) { istructured text expert expert ; if ( environment = = null ) environment = structured text environment . default ; synchronized ( shared experts ) { map experts = ( map ) shared experts . get ( type ) ; if ( experts = = null ) { experts = new hash map ( ) ; shared experts . put ( type , experts ) ; } expert = ( istructured text expert ) experts . get ( environment ) ; if ( expert = = null ) { structured text type handler handler = structured text type handler factory . get handler ( type ) ; if ( handler = = null ) throw new illegal argument exception ( str ) ; expert = new structured text impl ( handler , environment , false ) ; experts . put ( type , expert ) ; } } return expert ; }"}
{"source": "the input state tag or null if none . <s> protected tag view get input tag ( ) { if ( is append mode ) { final int input tag index = get child count ( ) - num ; tag view input tag = ( tag view ) get child at ( input tag index ) ; if ( input tag ! = null & & input tag . m state = = tag view . state _ input ) { return input tag ; } else { return null ; } } else { return null ; } } <s> public string get input tag ( ) { final tag view input tag view = get input tag view ( ) ; if ( input tag view ! = null ) { return input tag view . get text ( ) . to string ( ) ; } return null ; }"}
{"source": "the validated collection ( never null for method chaining ) <s> public static < t extends collection < ? > > t valid index ( final t collection , final int index ) { return valid index ( collection , index , default _ valid _ index _ collection _ ex _ message , integer . value of ( index ) ) ; } <s> public static < t extends char sequence > t valid index ( final t chars , final int index ) { return valid index ( chars , index , default _ valid _ index _ char _ sequence _ ex _ message , integer . value of ( index ) ) ; }"}
{"source": "an int representation of the number with no decimal <s> public int get number ( ) { string number string = double to string ( get entered number ( ) ) ; string [ ] split = number string . split ( str ) ; return integer . parse int ( split [ num ] ) ; } <s> public big integer get number ( ) { big decimal big decimal = get entered number ( ) . set scale ( num , big decimal . round _ floor ) ; return big decimal . to big integer exact ( ) ; }"}
{"source": "whether is successful to update all tasks ' status to the filedownloader engine . if one task atom among them is not match the rules in com . liulishuo . filedownloader . services . file download mgr # obtain completed task shelf model ( string , string , long ) will receive false , and non of them would be updated to db . <s> public boolean set task completed ( list < file download task atom > task atom list ) { return file download service proxy . get impl ( ) . set task completed ( task atom list ) ; } <s> public boolean set task completed ( list < file download task atom > task atom list ) { file download log . w ( this , str + str ) ; return true ; }"}
{"source": "null if unknown type , null cannot be used to create valid catchpoint <s> public static string get event type from mi ( mibreakpoint mi breakpoint ) { if ( mi breakpoint . get what ( ) . equals ( str ) ) { return catchpoint . catch ; } else if ( mi breakpoint . get what ( ) . equals ( str ) ) { return catchpoint . throw ; } return null ; } <s> public static string get event type from mi ( mibreakpoint mi breakpoint ) { if ( mi breakpoint . get what ( ) . equals ( str ) ) { return event breakpoint . catch ; } else if ( mi breakpoint . get what ( ) . equals ( str ) ) { return event breakpoint . throw ; } return null ; }"}
{"source": "the traceability index of the current repository . if none find , creates it <s> public traceability index get or create traceability index ( ) { final resource traceability resource = repository adapter . get resource ( intent locations . traceability _ infos _ index _ path ) ; if ( traceability resource . get contents ( ) . is empty ( ) ) { traceability resource . get contents ( ) . add ( compiler factory . e instance . create traceability index ( ) ) ; } return ( traceability index ) traceability resource . get contents ( ) . get ( num ) ; } <s> public traceability index get or create traceability index ( ) { if ( traceability index = = null ) { final resource traceability resource = repository adapter . get resource ( intent locations . traceability _ infos _ index _ path ) ; if ( traceability resource . get contents ( ) . is empty ( ) ) { traceability resource . get contents ( ) . add ( compiler factory . e instance . create traceability index ( ) ) ; } traceability index = ( traceability index ) traceability resource . get contents ( ) . get ( num ) ; } return traceability index ; }"}
{"source": "possible object is jpa version <s> public jpa version get jpa version ( ) { return jpa version ; } <s> public string get jpa version ( ) { return jpa version ; }"}
{"source": "the scope context for the module scope that will be associated with this deployment unit <s> public scope context get module scope ( ) { return module scope ; } <s> public scope container get module scope ( ) { return module scope ; }"}
{"source": "an array of integers mapping to the update count per sql command . <s> protected int [ ] execute batch internal ( ) throws sqlexception { for ( int i = num ; i < connection . max retries per execute ; i + + ) { try { meta . execute batch result result = connection . prepare and update batch ( this , batched sql ) ; return result . update counts ; } catch ( no such statement exception e ) { reset statement ( ) ; } } throw new runtime exception ( str + connection . max retries per execute + str ) ; } <s> protected long [ ] execute batch internal ( ) throws sqlexception { for ( int i = num ; i < connection . max retries per execute ; i + + ) { try { return connection . prepare and update batch ( this , batched sql ) . update counts ; } catch ( no such statement exception e ) { reset statement ( ) ; } } throw new runtime exception ( str + connection . max retries per execute + str ) ; }"}
{"source": "all item ids filtered by given prefix . <s> public array list filter content ( string prefix ) { if ( str . equals ( prefix ) ) { this . filtered items buffer = new array list ( get item ids ( ) ) ; return this . filtered items buffer ; } else if ( items ! = null ) { this . filtered items buffer = new array list ( ) ; for ( iterator iter = items . get item ids ( ) . iterator ( ) ; iter . has next ( ) ; ) { object id = iter . next ( ) ; item item = get item ( id ) ; string test = str ; if ( get item caption mode ( ) = = item _ caption _ mode _ property ) test = item . get item property ( get item caption property id ( ) ) . get value ( ) . to string ( ) . trim ( ) ; else test = string . value of ( id ) ; if ( test . to lower case ( ) . starts with ( prefix ) ) { this . filtered items buffer . add ( id ) ; } } } return this . filtered items buffer ; } <s> public array list filter content ( string key ) { return this . of . filter ( key ) ; }"}
{"source": "yes or no <s> public boolean is pos on ad view ( final int pos ) { final int zero _ for _ admob _ selection = ( pos + num ) % adfrequency ; return zero _ for _ admob _ selection = = num ; } <s> public final boolean is pos on ad view ( final int pos ) { return is on ad view ( pos ) ; }"}
{"source": "true if the button is visible and popup menu is assigned . <s> public boolean is button overflow visible ( ) { if ( m popup menu = = no _ popup _ menu & & m custom overflow animation = = null ) { if ( m is button overflow visible ) log . w ( str , str ) ; return false ; } return m is button overflow visible ; } <s> public boolean is button overflow visible ( ) { return m is button overflow visible ; }"}
{"source": "type enum type <s> @ api model property ( value = str ) public type enum get type ( ) { return type ; } <s> @ api model property ( value = str ) public string get type ( ) { return type ; }"}
{"source": "the env <s> public env get apollo env ( ) { env env = env utils . transform env ( foundation . server ( ) . get env type ( ) ) ; if ( env = = null ) { string path = is oswindows ( ) ? str : str ; string message = string . format ( str , path ) ; logger . error ( message ) ; throw new apollo config exception ( message ) ; } return env ; } <s> public env get apollo env ( ) { return env utils . transform env ( foundation . server ( ) . get env type ( ) ) ; }"}
{"source": "the updated map configuration <s> public string get merge policy ( ) { return merge policy ; } <s> public string get merge policy ( ) { return merge policy config . get policy ( ) ; }"}
{"source": "true if there are no pending messages <s> public boolean is empty ( ) { return empty ; } <s> public boolean is empty ( ) { return pending count < = num ; }"}
{"source": "if d , l conditions are met , send stream event output with extrema type , actual _ l ( distance at which a value satisfying d condition is found ) , actual _ l ( distance at which a value satisfying d condition is found ) <s> private stream event find if actual max ( attribute details latest event ) { int index current max = value stack . index of ( current max ) ; int actual _ l = value stack . index of ( latest event ) - index current max ; if ( actual _ l > l ) { current max . not eligible for real max ( ) ; return null ; } int actual _ l = num ; double d threshold = current max . get value ( ) - current max . get value ( ) * d / num ; while ( actual _ l < = l & & index current max - actual _ l > = num ) { if ( value stack . get ( index current max - actual _ l ) . get value ( ) < = d threshold ) { stream event output event = event stack . get ( index current max ) ; complex event populater . populate complex event ( output event , new object [ ] { str , actual _ l , actual _ l } ) ; current max . sent output as real max ( ) ; return output event ; } + + actual _ l ; } current max . not eligible for real max ( ) ; return null ; } <s> private stream event find if actual max ( attribute details latest event ) { int index current max = value stack . index of ( current max ) ; int post bound = value stack . index of ( latest event ) - index current max ; if ( post bound > max post bound ) { current max . not eligible for real max ( ) ; return null ; } if ( max pre bound = = num ) { stream event output event = event stack . get ( index current max ) ; complex event populater . populate complex event ( output event , new object [ ] { str , num , post bound } ) ; current max . sent output as real max ( ) ; return output event ; } int pre bound = num ; double d threshold = current max . get value ( ) - current max . get value ( ) * pre bound change / num ; while ( pre bound < = max pre bound & & index current max - pre bound > = num ) { if ( value stack . get ( index current max - pre bound ) . get value ( ) < = d threshold ) { stream event output event = event stack . get ( index current max ) ; complex event populater . populate complex event ( output event , new object [ ] { str , pre bound , post bound } ) ; current max . sent output as real max ( ) ; return output event ; } + + pre bound ; } current max . not eligible for real max ( ) ; return null ; }"}
{"source": "the path to the optmized image <s> public static string optimize image ( context context , string path ) { file file = new file ( path ) ; if ( ! file . exists ( ) ) { return path ; } string mime type = media utils . get media file mime type ( file ) ; if ( mime type . equals ( str ) ) { return path ; } string file name = media utils . get media file name ( file , mime type ) ; string file extension = mime type map . get file extension from url ( file name ) . to lower case ( ) ; int [ ] dimensions = get image size ( uri . from file ( file ) , context ) ; int orientation = get image orientation ( context , path ) ; uri image uri = uri . parse ( path ) ; if ( context = = null | | image uri = = null ) { return path ; } file resized image file ; file output stream out ; try { resized image file = file . create temp file ( str , str + file extension ) ; out = new file output stream ( resized image file ) ; } catch ( ioexception e ) { app log . e ( app log . t . media , str ) ; return path ; } catch ( security exception e ) { app log . e ( app log . t . media , str ) ; return path ; } try { boolean res = resize image and write to stream ( context , image uri , file extension , dimensions [ num ] , orientation , num , out ) ; if ( ! res ) { app log . w ( app log . t . media , str ) ; return path ; } } catch ( ioexception e ) { app log . e ( app log . t . media , str ) ; return path ; } catch ( out of memory error e ) { app log . e ( app log . t . media , str ) ; return path ; } finally { try { out . flush ( ) ; out . close ( ) ; } catch ( ioexception e ) { } } string temp file path = resized image file . get path ( ) ; if ( ! text utils . is empty ( temp file path ) ) { return temp file path ; } else { app log . e ( app log . t . media , str ) ; } return path ; } <s> public static string optimize image ( context context , string path ) { if ( context = = null | | text utils . is empty ( path ) ) { return path ; } file file = new file ( path ) ; if ( ! file . exists ( ) ) { return path ; } string mime type = media utils . get media file mime type ( file ) ; if ( mime type . equals ( str ) ) { return path ; } uri image uri = uri . parse ( path ) ; if ( image uri = = null ) { return path ; } string file name = media utils . get media file name ( file , mime type ) ; string file extension = mime type map . get file extension from url ( file name ) . to lower case ( ) ; int [ ] dimensions = get image size ( image uri , context ) ; int selected width = dimensions [ num ] ; final int max image width = num ; if ( selected width > max image width ) { selected width = max image width ; } int orientation = get image orientation ( context , path ) ; file resized image file ; file output stream out ; try { resized image file = file . create temp file ( str , str + file extension ) ; out = new file output stream ( resized image file ) ; } catch ( ioexception e ) { app log . e ( app log . t . media , str ) ; return path ; } catch ( security exception e ) { app log . e ( app log . t . media , str ) ; return path ; } try { boolean res = resize image and write to stream ( context , image uri , file extension , selected width , orientation , num , out ) ; if ( ! res ) { app log . w ( app log . t . media , str ) ; return path ; } } catch ( ioexception e ) { app log . e ( app log . t . media , str ) ; return path ; } catch ( out of memory error e ) { app log . e ( app log . t . media , str ) ; return path ; } finally { try { out . flush ( ) ; out . close ( ) ; } catch ( ioexception e ) { } } string temp file path = resized image file . get path ( ) ; if ( ! text utils . is empty ( temp file path ) ) { return temp file path ; } else {"}
{"source": "application . <s> public static application get context ( ) { if ( s application = = null ) throw new exception in initializer error ( str ) ; return s application ; } <s> public static context get context ( ) { test initialize ( ) ; return s context ; }"}
{"source": "the errors that already exist in the request , or a new action errors object if empty . <s> protected action errors get errors ( http servlet request request ) { action errors errors = ( action errors ) request . get attribute ( globals . error _ key ) ; if ( errors = = null ) { errors = new action errors ( ) ; } return errors ; } <s> protected action messages get errors ( http servlet request request ) { action messages errors = ( action messages ) request . get attribute ( globals . error _ key ) ; if ( errors = = null ) { errors = new action messages ( ) ; } return errors ; }"}
{"source": "one of # acc _ private , # acc _ protected , # acc _ package or # acc _ public . <s> public int get access type ( ) { if ( is public ( ) ) { return acc _ public ; } if ( is private ( ) ) { return acc _ private ; } if ( is protected ( ) ) { return acc _ protected ; } return acc _ package ; } <s> public access type get access type ( ) { if ( is public ( ) ) { return access type . acc _ public ; } if ( is private ( ) ) { return access type . acc _ private ; } if ( is protected ( ) ) { return access type . acc _ protected ; } return access type . acc _ package ; }"}
{"source": "true if habit has reminder <s> public boolean has reminder ( ) { return ( reminder hour ! = null & & reminder min ! = null ) ; } <s> public boolean has reminder ( ) { return reminder ! = null ; }"}
{"source": "double the yaw euler angle . <s> public double get rot y ( ) { return m orientation . get rotation y ( ) ; } <s> public double get rot y ( ) { return math . to degrees ( m orientation . get rotation y ( ) ) ; }"}
{"source": "the time in seconds the specified session may remain idle before expiring . <s> protected int get timeout ( session session ) { return get global session timeout ( ) ; } <s> protected long get timeout ( session session ) { return session . get timeout ( ) ; }"}
{"source": "vcard config # flag _ v21 <s> protected int get version ( ) { return vcard config . flag _ v21 ; } <s> protected int get version ( ) { return vcard config . version _ 21 ; }"}
{"source": "the receiver . <s> public com . vaadin . terminal . receiver get receiver ( ) { return receiver ; } <s> public receiver get receiver ( ) { return receiver ; }"}
{"source": "the graph read from the stream <s> public graph parse ( input stream serialized graph , string format identifier ) throws unsupported format exception { return parse ( serialized graph , format identifier , null ) ; } <s> public immutable graph parse ( input stream serialized graph , string format identifier ) throws unsupported format exception { return parse ( serialized graph , format identifier , null ) ; }"}
{"source": "an array of interfaces . <s> public static class [ ] get all interfaces ( list objects ) { set interfaces = new hash set ( ) ; for ( iterator iterator = objects . iterator ( ) ; iterator . has next ( ) ; ) { object o = iterator . next ( ) ; class clazz = o . get class ( ) ; get interfaces ( clazz , interfaces ) ; } return ( class [ ] ) interfaces . to array ( new class [ interfaces . size ( ) ] ) ; } <s> public static set get all interfaces ( list objects ) { set interfaces = new hash set ( ) ; for ( iterator iterator = objects . iterator ( ) ; iterator . has next ( ) ; ) { object o = iterator . next ( ) ; class clazz = o . get class ( ) ; get interfaces ( clazz , interfaces ) ; } return interfaces ; }"}
{"source": "returns widget label text <s> public boolean is selected ( final tool item w ) { boolean selection state = display . sync exec ( new result runnable < boolean > ( ) { @ override public boolean run ( ) { return w . get selection ( ) ; } } ) ; return selection state ; } <s> public boolean is selected ( final tool item tool item ) { boolean selection state = display . sync exec ( new result runnable < boolean > ( ) { @ override public boolean run ( ) { return tool item . get selection ( ) ; } } ) ; return selection state ; }"}
{"source": "media hold by media list , should not be released . <s> public synchronized media get media at ( int index ) { if ( index < num | | index > get count ( ) ) return null ; return m media array . get ( index ) ; } <s> public synchronized media get media at ( int index ) { if ( index < num | | index > = get count ( ) ) throw new index out of bounds exception ( ) ; final media media = m media array . get ( index ) ; media . retain ( ) ; return media ; }"}
{"source": "the value of the ' top ' css - attribute <s> public float get top value ( ) { return top value = = null ? num : top value . float value ( ) ; } <s> public float get top value ( ) { return top value ; }"}
{"source": "a new com . yammer . metrics . core . timer <s> public timer get timer ( string name ) { return get timer ( name , time unit . milliseconds , time unit . seconds ) ; } <s> public timer get timer ( timer desc timer desc ) { return get timer ( timer desc . get name ( ) , timer desc . get duration unit ( ) , timer desc . get time unit ( ) ) ; }"}
{"source": "new foreground color based on the supplied background color <s> private int invert fg color ( ) { if ( current bg color _ . default color ( ) ) { if ( ! inverted _ ) clazzes _ . add ( inverse _ fg _ style ) ; return color . default _ color ; } else if ( current bg color _ . code ( ) > = background _ min & & current bg color _ . code ( ) < = background _ max ) { int new fg = current bg color _ . code ( ) - ( background _ min - foreground _ min ) ; clazzes _ . add ( foreground _ style + integer . to string ( new fg - foreground _ min ) ) ; return new fg ; } else { int new fg = current bg color _ . code ( ) - ( background _ intense _ min - foreground _ intense _ min ) ; clazzes _ . add ( foreground _ style + integer . to string ( new fg + num - foreground _ intense _ min ) ) ; return new fg ; } } <s> private color invert fg color ( ) { if ( current bg color _ . default color ( ) ) { if ( ! inverted _ ) clazzes _ . add ( inverse _ fg _ style ) ; return new color ( ) ; } else if ( current bg color _ . is extended ( ) ) { clazzes _ . add ( color . clazz for color index ( current bg color _ . code ( ) , false ) ) ; return new color ( true , current bg color _ . code ( ) ) ; } else if ( current bg color _ . code ( ) > = background _ min & & current bg color _ . code ( ) < = background _ max ) { int new fg = current bg color _ . code ( ) - ( background _ min - foreground _ min ) ; clazzes _ . add ( foreground _ style + integer . to string ( new fg - foreground _ min ) ) ; return new color ( false , new fg ) ; } else { int new fg = current bg color _ . code ( ) - ( background _ intense _ min - foreground _ intense _ min ) ; clazzes _ . add ( foreground _ style + integer . to string ( new fg + num - foreground _ intense _ min ) ) ; return new color ( false , new fg ) ; } }"}
{"source": "a hashed version of the passed - in string <s> public synchronized static final string hash password ( string password ) { if ( digest = = null ) { try { digest = message digest . get instance ( str ) ; } catch ( no such algorithm exception nsae ) { system . err . println ( str + str ) ; nsae . print stack trace ( ) ; } } digest . update ( get bytes ( password ) ) ; string result = fx format utils . encode hex ( digest . digest ( ) ) ; return result . replace all ( str , str ) ; } <s> public synchronized static string hash password ( long account id , string password ) { try { return sha1 hash ( get bytes ( str + account id + password ) ) ; } catch ( no such algorithm exception e ) { throw new fx create exception ( str ) . as runtime exception ( ) ; } }"}
{"source": "a new calendar instance with the date set to today . time set to zero . <s> @ non null public static calendar get instance ( ) { calendar calendar = calendar . get instance ( ) ; copy date to ( calendar , calendar ) ; return calendar ; } <s> @ non null public static calendar get instance ( ) { return calendar . get instance ( locale . get default ( ) ) ; }"}
{"source": "the path representing the provided uri <s> public static ipath to path ( uri uri ) { if ( uri = = null ) return null ; if ( efs . scheme _ file . equals ( uri . get scheme ( ) ) ) return new path ( uri . get scheme specific part ( ) ) ; return new path ( uri . get path ( ) ) ; } <s> public static ipath to path ( uri uri ) { assert . is not null ( uri ) ; if ( efs . scheme _ file . equals ( uri . get scheme ( ) ) ) return new path ( uri . get scheme specific part ( ) ) ; return null ; }"}
{"source": ": set of thrift sentry role objects <s> public set < tsentry role > get tsentry roles by group name ( set < string > group names , boolean check all groups ) throws exception { set < msentry role > role set = sets . new hash set ( ) ; for ( string group name : group names ) { try { role set . add all ( get msentry roles by group name ( group name ) ) ; } catch ( sentry no such object exception e ) { if ( ! check all groups ) { throw e ; } } } return convert to tsentry roles ( role set ) ; } <s> public set < tsentry role > get tsentry roles by group name ( final set < string > group names , final boolean check all groups ) throws exception { if ( group names . is empty ( ) ) { return collections . empty set ( ) ; } return tm . execute transaction ( new transaction block < set < tsentry role > > ( ) { @ override public set < tsentry role > execute ( persistence manager pm ) throws exception { pm . set detach all on commit ( false ) ; set < string > role names = new hash set < > ( num ) ; set < tsentry role > result = new hash set < > ( num ) ; for ( string group : group names ) { if ( group = = null ) { list < msentry role > roles = get all roles ( pm ) ; for ( msentry role role : roles ) { result . add ( convert to tsentry role ( role ) ) ; } return result ; } string trimmed group = group . trim ( ) ; query query = pm . new query ( msentry group . class ) ; query . set filter ( str ) ; query . set unique ( true ) ; msentry group m group = ( msentry group ) query . execute ( trimmed group ) ; if ( m group ! = null ) { for ( msentry role role : m group . get roles ( ) ) { string role name = role . get role name ( ) ; if ( role names . add ( role name ) ) { result . add ( convert to tsentry role ( role ) ) ; } } } else if ( ! check all groups ) { throw no such group ( trimmed group ) ; } query . close all ( ) ; } return result ; } } ) ; }"}
{"source": "file reader return the file reader <s> protected file reader read announcement ( file file ) throws mojo execution exception { file reader file reader ; try { file reader = new file reader ( file ) ; } catch ( file not found exception fnfe ) { throw new mojo execution exception ( str + file ) ; } return file reader ; } <s> protected string read announcement ( file file ) throws mojo execution exception { input stream reader reader = null ; file input stream input stream = null ; try { input stream = new file input stream ( file ) ; if ( string utils . is empty ( template encoding ) ) { template encoding = reader factory . file _ encoding ; get log ( ) . warn ( str + template encoding + str ) ; } reader = new input stream reader ( input stream , template encoding ) ; return ioutil . to string ( reader ) ; } catch ( file not found exception fnfe ) { throw new mojo execution exception ( str + file ) ; } catch ( unsupported encoding exception uee ) { throw new mojo execution exception ( str + template encoding + str ) ; } catch ( ioexception ioe ) { throw new mojo execution exception ( str , ioe ) ; } finally { ioutil . close ( input stream ) ; ioutil . close ( reader ) ; } }"}
{"source": "an array of sui container children <s> public sui component [ ] get children ( ) { ensure zorder ( ) ; sui component [ ] c = new sui component [ children . size ( ) ] ; return ( sui component [ ] ) children . to array ( c ) ; } <s> public component [ ] get children ( ) { ensure zorder ( ) ; component [ ] c = new component [ children . size ( ) ] ; return ( component [ ] ) children . to array ( c ) ; }"}
{"source": "json array of the aggreagtor values <s> private jsonarray marshal aggregator values ( long superstep ) { jsonarray aggregator array = new jsonarray ( ) ; if ( ( superstep = = input _ superstep ) | | ( aggregator in use . size ( ) = = num ) ) { return aggregator array ; } for ( string name : aggregator in use ) { try { aggregator < writable > aggregator = get aggregator map ( ) . get ( name ) ; byte array output stream output stream = new byte array output stream ( ) ; data output output = new data output stream ( output stream ) ; aggregator . get aggregated value ( ) . write ( output ) ; jsonobject aggregator obj = new jsonobject ( ) ; aggregator obj . put ( aggregator _ name _ key , name ) ; aggregator obj . put ( aggregator _ class _ name _ key , aggregator . get class ( ) . get name ( ) ) ; aggregator obj . put ( aggregator _ value _ key , base64 . encode bytes ( output stream . to byte array ( ) ) ) ; aggregator array . put ( aggregator obj ) ; if ( log . is info enabled ( ) ) { log . info ( str + str + aggregator obj + str + aggregator . get aggregated value ( ) + str ) ; } } catch ( jsonexception e ) { throw new illegal state exception ( str + str + name , e ) ; } catch ( ioexception e ) { throw new illegal state exception ( str + str + name , e ) ; } } if ( log . is info enabled ( ) ) { log . info ( str + str + aggregator array ) ; } aggregator in use . clear ( ) ; return aggregator array ; } <s> private byte [ ] marshal aggregator values ( long superstep ) { if ( superstep = = input _ superstep ) { return new byte [ num ] ; } byte array output stream output stream = new byte array output stream ( ) ; data output stream output = new data output stream ( output stream ) ; for ( entry < string , aggregator wrapper < writable > > entry : get aggregator map ( ) . entry set ( ) ) { if ( entry . get value ( ) . is changed ( ) ) { try { output . write utf ( entry . get key ( ) ) ; entry . get value ( ) . get current aggregated value ( ) . write ( output ) ; } catch ( ioexception e ) { throw new illegal state exception ( str + str + entry . get key ( ) , e ) ; } } } if ( log . is info enabled ( ) ) { log . info ( str ) ; } return output stream . to byte array ( ) ; }"}
{"source": "the modules needing id ( excluding it ) , in uninstallation order ( i . e . the first item isn ' t depended on ) . <s> public synchronized final list < string > get dependent modules recursively ( final string id ) throws exception { final list < string > res = new array list < string > ( ) ; for ( final string dep module : get dependent modules ( id ) ) { res . add ( dep module ) ; res . add all ( this . get dependent modules recursively ( dep module ) ) ; } collections . reverse ( res ) ; return res ; } <s> public final list < module reference > get dependent modules recursively ( final module reference ref ) throws exception { return get dependent modules recursively ( ref , new array list < module reference > ( ) ) ; }"}
{"source": "a formatted challege response , as an array of bytes . <s> public byte [ ] evaluate challenge ( byte [ ] challenge ) throws messaging exception { try { byte [ ] user bytes = username . get bytes ( str ) ; byte [ ] pass bytes = password . get bytes ( str ) ; byte [ ] token bytes = new byte [ ( user bytes . length * num ) + pass bytes . length + num ] ; system . arraycopy ( user bytes , num , token bytes , num , user bytes . length ) ; system . arraycopy ( user bytes , num , token bytes , user bytes . length + num , user bytes . length ) ; system . arraycopy ( pass bytes , num , token bytes , ( user bytes . length * num ) + num , pass bytes . length ) ; complete = true ; return token bytes ; } catch ( unsupported encoding exception e ) { throw new messaging exception ( str ) ; } } <s> public byte [ ] evaluate challenge ( byte [ ] challenge ) throws messaging exception { try { string result = str + username + str + password ; if ( authzid ! = null & & authzid . length ( ) > num ) { result = authzid + result ; } complete = true ; return result . get bytes ( str ) ; } catch ( unsupported encoding exception e ) { throw new messaging exception ( str ) ; } }"}
{"source": "an aggregated authentication info instance representing authentication info across all the successfully consulted realms . <s> protected authentication info do multi realm authentication ( collection < ? extends realm > realms , authentication token token ) { modular authentication strategy strategy = get modular authentication strategy ( ) ; strategy . before all attempts ( realms , token ) ; authentication info aggregated info = create aggregated authentication info ( token ) ; if ( log . is debug enabled ( ) ) { log . debug ( str + realms . size ( ) + str ) ; } for ( realm realm : realms ) { strategy . before attempt ( realm , token ) ; if ( realm . supports ( token . get class ( ) ) ) { if ( log . is debug enabled ( ) ) { log . debug ( str + token + str + str + realm . get class ( ) + str ) ; } authentication info realm info = null ; throwable t = null ; try { realm info = realm . get authentication info ( token ) ; } catch ( throwable throwable ) { t = throwable ; if ( log . is trace enabled ( ) ) { string msg = str + realm + str ; log . trace ( msg , t ) ; } } strategy . after attempt ( realm , token , realm info , t ) ; if ( realm info ! = null ) { if ( log . is debug enabled ( ) ) { log . debug ( str + realm . get class ( ) . get name ( ) + str ) ; } merge ( aggregated info , realm info ) ; } } else { if ( log . is debug enabled ( ) ) { log . debug ( str + realm . get class ( ) . get name ( ) + str + str + token . get class ( ) . get name ( ) + str ) ; } } } strategy . after all attempts ( token , aggregated info ) ; return aggregated info ; } <s> protected account do multi realm authentication ( collection < ? extends realm > realms , authentication token token ) { modular authentication strategy strategy = get modular authentication strategy ( ) ; strategy . before all attempts ( realms , token ) ; account aggregated info = create aggregated account ( token ) ; if ( log . is debug enabled ( ) ) { log . debug ( str + realms . size ( ) + str ) ; } for ( realm realm : realms ) { strategy . before attempt ( realm , token ) ; if ( realm . supports ( token . get class ( ) ) ) { if ( log . is debug enabled ( ) ) { log . debug ( str + token + str + str + realm . get class ( ) + str ) ; } account realm info = null ; throwable t = null ; try { realm info = realm . get account ( token ) ; } catch ( throwable throwable ) { t = throwable ; if ( log . is trace enabled ( ) ) { string msg = str + realm + str ; log . trace ( msg , t ) ; } } strategy . after attempt ( realm , token , realm info , t ) ; if ( realm info ! = null ) { if ( log . is debug enabled ( ) ) { log . debug ( str + realm . get class ( ) . get name ( ) + str ) ; } merge ( aggregated info , realm info ) ; } } else { if ( log . is debug enabled ( ) ) { log . debug ( str + realm . get class ( ) . get name ( ) + str + str + token . get class ( ) . get name ( ) + str ) ; } } } strategy . after all attempts ( token , aggregated info ) ; return aggregated info ; }"}
{"source": "0 if the bundle is already in the descriptor , else - 1 <s> private int parse repository xml ( ) throws mojo execution exception { file fout = new file ( m _ repository xml ) ; if ( ! fout . exists ( ) ) { document doc = m _ document builder . new document ( ) ; date d = new date ( ) ; d . set time ( system . current time millis ( ) ) ; element root = doc . create element ( str ) ; root . set attribute ( str , m _ format . format ( d ) ) ; root . set attribute ( str , str ) ; try { write to file ( m _ repository xml , root ) ; } catch ( mojo execution exception e ) { e . print stack trace ( ) ; throw new mojo execution exception ( str ) ; } } m _ repository doc = parse file ( m _ repository xml , m _ document builder ) ; if ( m _ repository doc = = null ) { return - num ; } return num ; } <s> public boolean parse repository xml ( ) throws mojo execution exception { file fout = new file ( m _ repository xml ) ; if ( ! fout . exists ( ) ) { document doc = m _ document builder . new document ( ) ; date d = new date ( ) ; d . set time ( system . current time millis ( ) ) ; element root = doc . create element ( str ) ; root . set attribute ( str , m _ format . format ( d ) ) ; root . set attribute ( str , str ) ; try { write to file ( m _ repository xml , root ) ; } catch ( mojo execution exception e ) { e . print stack trace ( ) ; throw new mojo execution exception ( str ) ; } } m _ repository doc = parse file ( m _ repository xml , m _ document builder ) ; return ( null ! = m _ repository doc ) ; }"}
{"source": "a druid dimensions loader <s> protected druid dimensions loader build druid dimensions loader ( druid web service web service , physical table dictionary physical table dictionary , dimension dictionary dimension dictionary ) { return new druid dimensions loader ( physical table dictionary , dimension dictionary , web service ) ; } <s> protected dimension value load task build druid dimensions loader ( druid web service web service , physical table dictionary physical table dictionary , dimension dictionary dimension dictionary ) { druid dimension value loader druid dimension row provider = new druid dimension value loader ( physical table dictionary , dimension dictionary , web service ) ; return new dimension value load task ( collections . singleton list ( druid dimension row provider ) ) ; }"}
{"source": "an error , because querys could ' t add new records to the database <s> @ override public boolean create record ( dbrecord rec , connection conn ) { return error ( errors . not implemented , str ) ; } <s> @ override public void create record ( dbrecord rec , connection conn ) { throw new not implemented exception ( this , str ) ; }"}
{"source": "the mouse cursor y position <s> public int get client y ( ) { return details . get client y ( ) ; } <s> public int get client y ( ) { if ( null ! = details ) { return details . get client y ( ) ; } else { return - num ; } }"}
{"source": "true if this authentication realm \" understands \" how to process submissions for the submitted token instances of the class , false otherwise . <s> public boolean supports ( class token class ) { return get authentication token class ( ) . is assignable from ( token class ) ; } <s> public boolean supports ( authentication token token ) { if ( log . is info enabled ( ) ) { log . info ( str + str ) ; } return token ! = null & & get authentication token class ( ) . is assignable from ( token . get class ( ) ) ; }"}
{"source": "score for that day <s> public int get value ( long timestamp ) { compute all ( ) ; string [ ] args = { habit . get id ( ) . to string ( ) , long . to string ( timestamp ) } ; return sqlite utils . int query ( str , args ) ; } <s> public final int get value ( long timestamp ) { compute ( timestamp , timestamp ) ; score s = get computed by timestamp ( timestamp ) ; if ( s = = null ) throw new illegal state exception ( ) ; return s . get value ( ) ; }"}
{"source": "a subset configuration using the prefix # app _ prefix . any change made to subset will be reflected in this configuration , but with the prefix added . this method is useful for setting application configuration before initialization . for reading application configuration after initialization , see fluo client # get app configuration ( ) <s> public configuration get app configuration ( ) { return subset ( app _ prefix ) ; } <s> public simple configuration get app configuration ( ) { return subset ( app _ prefix ) ; }"}
{"source": "the list of initial service reference objects . <s> private service reference [ ] get initial references ( boolean track all services , string track class , string filter string ) throws invalid syntax exception { if ( track all services ) { return context . get all service references ( track class , filter string ) ; } else { return context . get service references ( track class , filter string ) ; } } <s> private service reference [ ] get initial references ( boolean track all services , string class name , string filter string ) throws invalid syntax exception { if ( track all services ) { return context . get all service references ( class name , filter string ) ; } return context . get service references ( class name , filter string ) ; }"}
{"source": "the utf - 8 content of the stream . <s> public static string as string ( final input stream is ) throws ioexception { final buffered reader reader = new buffered reader ( new input stream reader ( is , str ) ) ; try { return reader . read line ( ) ; } finally { reader . close ( ) ; } } <s> public static string as string ( final input stream is , charset charset ) throws ioexception { final buffered reader reader = new buffered reader ( new input stream reader ( is , charset ) ) ; try { final string first line = reader . read line ( ) ; if ( first line = = null ) { return str ; } final string builder builder = new string builder ( first line ) ; for ( string line = reader . read line ( ) ; line ! = null ; line = reader . read line ( ) ) { builder . append ( eol ) ; builder . append ( line ) ; } return builder . to string ( ) ; } finally { reader . close ( ) ; } }"}
{"source": "this object . <s> public throwable init cause ( throwable cause ) { throw new illegal state exception ( ) ; } <s> public throwable init cause ( throwable cause ) { return super . init cause ( cause ) ; }"}
{"source": "a string of the format \" thu oct 18 20 : 21 : 13 2001 \" <s> public string get time stamp ( ) { return time stamp ; } <s> public date get time stamp ( ) { return time stamp ; }"}
{"source": "a set of topic metadatas <s> public set < topic metadata > topic meta data ( final string . . . topic names ) { if ( ! running . get ( ) ) throw new illegal state exception ( str ) ; if ( topic names = = null | | topic names . length = = num ) return collections . empty set ( ) ; final zk utils z = get zk utils ( ) ; final set < string > set = new linked hash set < string > ( arrays . as list ( topic names ) ) ; return java conversions . set as java set ( admin utils . fetch topic metadata from zk ( java converters . as scala set converter ( set ) . as scala ( ) , z ) ) ; } <s> public map < string , topic metadata > topic meta data ( final string . . . topic names ) { if ( ! running . get ( ) ) throw new illegal state exception ( str ) ; final zk utils z = get zk utils ( ) ; final set < string > set = ( topic names = = null | | topic names . length = = num ) ? topic names ( ) : new linked hash set < string > ( arrays . as list ( topic names ) ) ; final set < topic metadata > meta = java conversions . set as java set ( admin utils . fetch topic metadata from zk ( java converters . as scala set converter ( set ) . as scala ( ) , z ) ) ; final map < string , topic metadata > map = new hash map < string , topic metadata > ( meta . size ( ) ) ; for ( topic metadata tm : meta ) { map . put ( tm . topic ( ) , tm ) ; } return map ; }"}
{"source": "one of the following application running states : iserver # state _ started , iserver # state _ starting , iserver # state _ stopped , iserver # state _ stopping , iserver # state _ unknown <s> public int track ( iprogress monitor monitor ) throws core exception { long current time = system . current time millis ( ) ; long total time = current time + timeout ; cloud foundry application module app module = cloud server . get behaviour ( ) . update module with all cloud info ( app name , monitor ) ; println to console ( nls . bind ( messages . application instance starting tracker _ starting _ tracking , app name ) , app module ) ; int state = app module . get state ( ) ; while ( state ! = iserver . state _ started & & state ! = iserver . state _ stopped & & current time < total time ) { app module = cloud server . get behaviour ( ) . update module with all cloud info ( app name , monitor ) ; if ( app module = = null | | app module . get application ( ) = = null ) { println to console ( nls . bind ( messages . application instance starting tracker _ application _ not _ exists , app name ) , app module ) ; return iserver . state _ unknown ; } if ( monitor ! = null & & monitor . is canceled ( ) ) { println to console ( nls . bind ( messages . application instance starting tracker _ application _ check _ canceled , app name ) , app module ) ; return iserver . state _ unknown ; } state = app module . get state ( ) ; try { thread . sleep ( wait _ time ) ; } catch ( interrupted exception e ) { } current time = system . current time millis ( ) ; } string running state message = state = = iserver . state _ started ? nls . bind ( messages . application instance starting tracker _ application _ is _ running , app name ) : nls . bind ( messages . application instance starting tracker _ application _ is _ not _ running , app name ) ; println to console ( running state message , app module ) ; return state ; } <s> public int track ( iprogress monitor monitor ) throws core exception , operation canceled exception { long current time = system . current time millis ( ) ; long total time = current time + timeout ; cloud foundry server behaviour behaviour = cloud server . get behaviour ( ) ; string app name = app module . get deployed application name ( ) ; println to console ( nls . bind ( messages . application instance starting tracker _ starting _ tracking , app name ) , app module ) ; int state = iserver . state _ unknown ; while ( state ! = iserver . state _ started & & state ! = iserver . state _ stopped & & current time < total time ) { if ( monitor ! = null & & monitor . is canceled ( ) ) { string error = nls . bind ( messages . application instance starting tracker _ application _ check _ canceled , app name ) ; println to console ( error , app module ) ; throw new operation canceled exception ( error ) ; } cloud application cloud app = behaviour . get cloud application ( app name , monitor ) ; application stats application stats = behaviour . get application stats ( app name , monitor ) ; if ( cloud app = = null ) { string error = nls . bind ( messages . application instance starting tracker _ application _ not _ exists , app name ) ; println to console ( error , app module ) ; throw cloud error util . to core exception ( error ) ; } else { state = cloud foundry application module . get cloud state ( cloud app , application stats ) ; try { thread . sleep ( wait _ time ) ; } catch ( interrupted exception e ) { } current time = system . current time millis ( ) ; } } string running state message = state = = iserver . state _ started ? nls . bind ( messages . application instance starting tracker _ application _ is _ running , app name ) : nls . bind ( messages . application instance starting tracker _ application _ is _ not _ running , app name ) ; println to console ( running state message"}
{"source": "an integer identifying the status <s> public integer get row status ( int a row ) throws index out of bounds exception { row data row = this . get row ( a row ) ; if ( row . is original ( ) ) { return row _ original ; } else if ( row . is new ( ) ) { return row _ new ; } else if ( row . is modified ( ) ) { return row _ modified ; } else { return row _ original ; } } <s> public int get row status ( int a row ) throws index out of bounds exception { row data row = this . get row ( a row ) ; if ( row . is new ( ) ) { return row data . new ; } else if ( row . is modified ( ) ) { return row data . modified ; } else { return row data . not _ modified ; } }"}
{"source": "valid person <s> public person get owner ( ) { return owner ; } <s> public user get owner ( ) { return owner ; }"}
{"source": "the frame to be displayed . <s> protected ilist frame create list frame ( sqlelement elem ) { return new ilist frame ( new liste modify panel ( elem ) ) ; } <s> protected ilist frame create list frame ( sqlelement elem ) { return null ; }"}
{"source": "the package id for the given apk , or null if it could not be determined . <s> private static string get package id for apk ( abstract build < ? , ? > build , launcher launcher , print stream logger , android sdk android sdk , file path apk path ) throws ioexception , interrupted exception { byte array output stream aapt output = new byte array output stream ( ) ; string args = string . format ( str , apk path . get name ( ) ) ; utils . run android tool ( launcher , aapt output , logger , android sdk , tool . aapt , args , apk path . get parent ( ) ) ; string package id = null ; string aapt result = aapt output . to string ( ) ; if ( aapt result . length ( ) > num ) { matcher matcher = pattern . compile ( str ) . matcher ( aapt result ) ; if ( matcher . find ( ) ) { package id = matcher . group ( num ) ; } } return package id ; } <s> private static string get package id for apk ( file path apk path ) throws ioexception , interrupted exception { return apk path . act ( new file path . file callable < string > ( ) { public string invoke ( file f , virtual channel channel ) throws ioexception , interrupted exception { return get apk metadata ( f ) . get package name ( ) ; } } ) ; }"}
{"source": "a valid url , if all went well ; else null ; <s> @ visible for testing protected url create plugin url ( ) { url url for plugin = null ; try { url for plugin = new url ( str + location ) ; gdd . diag ( gdd . get lit ( str ) + str + url for plugin . to string ( ) ) ; } catch ( malformed urlexception e ) { gdd . log . severe ( gdd . get lit ( str ) + str + location + str + e ) ; throw new stop execution exception ( null ) ; } return ( url for plugin ) ; } <s> @ visible for testing protected url create plugin url ( ) { try { url url for plugin = new url ( str + location ) ; gdd . diag ( gdd . get lit ( str ) + str + url for plugin . to string ( ) ) ; return ( url for plugin ) ; } catch ( malformed urlexception e ) { gdd . log . severe ( gdd . get lit ( str ) + str + location + str + e ) ; throw new stop execution exception ( null ) ; } }"}
{"source": "an enumeration of all child nodes of this node . <s> protected final enumeration elements ( ) { return _ contents . elements ( ) ; } <s> protected final iterator < syntax tree node > elements ( ) { return _ contents . iterator ( ) ; }"}
{"source": "true if it is successful . <s> public boolean doit ( ) { return false ; } <s> public istatus doit ( ) { return status . ok _ status ; }"}
{"source": "set method or null if none found . <s> public static method find set method ( field field , boolean throw exceptions ) { string method name = method from field ( field , str ) ; method field set method ; try { field set method = field . get declaring class ( ) . get method ( method name , field . get type ( ) ) ; } catch ( exception e ) { if ( throw exceptions ) { throw new illegal argument exception ( str + field ) ; } else { return null ; } } if ( field set method . get return type ( ) ! = void . class ) { if ( throw exceptions ) { throw new illegal argument exception ( str + method name + str + field set method . get return type ( ) + str ) ; } else { return null ; } } return field set method ; } <s> public static method find set method ( field field , boolean throw exceptions ) throws illegal argument exception { method field set method ; if ( locale . english . equals ( locale . get default ( ) ) ) { field set method = find method from names ( field , false , throw exceptions , method from field ( field , str , null ) ) ; } else { field set method = find method from names ( field , false , throw exceptions , method from field ( field , str , null ) , method from field ( field , str , locale . english ) ) ; } if ( field set method = = null ) { return null ; } if ( field set method . get return type ( ) ! = void . class ) { if ( throw exceptions ) { throw new illegal argument exception ( str + field set method . get name ( ) + str + field set method . get return type ( ) + str ) ; } else { return null ; } } return field set method ; }"}
{"source": "a set of class names and class member signatures found in the method . <s> public static set < string > find referenced members ( method info method info ) { set < string > members = new hash set < string > ( ) ; class member visitor visitor = new class member visitor ( members ) ; set < integer > ids = find pool references ( method info ) ; visitor . visit method ( method info ) ; visit pool references ( method info . get class info ( ) , visitor , ids ) ; return members ; } <s> public static reference result find referenced members ( method info method info ) { set < string > members = new hash set < string > ( ) ; class member visitor visitor = new class member visitor ( members ) ; id finder visitor finder = find pool references ( method info , method info . compile ( ) , true ) ; visitor . visit method ( method info ) ; visit pool references ( method info . get class info ( ) , visitor , finder . get ids ( ) ) ; return new reference result ( members , finder . get invoke sites ( ) ) ; }"}
{"source": "a sorted list of arrays of two strings consisting of the family and a font file in that family <s> public list < string [ ] > get font families ( collection < string > filenames ) { linked list < string [ ] > family and font = new linked list < string [ ] > ( ) ; string [ ] family = null ; base font bf = null ; collection < string > files = check not null ( filenames ) ; for ( string filename : files ) { family = extract family names ( filename , bf ) ; system . out . println ( str + family [ num ] + str + filename ) ; string [ ] x = { family [ num ] , filename } ; family and font . add ( x ) ; } return ( family and font ) ; } <s> public tree map < string , list < string > > get font families ( collection < string > filenames ) { linked list < string [ ] > family and font = new linked list < string [ ] > ( ) ; string [ ] family ; base font bf = null ; int i = num ; collection < string > files = check not null ( filenames ) ; for ( string filename : files ) { family = extract family names ( filename , bf ) ; system . out . println ( str + family [ num ] + str + filename ) ; string [ ] x = { family [ num ] , filename } ; family and font . add ( x ) ; i + + ; } gdd . diag ( str + i + str ) ; try { for ( string [ ] kv : family and font ) { if ( family tree . contains key ( kv [ num ] ) ) { list v = family tree . get ( kv [ num ] ) ; v . add ( kv [ num ] ) ; } else { list l = new linked list < string > ( ) ; l . add ( kv [ num ] ) ; family tree . put ( kv [ num ] , l ) ; } } } catch ( exception e ) { system . err . println ( str ) ; } return ( family tree ) ; }"}
{"source": "the final name of the saved script <s> private string save script and forward ( string name , string comment , string script , boolean non administer using , string origin catalog name , string origin id , parameter [ ] parameters ) throws ioexception { if ( string utils . is empty ( script ) | | string utils . is empty ( name ) ) { throw new illegal argument exception ( str ) ; } final string final name = fix file name ( origin catalog name , name ) ; file new script file = new file ( get script directory ( ) , final name ) ; writer writer = new file writer ( new script file ) ; writer . write ( script ) ; writer . close ( ) ; script new script = null ; if ( ! string utils . is empty ( origin id ) ) { new script = new script ( final name , comment , true , origin catalog name , origin id , new simple date format ( str ) . format ( new date ( ) ) , parameters ) ; } else { new script = new script ( final name , comment , non administer using , parameters ) ; } scriptler configuration cfg = get configuration ( ) ; cfg . add or replace ( new script ) ; cfg . save ( ) ; return final name ; } <s> private string save script and forward ( string id , string name , string comment , string script , boolean non administer using , string origin catalog name , string origin id , parameter [ ] parameters ) throws ioexception { script = script = = null ? str : script ; if ( string utils . is empty ( id ) ) { throw new illegal argument exception ( str ) ; } final string display name = name = = null ? id : name ; final string final file name = fix file name ( origin catalog name , id ) ; file new script file = new file ( get script directory ( ) , final file name ) ; writer writer = new file writer ( new script file ) ; writer . write ( script ) ; writer . close ( ) ; script new script = null ; if ( ! string utils . is empty ( origin id ) ) { new script = new script ( final file name , display name , comment , true , origin catalog name , origin id , new simple date format ( str ) . format ( new date ( ) ) , parameters ) ; } else { new script = new script ( final file name , display name , comment , non administer using , parameters ) ; } scriptler configuration cfg = get configuration ( ) ; cfg . add or replace ( new script ) ; cfg . save ( ) ; return final file name ; }"}
{"source": "true if we wrote a schema , false if we didn ' t . <s> public boolean write schema ( types types ) throws exception { return false ; } <s> public element write schema ( class java type , types types ) throws exception { string component type name = null ; class component type = null ; if ( java type . is array ( ) ) { string dim string = str ; component type = java type . get component type ( ) ; if ( component type . is array ( ) ) { while ( component type . is array ( ) ) { dim string + = str ; component type = component type . get component type ( ) ; } } component type name = types . get qname string ( types . get type qname ( component type ) ) + dim string ; } return types . create array element ( component type name ) ; }"}
{"source": "the result of interpretting the object as an instance of ' s type ' . <s> public object case customers type ( customers type object ) { return null ; } <s> public t case customers type ( customers type object ) { return null ; }"}
{"source": "the next element obf the iteration <s> @ override public final type next ( ) { type result = next ; next = null ; result = ( result = = null ? from iterator . next ( ) : result ) ; return result ; } <s> @ override public final type next ( ) { if ( next = = null ) { return from iterator . next ( ) ; } else { final type result = next ; next = null ; return result ; } }"}
{"source": "a security context representing the authenticated account . <s> public security context login ( authentication token token ) throws authentication exception { account account ; try { account = authenticate ( token ) ; remember me successful login ( token , account ) ; } catch ( authentication exception ae ) { remember me failed login ( token , ae ) ; throw ae ; } security context sec ctx = create security context ( token , account ) ; assert creation ( sec ctx ) ; bind ( sec ctx ) ; return sec ctx ; } <s> public subject login ( authentication token token ) throws authentication exception { account account ; try { account = authenticate ( token ) ; remember me successful login ( token , account ) ; } catch ( authentication exception ae ) { remember me failed login ( token , ae ) ; throw ae ; } subject sec ctx = create subject ( token , account ) ; assert creation ( sec ctx ) ; bind ( sec ctx ) ; return sec ctx ; }"}
{"source": "a future for accessing the results of the asynchronous request . <s> public future < http response > execute async ( executor exec ) { final settable future < http response > future = settable future . create ( ) ; exec . execute ( new runnable ( ) { public void run ( ) { try { future . set ( execute ( ) ) ; } catch ( ioexception ex ) { future . set exception ( ex ) ; } } } ) ; return future ; } <s> public future < http response > execute async ( executor executor ) { future task < http response > future = new future task < http response > ( new callable < http response > ( ) { public http response call ( ) throws exception { return execute ( ) ; } } ) ; executor . execute ( future ) ; return future ; }"}
{"source": "built ct . merkle tree leaf . <s> public static ct . merkle tree leaf parse merkle tree leaf ( input stream in ) { ct . merkle tree leaf . builder merkle tree leaf builder = ct . merkle tree leaf . new builder ( ) ; int version = ( int ) read number ( in , ctconstants . version _ length ) ; if ( version ! = ct . version . v1 . get number ( ) ) { throw new serialization exception ( string . format ( str , version ) ) ; } merkle tree leaf builder . set version ( ct . version . value of ( version ) ) ; int leaf type = ( int ) read number ( in , num ) ; if ( leaf type ! = ct . merkle leaf type . timestamped _ entry _ value ) { throw new serialization exception ( string . format ( str , leaf type ) ) ; } merkle tree leaf builder . set type ( ct . merkle leaf type . value of ( leaf type ) ) ; merkle tree leaf builder . set timestamped entry ( ( parse timestamped entry ( in ) ) ) ; return merkle tree leaf builder . build ( ) ; } <s> public static merkle tree leaf parse merkle tree leaf ( input stream in ) { int version = ( int ) read number ( in , ctconstants . version _ length ) ; if ( version ! = ct . version . v1 . get number ( ) ) { throw new serialization exception ( string . format ( str , version ) ) ; } int leaf type = ( int ) read number ( in , num ) ; if ( leaf type ! = ct . merkle leaf type . timestamped _ entry _ value ) { throw new serialization exception ( string . format ( str , leaf type ) ) ; } return new merkle tree leaf ( ct . version . value of ( version ) , ct . merkle leaf type . value of ( leaf type ) , parse timestamped entry ( in ) ) ; }"}
{"source": "the result as a int value , if no result the int value 0 <s> public final int query single int ( string sql cmd , connection conn ) { return query single int ( sql cmd , num , conn ) ; } <s> public final int query single int ( string sql cmd , connection conn ) { return query single int ( sql cmd , null , num , conn ) ; }"}
{"source": "a bundle with remote animations that controls how the window of the opening targets are displayed . <s> @ override public bundle get activity launch options ( launcher launcher , view v ) { if ( has control remote app transition permission ( ) ) { try { remote animation runner compat runner = new launcher animation runner ( m launcher ) { @ override public void on animation start ( remote animation target compat [ ] targets , runnable finished callback ) { post at front of queue asynchronously ( v . get handler ( ) , ( ) - > { m animator = new animator set ( ) ; set current animator ( m animator ) ; m animator . play ( get launcher animators ( v ) ) ; m animator . play ( get window animators ( v , targets ) ) ; m animator . add listener ( new animator listener adapter ( ) { @ override public void on animation end ( animator animation ) { v . set visibility ( view . visible ) ; ( ( view group ) m drag layer . get parent ( ) ) . remove view ( m floating view ) ; m drag layer . set alpha ( num ) ; m drag layer . set translation y ( num ) ; view apps view = m launcher . get apps view ( ) ; apps view . set alpha ( num ) ; apps view . set translation y ( num ) ; finished callback . run ( ) ; } } ) ; m animator . start ( ) ; m animator . set current play time ( refresh _ rate _ ms ) ; } ) ; } } ; return activity options compat . make remote animation ( new remote animation adapter compat ( runner , num , num ) ) . to bundle ( ) ; } catch ( no class def found error e ) { } } return get default activity launch options ( launcher , v ) ; } <s> @ override public activity options get activity launch options ( launcher launcher , view v ) { if ( has control remote app transition permission ( ) ) { try { remote animation runner compat runner = new launcher animation runner ( m handler ) { @ override public animator set get animator ( remote animation target compat [ ] target compats ) { animator set anim = new animator set ( ) ; if ( ! compose recents launch animator ( v , target compats , anim ) ) { m launcher . get state manager ( ) . set current animation ( anim ) ; anim . play ( get icon animator ( v ) ) ; if ( launcher is atarget with mode ( target compats , mode _ closing ) ) { anim . play ( get launcher content animator ( false ) ) ; } anim . play ( get window animators ( v , target compats ) ) ; } return anim ; } } ; int duration = find task view to launch ( launcher , v , null ) ! = null ? recents _ launch _ duration : app _ launch _ duration ; int status bar transition delay = duration - status _ bar _ transition _ duration ; return activity options compat . make remote animation ( new remote animation adapter compat ( runner , duration , status bar transition delay ) ) ; } catch ( no class def found error e ) { } } return get default activity launch options ( launcher , v ) ; }"}
{"source": "0 for success and - 1 for fail <s> private int execute sucommands ( intent result , string result extra text , string [ ] commands ) { file root folder = new file ( m root of work path ) ; file working folder = new file ( root folder , temp _ folder ) ; if ( ! working folder . exists ( ) & & ! working folder . mkdir ( ) ) { result . put extra ( result extra text , str ) ; return - num ; } try { utils . extract executable asset ( this , update _ script , working folder . to string ( ) , true ) ; utils . extract executable asset ( this , android _ loop _ mount , working folder . to string ( ) , true ) ; utils . extract executable asset ( this , android _ bootmgr , working folder . to string ( ) , true ) ; } catch ( ioexception e ) { e . print stack trace ( ) ; result . put extra ( result extra text , str ) ; return - num ; } m wake lock = m power manager . new wake lock ( power manager . partial _ wake _ lock , str ) ; try { process process = runtime . get runtime ( ) . exec ( str , null , working folder ) ; data output stream os = new data output stream ( process . get output stream ( ) ) ; os . write bytes ( str ) ; for ( string c : commands ) { log . v ( tag , str + c ) ; os . write bytes ( string . format ( str , working folder . get absolute path ( ) ) ) ; os . write bytes ( c ) ; } os . write bytes ( string . format ( str , working folder . get absolute path ( ) ) ) ; os . write bytes ( str ) ; os . flush ( ) ; int read = num ; byte [ ] buff = new byte [ num ] ; input stream is = process . get input stream ( ) ; input stream es = process . get error stream ( ) ; boolean running = true ; boolean script executed = false ; do { while ( is . available ( ) > num ) { read = is . read ( buff ) ; if ( read < = num ) { break ; } script executed = true ; string seg = new string ( buff , num , read ) ; log . i ( tag , str + seg ) ; broadcast progress ( - num , seg ) ; } while ( es . available ( ) > num ) <s> private int execute sucommands ( string [ ] commands ) throws eshell exec exception { int ret = num ; file root folder = new file ( m root of work path ) ; file working folder = new file ( root folder , temp _ folder ) ; string working folder path = working folder . get absolute path ( ) ; if ( ! working folder . exists ( ) & & ! working folder . mkdir ( ) ) { throw ( new eshell exec exception ( str ) ) ; } broadcast progress ( num , str + working folder . get absolute path ( ) ) ; try { utils . extract executable asset ( this , android _ bootmgr , working folder path , true ) ; utils . extract executable asset ( this , android _ loop _ mount , working folder path , true ) ; utils . extract executable asset ( this , archive _ master _ asc , working folder path , false ) ; utils . extract executable asset ( this , archive _ master , working folder path , false ) ; utils . extract executable asset ( this , busybox , working folder path , true ) ; utils . extract executable asset ( this , gpg , working folder path , true ) ; utils . extract executable asset ( this , tar , working folder path , true ) ; utils . extract executable asset ( this , update _ script , working folder path , true ) ; utils . extract executable asset ( this , u _ reboot _ app _ asc , working folder path , false ) ; utils . extract executable asset ( this , u _ reboot _ app , working folder path , false ) ; utils . extract executable asset ( this , upgradechecker , working folder path , true ) ; } catch ( ioexception e ) { throw ( new eshell exec exception ( str ) ) ; } m wake lock = m power manager . new wake lock ( power manager . partial _ wake _ lock , str ) ; try { process process = runtime . get runtime ( ) . exec ( str , null , working folder ) ; data output stream os = new data output stream ( process . get output stream ( ) ) ; os . write bytes ( str ) ; os . write bytes ( str ) ; os . write bytes ( string . format ( str , working folder . get absolute path ( ) ) ) ; os . write bytes ( string . format ( str , working folder . get absolute path ( ) ) ) ; for ( string cmd : commands ) {"}
{"source": "a by which locates a elements that contain the given text . <s> public static by partial link text ( final string link text ) { if ( link text = = null ) throw new illegal argument exception ( str ) ; return new by partial link text ( link text ) ; } <s> public static by partial link text ( final string partial link text ) { return new by partial link text ( partial link text ) ; }"}
{"source": "expression to match columns from name list , or null if name list is empty <s> private rex node convert using ( rel node left rel , rel node right rel , list < string > name list ) { rex node condition exp = null ; for ( string name : name list ) { final rel data type left row type = left rel . get row type ( ) ; rel data type field left field = catalog reader . field ( left row type , name ) ; rex node left = rex builder . make input ref ( left field . get type ( ) , left field . get index ( ) ) ; final rel data type right row type = right rel . get row type ( ) ; rel data type field right field = catalog reader . field ( right row type , name ) ; rex node right = rex builder . make input ref ( right field . get type ( ) , left row type . get field list ( ) . size ( ) + right field . get index ( ) ) ; rex node equals call = rex builder . make call ( sql std operator table . equals , left , right ) ; if ( condition exp = = null ) { condition exp = equals call ; } else { condition exp = rex builder . make call ( sql std operator table . and , condition exp , equals call ) ; } } return condition exp ; } <s> private rex node convert using ( rel node left rel , rel node right rel , list < string > name list ) { final list < rex node > list = lists . new array list ( ) ; for ( string name : name list ) { final rel data type left row type = left rel . get row type ( ) ; rel data type field left field = catalog reader . field ( left row type , name ) ; rex node left = rex builder . make input ref ( left field . get type ( ) , left field . get index ( ) ) ; final rel data type right row type = right rel . get row type ( ) ; rel data type field right field = catalog reader . field ( right row type , name ) ; rex node right = rex builder . make input ref ( right field . get type ( ) , left row type . get field list ( ) . size ( ) + right field . get index ( ) ) ; rex node equals call = rex builder . make call ( sql std operator table . equals , left , right ) ; list . add ( equals call ) ; } return rex util . compose conjunction ( rex builder , list , false ) ; }"}
{"source": "the value of this attribute if this attribute is present in the map . otherwise # get default value ( ) <s> public byte get ( with attributes attributes ) { return attributes . get attributes ( ) . get ( this ) ; } <s> public byte get ( with attributes with attributes ) { return with attributes . get attributes ( ) . get ( this ) ; }"}
{"source": "current directory history . <s> private string [ ] get directory history ( ) { return new string [ ] { directory . get absolute path ( ) , str , str , str , str } ; } <s> private file [ ] get directory history ( ) { file [ ] dirhist = settings . instance ( ) . get directory history ( ) ; if ( dirhist = = null | | dirhist . length = = num ) return new file [ ] { new file ( str ) . get absolute file ( ) } ; else return dirhist ; }"}
{"source": "a vector containing all compile error messages <s> public vector get errors ( ) { return _ parser . get errors ( ) ; } <s> public array list < error msg > get errors ( ) { return _ parser . get errors ( ) ; }"}
{"source": "the total number of items in this adapter . <s> @ override public int get item count ( ) { int header or footer = num ; if ( custom header view ! = null ) header or footer + + ; if ( custom load more view ! = null ) header or footer + + ; return get adapter item count ( ) + header or footer ; } <s> @ override public int get item count ( ) { return get adapter item count ( ) + total additional items ( ) ; }"}
{"source": "the n - triples representation of the supplied value , or # null _ param _ value if the supplied value was null . <s> public static string encode value ( value value ) { return ntriples util . to ntriples string ( value ) ; } <s> public static string encode value ( value value ) { if ( value instanceof bnode ) { return ( ( bnode ) value ) . get id ( ) ; } return ntriples util . to ntriples string ( value ) ; }"}
{"source": "minimum value ( without checking d , d conditions ) <s> private attribute details min deque iterator ( attribute details val object ) { if ( value removed ! = null ) { for ( iterator < attribute details > iterator = min deque . descending iterator ( ) ; iterator . has next ( ) ; ) { double possible min value = iterator . next ( ) . get value ( ) ; if ( possible min value > val object . get value ( ) | | possible min value > = value removed . get value ( ) ) { if ( possible min value > val object . get value ( ) ) { iterator . remove ( ) ; } else if ( value removed . get value ( ) = = possible min value ) { iterator . remove ( ) ; break ; } } else { break ; } } } else { for ( iterator < attribute details > iterator = min deque . descending iterator ( ) ; iterator . has next ( ) ; ) { if ( iterator . next ( ) . get value ( ) > val object . get value ( ) ) { iterator . remove ( ) ; } else { break ; } } } val object . set min threshold ( ) ; min deque . add last ( val object ) ; return min deque . peek ( ) ; } <s> private attribute details min deque iterator ( attribute details val object ) { if ( value removed ! = null ) { for ( iterator < attribute details > iterator = min deque . descending iterator ( ) ; iterator . has next ( ) ; ) { attribute details possible min value = iterator . next ( ) ; if ( possible min value . get value ( ) > val object . get value ( ) | | possible min value . get value ( ) > = value removed . get value ( ) ) { if ( possible min value . get value ( ) > val object . get value ( ) ) { iterator . remove ( ) ; } else if ( value removed . equals ( possible min value ) ) { iterator . remove ( ) ; } } else { break ; } } } else { for ( iterator < attribute details > iterator = min deque . descending iterator ( ) ; iterator . has next ( ) ; ) { if ( iterator . next ( ) . get value ( ) > val object . get value ( ) ) { iterator . remove ( ) ; } else { break ; } } } val object . set min threshold ( ) ; min deque . add last ( val object ) ; return min deque . peek ( ) ; }"}
{"source": "injection option instance <s> public static from context get instance ( string option string ) { if ( name . get from string ( ) . equals ignore case ( option string ) ) return name ; else if ( metadata . get from string ( ) . equals ignore case ( option string ) ) return metadata ; else if ( scope . get from string ( ) . equals ignore case ( option string ) ) return scope ; else if ( id . get from string ( ) . equals ignore case ( option string ) ) return id ; else return new dynamic from context ( option string ) ; } <s> public static from context get instance ( string from string ) { if ( name . get from string ( ) . equals ignore case ( from string ) ) return name ; else if ( alias . get from string ( ) . equals ignore case ( from string ) ) return alias ; else if ( metadata . get from string ( ) . equals ignore case ( from string ) ) return metadata ; else if ( beaninfo . get from string ( ) . equals ignore case ( from string ) ) return beaninfo ; else if ( scope . get from string ( ) . equals ignore case ( from string ) ) return scope ; else if ( id . get from string ( ) . equals ignore case ( from string ) ) return id ; else return new dynamic from context ( from string ) ; }"}
{"source": "status . ok , if all went well ; status . file _ not _ found _ err if file not found . <s> int open ( ) { try { in reader = new buffered reader ( new file reader ( filename ) ) ; } catch ( file not found exception e ) { return ( status . file _ not _ found _ err ) ; } return ( status . ok ) ; } <s> public buffered reader open ( final string file name ) { buffered reader reader ; try { reader = new buffered reader ( new file reader ( file name ) ) ; } catch ( file not found exception e ) { return ( null ) ; } return ( reader ) ; }"}
{"source": "input value without any characters that might not be allowed for a filename <s> public static final string make filename ( string input ) { return input . replace all ( str , str ) ; } <s> public static final string make filename ( string input ) { if ( input = = null ) return null ; if ( input . equals ( str ) ) return str ; if ( input . equals ( str ) ) return str ; return input . replace all ( str , str ) . to lower case ( ) ; }"}
{"source": "user info response object <s> public user info response get user info ( oidcconfiguration oidc configuration , string acs token ) throws user info exception { bearer access token access token = new bearer access token ( acs token ) ; uri user info endpoint = oidc configuration . get user info endpoint ( ) ; user info request user info request = new user info request ( user info endpoint , access token ) ; httprequest request = user info request . to httprequest ( ) ; return process user info response ( request ) ; } <s> public user information response get user info ( oidcconfiguration oidc configuration , string acs token ) throws user info exception { bearer access token access token = new bearer access token ( acs token ) ; uri user info endpoint = oidc configuration . get user info endpoint ( ) ; user info request user info request = new user info request ( user info endpoint , access token ) ; httprequest request = user info request . to httprequest ( ) ; return process user info response ( request ) ; }"}
{"source": "project rel corresponding to the right child <s> protected project rel base get right child ( rel opt rule call call ) { return call . rel ( num ) ; } <s> protected project get right child ( rel opt rule call call ) { return call . rel ( num ) ; }"}
{"source": "the java . lang . runnable ( ) operation associated with this page that should be run during the wizard ' s do run epilogue ( ) method . this operation should only be executed if in fact the page is visible . <s> public runnable get operation ( ) { return operation ; } <s> public irunnable with progress get operation ( ) { return operation ; }"}
{"source": "the field for this accumulator <s> public object get field ( ) { return field ; } <s> @ deprecated public object get field ( ) { return get value ( ) ; }"}
{"source": "an open input stream , or null if no suitable output was produced <s> public final input stream get generated output ( ) throws curn exception { input stream result = null ; if ( has generated output ( ) ) { try { result = new file input stream ( output file ) ; } catch ( file not found exception ex ) { throw new curn exception ( curn . bundle _ name , str , str , new object [ ] { output file } , ex ) ; } } return result ; } <s> public final file get generated output ( ) throws curn exception { return has generated output ( ) ? output file : null ; }"}
{"source": "the update counts as an int [ ] <s> int [ ] get batch counts ( ) throws batch update exception { array list counts = new array list ( ) ; integer last count = jtds statement . success _ no _ info ; batch update exception batch ex = null ; try { check open ( ) ; while ( ! end of response ) { next token ( ) ; if ( current token . is result set ( ) ) { throw new sqlexception ( messages . get ( str ) , str ) ; } switch ( current token . token ) { case tds _ done _ token : if ( ( current token . status & done _ error ) ! = num ) { counts . add ( jtds statement . execute _ failed ) ; } else { if ( current token . is update count ( ) ) { counts . add ( new integer ( current token . update count ) ) ; } else { counts . add ( last count ) ; } } last count = jtds statement . success _ no _ info ; break ; case tds _ doneinproc _ token : if ( ( current token . status & done _ error ) ! = num ) { last count = jtds statement . execute _ failed ; } else if ( current token . is update count ( ) ) { last count = new integer ( current token . update count ) ; } break ; case tds _ doneproc _ token : if ( ( current token . status & done _ error ) ! = num ) { counts . add ( jtds statement . execute _ failed ) ; } else { counts . add ( last count ) ; } last count = jtds statement . success _ no _ info ; break ; } } messages . check errors ( ) ; } catch ( sqlexception e ) { int [ ] results = new int [ counts . size ( ) ] ; for ( int i = num ; i < results . length ; i + + ) { results [ i ] = ( ( integer ) counts . get ( i ) ) . int value ( ) ; } batch ex = new batch update exception ( e . get message ( ) , e . get sqlstate ( ) , e . get error code ( ) , results ) ; throw batch ex ; } finally { while ( ! end of response ) { try { next token ( ) ; } catch ( sqlexception ex ) { if ( batch ex ! = null <s> sqlexception get batch counts ( array list counts , sqlexception sql ex ) { integer last count = jtds statement . success _ no _ info ; try { check open ( ) ; while ( ! end of response ) { next token ( ) ; if ( current token . is result set ( ) ) { throw new sqlexception ( messages . get ( str ) , str ) ; } switch ( current token . token ) { case tds _ done _ token : if ( ( current token . status & done _ error ) ! = num | | last count = = jtds statement . execute _ failed ) { if ( connection . get server type ( ) = = driver . sybase ) { counts . add ( jtds statement . execute _ failed ) ; } } else { if ( current token . is update count ( ) ) { counts . add ( new integer ( current token . update count ) ) ; } else { counts . add ( last count ) ; } } last count = jtds statement . success _ no _ info ; break ; case tds _ doneinproc _ token : if ( ( current token . status & done _ error ) ! = num ) { last count = jtds statement . execute _ failed ; } else if ( current token . is update count ( ) ) { last count = new integer ( current token . update count ) ; } break ; case tds _ doneproc _ token : if ( ( current token . status & done _ error ) ! = num | | last count = = jtds statement . execute _ failed ) { if ( connection . get server type ( ) = = driver . sybase ) { counts . add ( jtds statement . execute _ failed ) ; } } else { counts . add ( last count ) ; } last count = jtds statement . success _ no _ info ; break ; } } messages . check errors ( ) ; } catch ( sqlexception e ) { if ( sql ex ! = null ) { sql ex . set next exception ( e ) ; } else { sql ex = e ; } } finally { while ( ! end of response ) { try { next token ( ) ; } catch ( sqlexception ex ) { if ( sql ex ! = null ) { sql ex . set next exception ( ex ) ; } else {"}
{"source": "whether cv1t1 is reference - compatible with cv2t2 <s> private static final boolean is reference compatible ( itype cv1t1 , itype cv2t2 ) throws domexception { if ( is reference related ( cv1t1 , cv2t2 ) ) { integer cmp = compare qualifications ( cv1t1 , cv2t2 ) ; return cmp ! = null & & cmp > = num ; } return false ; } <s> private static final cost is reference compatible ( itype cv1 target , itype cv2 source ) throws domexception { final int inheritance dist = is reference related ( cv1 target , cv2 source ) ; if ( inheritance dist < num ) return null ; final int cmp = compare qualifications ( cv1 target , cv2 source ) ; if ( cmp < num ) return null ; cost cost = new cost ( cv2 source , cv1 target ) ; cost . qualification = cmp > num ? cost . conversion _ rank : cost . identity _ rank ; cost . conversion = inheritance dist ; return cost ; }"}
{"source": "red value in given position <s> public short get red ( final int i ) { return data [ get1 dindex ( i ) ] ; } <s> public short get red ( ) { return data [ get first1 dindex ( ) ] ; }"}
{"source": "list of unread priority messages <s> public list < gmail message > get priority messages ( ) { try { final list < gmail message > unread priority = new array list < gmail message > ( ) ; final store store = open gmail store ( ) ; folder folder = get folder ( imap gmail label . important . get name ( ) , store ) ; folder . open ( folder . read _ only ) ; for ( final message msg : folder . search ( new flag term ( new flags ( flags . flag . seen ) , false ) ) ) { unread priority . add ( new java mail gmail message ( msg ) ) ; } return unread priority ; } catch ( final exception e ) { throw new gmail exception ( str , e ) ; } } <s> public list < gmail message > get priority messages ( boolean unread only ) { try { final list < gmail message > priority messages = new array list < gmail message > ( ) ; final store store = open gmail store ( ) ; folder folder = get folder ( imap gmail label . important . get name ( ) , store ) ; folder . open ( folder . read _ only ) ; for ( final message msg : folder . search ( new flag term ( new flags ( flags . flag . seen ) , ! unread only ) ) ) { priority messages . add ( new java mail gmail message ( msg ) ) ; } return priority messages ; } catch ( final exception e ) { throw new gmail exception ( str , e ) ; } }"}
{"source": "absolute path to directory in which native bower call must be performed . basically , the method scans project for bower . json file and returns it ' s parent , ignoring components directories i . e \" bower _ components \" or defined in . bowerrc file <s> public static string get bower working dir ( iproject project , final string . . . ignores ) throws core exception { string working dir = null ; final list < ifile > found files = new array list < > ( ) ; if ( project ! = null & & project . exists ( ) ) { project . accept ( new iresource visitor ( ) { @ override public boolean visit ( iresource resource ) throws core exception { if ( ! found files . is empty ( ) ) { return false ; } else if ( resource . get type ( ) = = iresource . folder & & ignores ! = null ) { for ( string ignore : ignores ) { if ( resource . get name ( ) . equals ( ignore ) ) { return false ; } } } else if ( resource . get type ( ) = = iresource . file & & bower constants . bower _ json . equals ( resource . get name ( ) ) ) { found files . add ( ( ifile ) resource ) ; } return true ; } } ) ; } if ( ! found files . is empty ( ) ) { working dir = found files . get ( num ) . get parent ( ) . get full path ( ) . to osstring ( ) ; } return working dir ; } <s> public static ipath get bower working dir ( iproject project , final string . . . ignores ) throws core exception { ipath working dir = null ; final list < ifile > found files = new array list < > ( ) ; if ( project ! = null & & project . exists ( ) ) { project . accept ( new iresource visitor ( ) { @ override public boolean visit ( iresource resource ) throws core exception { if ( ! found files . is empty ( ) ) { return false ; } else if ( resource . get type ( ) = = iresource . folder & & ignores ! = null ) { for ( string ignore : ignores ) { if ( resource . get name ( ) . equals ( ignore ) ) { return false ; } } } else if ( resource . get type ( ) = = iresource . file & & bower constants . bower _ json . equals ( resource . get name ( ) ) ) { found files . add ( ( ifile ) resource ) ; } return true ; } } ) ; } if ( ! found files . is empty ( ) ) { working dir = found files . get ( num ) . get parent ( ) . get location ( ) ; } return working dir ; }"}
{"source": "the minimum java version required to run this add - on or an empty string if no minimum version <s> public string get minimum java version ( ) { if ( dependencies = = null ) { return str ; } return dependencies . get java version ( ) ; } <s> public string get minimum java version ( ) { return minimum java version ; }"}
{"source": "the response , or an exception if something bad happened <s> private < t > t process response ( final client response client response , final type response type ) { final string response = read response from client response ( client response ) ; if ( client response . get status ( ) > = num ) { throw new handshake apiexception ( response ) ; } try { return parse json ( response , response type ) ; } catch ( final ioexception e ) { throw new runtime exception ( e ) ; } } <s> private < t > t process response ( final client response client response , final type response type ) { final string response = read response from client response ( client response ) ; if ( client response . get status ( ) = = num ) { return null ; } else if ( client response . get status ( ) > = num ) { throw new handshake apiexception ( response ) ; } try { return parse json ( response , response type ) ; } catch ( final ioexception e ) { throw new runtime exception ( e ) ; } }"}
{"source": "the session id which now contains the memcached id . <s> public string create session id ( final string session id , final string memcached id ) { final int idx = session id . index of ( str ) ; if ( idx < num ) { return session id + str + memcached id ; } else { return session id . substring ( num , idx ) + str + memcached id + session id . substring ( idx ) ; } } <s> public string create session id ( final string session id , final string memcached id ) { if ( memcached id = = null ) { return session id ; } final int idx = session id . index of ( str ) ; if ( idx < num ) { return session id + str + memcached id ; } else { return session id . substring ( num , idx ) + str + memcached id + session id . substring ( idx ) ; } }"}
{"source": "the physical class used by the runtime <s> public class < p > get physical ( ) { return physical ; } <s> public type get physical ( ) { return physical ; }"}
{"source": "the field hashmap [ field _ name , type ] . <s> public hash map get fields ( ) { return m _ fields ; } <s> public map get fields ( ) { return m _ fields ; }"}
{"source": "a set of class names and class member signatures found in the class . <s> public static set < string > find referenced members ( field info field info ) { set < string > members = new hash set < string > ( ) ; class member visitor visitor = new class member visitor ( members ) ; set < integer > ids = find pool references ( field info ) ; visitor . visit field ( field info ) ; visit pool references ( field info . get class info ( ) , visitor , ids ) ; return members ; } <s> public static reference result find referenced members ( field info field info ) { set < string > members = new hash set < string > ( ) ; class member visitor visitor = new class member visitor ( members ) ; set < integer > ids = find pool references ( field info ) ; visitor . visit field ( field info ) ; visit pool references ( field info . get class info ( ) , visitor , ids ) ; return new reference result ( members , new array list < invoke site > ( num ) ) ; }"}
{"source": "the extended fluent pipeline <s> public t out v ( ) { return this . add ( new out vertex pipe ( ) ) ; } <s> public gremlin pipeline < s , vertex > out v ( ) { return this . add ( new out vertex pipe ( ) ) ; }"}
{"source": "map of properties <s> public static string add properties to urifrom bean ( string uri , object bean ) throws exception { map < string , string > props = property util . get properties ( bean ) ; return property util . add properties to uri ( uri , props ) ; } <s> public static string add properties to urifrom bean ( string uri , object bean ) throws exception { map < string , string > properties = property util . get properties ( bean ) ; return property util . add properties to uri ( uri , properties ) ; }"}
{"source": "the cmd line option instances which failed validation . <s> public static set < cmd line option instance > validate ( cmd line args cmd line args ) { validate . not null ( cmd line args ) ; hash set < cmd line option instance > options failed = new hash set < cmd line option instance > ( ) ; for ( cmd line option instance option inst : cmd line args . get specified options ( ) ) { if ( ! cmd line utils . validate ( option inst ) ) { options failed . add ( option inst ) ; } } return options failed ; } <s> public static list < cmd line option validator . result > validate ( cmd line args cmd line args ) { validate . not null ( cmd line args ) ; list < cmd line option validator . result > results = lists . new array list ( ) ; for ( cmd line option instance option inst : cmd line args . get specified options ( ) ) { results . add all ( cmd line utils . validate ( option inst ) ) ; } return results ; }"}
{"source": "the color schema , or null if the measure targer is 0 <s> public mcolor schema get color schema ( ) { return ( get measure target ( ) . signum ( ) = = num ) ? null : mcolor schema . get ( get ctx ( ) , get pa _ color schema _ id ( ) ) ; } <s> public mcolor schema get color schema ( ) { return mcolor schema . get ( get ctx ( ) , get pa _ color schema _ id ( ) ) ; }"}
{"source": "a map containing the body parameters . <s> public map < string , string > get body params ( ) { return body params ; } <s> public parameter list get body params ( ) { return body params ; }"}
{"source": "the session tracker valve . session backup service . backup result <s> public backup result backup session ( final session session ) { if ( _ log . is info enabled ( ) ) { _ log . debug ( str + session . get id ( ) ) ; } final backup session task task = get or create backup session task ( ( memcached backup session ) session ) ; return task . backup session ( ) ; } <s> public backup result status backup session ( final session session ) { if ( _ log . is info enabled ( ) ) { _ log . debug ( str + session . get id ( ) ) ; } final memcached backup session backup session = ( memcached backup session ) session ; final backup session task task = get or create backup session task ( backup session ) ; final map < string , object > attributes = backup session . get attributes internal ( ) ; final byte [ ] attributes data = _ transcoder service . serialize attributes ( backup session , attributes ) ; final int hash code = arrays . hash code ( attributes data ) ; if ( backup session . get data hash code ( ) ! = hash code | | task . session cookie was relocated ( ) ) { final byte [ ] data = _ transcoder service . serialize ( backup session , attributes data ) ; final backup result result = task . backup session ( data , attributes data ) ; if ( result . get attributes data ( ) ! = null ) { backup session . set data hash code ( arrays . hash code ( result . get attributes data ( ) ) ) ; } return result . get status ( ) ; } else { return backup result status . skipped ; } }"}
{"source": "the created project , or null if file was not writable . <s> public static project create afproject ( file file ) { return create project ( file , type . af ) ; } <s> public static project create afproject ( file file ) { return create project ( file , af ) ; }"}
{"source": "the decoded value type or # x if the char does not map to a value type <s> public static value type decode ( final char c ) { final value type v = decode by int . get ( c ) ; return v = = null ? x : v ; } <s> public static value type decode ( final char c ) { final value type v = decode by int . get ( c ) ; return v = = null ? directed : v ; }"}
{"source": "int the crowdmap id <s> public int get crowdmap id ( ) { return this . crowdmap id ; } <s> public string get crowdmap id ( ) { return this . crowdmap id ; }"}
{"source": "a hashtable which contains all datatypes <s> public hashtable get built in types ( ) { return ( hashtable ) f built in types . clone ( ) ; } <s> @ override public map < string , datatype validator > get built in types ( ) { return new hash map < > ( f built in types ) ; }"}
{"source": "iterator the ports specified in the wsdl file <s> public iterator get ports ( ) throws service exception { if ( wsdl service = = null | | wsdl service . get ports ( ) = = null ) { return new vector ( ) . iterator ( ) ; } return wsdl service . get ports ( ) . values ( ) . iterator ( ) ; } <s> public iterator get ports ( ) throws service exception { if ( wsdl service = = null | | wsdl service . get ports ( ) = = null ) { return new vector ( ) . iterator ( ) ; } return wsdl service . get ports ( ) . key set ( ) . iterator ( ) ; }"}
{"source": "result of calling shared named pipe # calculate buffer size ( int , int ) . <s> private int invoke _ calculate buffer size ( int tds version , int packet size ) { class [ ] classes = new class [ ] { int . class , int . class } ; object [ ] objects = new object [ ] { new integer ( tds version ) , new integer ( packet size ) } ; return ( ( integer ) invoke static method ( shared named pipe . class , str , classes , objects ) ) . int value ( ) ; } <s> private int invoke _ calculate buffer size ( int tds version , int packet size ) { class [ ] classes = new class [ ] { int . class , int . class } ; object [ ] objects = new object [ ] { new integer ( tds version ) , new integer ( packet size ) } ; return ( ( integer ) invoke static method ( support . class , str , classes , objects ) ) . int value ( ) ; }"}
{"source": "list of cookies that were read json cookie . <s> public static list < http cookie > load cookies ( path path ) throws ioexception { list < http cookie > cookie list ; try ( buffered reader reader = files . new buffered reader ( path ) ) { list < json cookie > json cookies = jackson . new object mapper ( ) . read value ( reader , new type reference < list < json cookie > > ( ) { } ) ; cookie list = json cookies . stream ( ) . map ( c - > json cookie . to http cookie ( c ) ) . collect ( collectors . to list ( ) ) ; } return cookie list ; } <s> public static list < http cookie > load cookies ( path path ) throws ioexception { type reference cookies type = new type reference < list < json cookie > > ( ) { } ; try ( buffered reader reader = files . new buffered reader ( path ) ) { list < json cookie > json cookies = mapper . read value ( reader , cookies type ) ; return json cookies . stream ( ) . map ( json cookie : : to http cookie ) . collect ( to list ( ) ) ; } }"}
{"source": "a jsonobject which is the value . <s> public jsonobject get jsonobject ( string key ) { object object = this . get ( key ) ; if ( object instanceof jsonobject ) { return ( jsonobject ) object ; } throw new runtime exception ( str + quote ( key ) + str ) ; } <s> public jsonobject get jsonobject ( string key ) { object object = this . get ( key ) ; if ( object = = null ) { return null ; } if ( object instanceof jsonobject ) { return ( jsonobject ) object ; } throw new runtime exception ( str + quote ( key ) + str ) ; }"}
{"source": "true if the token is empty ( token = \" \" , secret = \" \" ) <s> public boolean is empty ( ) { return str . equals ( this . get token ( ) ) & & str . equals ( this . secret ) ; } <s> public boolean is empty ( ) { return str . equals ( token ) & & str . equals ( token secret ) ; }"}
{"source": "the char [ ] <s> public static char [ ] union ( char [ ] c1 , char [ ] c2 ) { string builder sb = new string builder ( ) ; for ( int i = num ; i < c1 . length ; i + + ) { if ( ! contains ( sb , c1 [ i ] ) ) sb . append ( c1 [ i ] ) ; } for ( int i = num ; i < c2 . length ; i + + ) { if ( ! contains ( sb , c2 [ i ] ) ) sb . append ( c2 [ i ] ) ; } char [ ] c3 = new char [ sb . length ( ) ] ; sb . get chars ( num , sb . length ( ) , c3 , num ) ; arrays . sort ( c3 ) ; return c3 ; } <s> public static char [ ] union ( char [ ] . . . list ) { string builder sb = new string builder ( ) ; for ( char [ ] characters : list ) { for ( int i = num ; i < list . length ; i + + ) { if ( ! contains ( sb , characters [ i ] ) ) sb . append ( list [ i ] ) ; } } char [ ] to return = new char [ sb . length ( ) ] ; sb . get chars ( num , sb . length ( ) , to return , num ) ; arrays . sort ( to return ) ; return to return ; }"}
{"source": "protocol result . <s> private connection result handle redirect ( ibasic request old request , headers response headers ) { ibasic request redirect request = null ; redirect handler redirect handler = old request . get redirect handler ( ) ; if ( redirect handler ! = null ) { if ( redirect handler . is disallowed redirect ( response headers ) ) return new connection result ( null , response headers , null , null ) ; else redirect request = redirect handler . on redirect ( response headers ) ; } if ( redirect request = = null ) { redirect request = new string request ( response headers . get location ( ) , old request . get request method ( ) ) ; redirect request . set sslsocket factory ( old request . get sslsocket factory ( ) ) ; redirect request . set hostname verifier ( old request . get hostname verifier ( ) ) ; redirect request . set proxy ( old request . get proxy ( ) ) ; } return get connection ( redirect request ) ; } <s> private connection handle redirect ( ibasic request old request , headers response headers ) { ibasic request redirect request = null ; redirect handler redirect handler = old request . get redirect handler ( ) ; if ( redirect handler ! = null ) { if ( redirect handler . is disallowed redirect ( response headers ) ) return new connection ( null , response headers , null , null ) ; else redirect request = redirect handler . on redirect ( response headers ) ; } if ( redirect request = = null ) { redirect request = new string request ( response headers . get location ( ) , old request . get request method ( ) ) ; redirect request . set sslsocket factory ( old request . get sslsocket factory ( ) ) ; redirect request . set hostname verifier ( old request . get hostname verifier ( ) ) ; redirect request . set proxy ( old request . get proxy ( ) ) ; } return get connection ( redirect request ) ; }"}
{"source": "state ( - 1 : not started , 0 : pending , 1 : canceled , 2 : established , 3 : terminated ) <s> public int get session state ( ) { return session . get session state ( ) ; } <s> public int get session state ( ) { return server api utils . get session state ( session ) ; }"}
{"source": "true if content is equal . <s> @ override public boolean equals ( object obj ) { if ( obj ! = null & & obj . get class ( ) . equals ( this . get class ( ) ) ) { note object that = ( note object ) obj ; return ( this . content . equals ( that . get content ( ) ) ) ; } return false ; } <s> @ override public boolean equals ( object obj ) { if ( obj ! = null & & obj . get class ( ) . equals ( this . get class ( ) ) ) { note object that = ( note object ) obj ; if ( content = = null & & that . get content ( ) ! = null ) return false ; if ( content ! = null & & ! content . equals ( that . get content ( ) ) ) return false ; } return true ; }"}
{"source": "a binary predicate that will call println ( x ) on the java . io . print stream y <s> public static < x > binary predicate < x , print stream > println ( ) { return new print line < x > ( ) ; } <s> public static < x > binary visitor < x , print stream > println ( ) { return new print line < x > ( ) ; }"}
{"source": "module class loader <s> public module class loader get loader ( ) { return loader ; } <s> public module jar class loader get loader ( ) { return loader ; }"}
{"source": "returns the charset . <s> public string get charset ( ) { return charset ; } <s> public string get charset ( ) { if ( charset ! = null ) { return charset . name ( ) ; } return default _ charset ; }"}
{"source": "the entity as an input stream . <s> public final branching input stream get entity ( ) { return entity ; } <s> public final entity get entity ( ) { return entity ; }"}
{"source": "current number of words for study <s> public long get count of the words ( ) { return ( long ) em . create query ( str ) . get single result ( ) ; } <s> public long get count of the words ( string study set name ) { return ( long ) em . create query ( str ) . set parameter ( str , study set name ) . get single result ( ) ; }"}
{"source": "number of terminals hosted by the pane <s> public int get terminal count ( ) { return terminal sessions panel _ . get widget count ( ) ; } <s> public int get terminal count ( ) { return active terminal toolbar button _ . terminal count ( ) ; }"}
{"source": "the route provider descriptor , never null . this object and all of its contents should be treated as if it were immutable so that it is safe for clients to cache it . <s> public final route provider descriptor get descriptor ( ) { return m descriptor ; } <s> public final provider descriptor get descriptor ( ) { return m descriptor ; }"}
{"source": "watt - the amount of rejected power to be sent back into the conductor <s> @ override public int on receive liquid ( int type , int amt , byte side ) { if ( type = = this . type ) { int rejected liquid = math . max ( ( this . get stored liquid ( type ) + amt ) - this . capacity , num ) ; this . liquid stored + = watt - rejected electricity ; return rejected liquid ; } return watt ; } <s> @ override public int on receive liquid ( int type , int vol , byte side ) { if ( type = = this . type ) { int rejected volume = math . max ( ( this . get stored liquid ( type ) + vol ) - this . capacity , num ) ; this . liquid stored = vol - rejected volume ; return rejected volume ; } return vol ; }"}
{"source": "the size of tiles in pixels <s> public int get tile size ( ) { return tile size ; } <s> @ deprecated public int get tile size ( ) { return math . max ( tile height , tile width ) ; }"}
{"source": "the key size <s> public static int get key length ( asymmetric key parameter key params ) throws crypto exception { if ( key params instanceof rsakey parameters ) { return ( ( rsakey parameters ) key params ) . get modulus ( ) . bit length ( ) ; } else if ( key params instanceof dsakey parameters ) { return ( ( dsakey parameters ) key params ) . get parameters ( ) . get p ( ) . bit length ( ) ; } else if ( key params instanceof dhkey parameters ) { return ( ( dhkey parameters ) key params ) . get parameters ( ) . get p ( ) . bit length ( ) ; } else { throw new crypto exception ( rb . get string ( str ) ) ; } } <s> public static int get key length ( asymmetric key parameter key params ) { if ( key params instanceof rsakey parameters ) { return ( ( rsakey parameters ) key params ) . get modulus ( ) . bit length ( ) ; } else if ( key params instanceof dsakey parameters ) { return ( ( dsakey parameters ) key params ) . get parameters ( ) . get p ( ) . bit length ( ) ; } else if ( key params instanceof dhkey parameters ) { return ( ( dhkey parameters ) key params ) . get parameters ( ) . get p ( ) . bit length ( ) ; } else if ( key params instanceof eckey parameters ) { return unknown _ key _ size ; } log . warning ( str + key params ) ; return unknown _ key _ size ; }"}
{"source": "a matcher that uses the ui element returned by first matcher as context for the second matcher <s> public static chain matcher chain ( matcher first , matcher second ) { return new chain matcher ( first , second ) ; } <s> public static chain finder chain ( finder first , finder second ) { return new chain finder ( first , second ) ; }"}
{"source": "the graph item located at the given point , if any <s> public graph item find item ( point p ) { point2 d p2 = ( m _ itransform = = null ? p : m _ itransform . transform ( p , m _ tmp point ) ) ; synchronized ( m _ registry ) { iterator items = m _ registry . get items reversed ( ) ; while ( items . has next ( ) ) { graph item gi = ( graph item ) items . next ( ) ; renderer r = gi . get renderer ( ) ; if ( r ! = null & & r . locate point ( p2 , gi ) ) { return gi ; } } } return null ; } <s> public visual item find item ( point p ) { point2 d p2 = ( m _ itransform = = null ? p : m _ itransform . transform ( p , m _ tmp point ) ) ; synchronized ( m _ registry ) { iterator items = m _ registry . get items reversed ( ) ; while ( items . has next ( ) ) { visual item vi = ( visual item ) items . next ( ) ; renderer r = vi . get renderer ( ) ; if ( r ! = null & & r . locate point ( p2 , vi ) ) { return vi ; } } } return null ; }"}
{"source": "the next power of two that is larger than the specified long value <s> public static long next power of two ( long value ) { if ( ! is power of two ( value ) ) { value - - ; value | = value > > num ; value | = value > > num ; value | = value > > num ; value | = value > > num ; value | = value > > num ; value | = value > > num ; value + + ; } return value ; } <s> public static long next power of two ( final long value ) { return num < < ( num - long . number of leading zeros ( value - num ) ) ; }"}
{"source": "the operator ' s arguments . <s> public list < expr > get args ( ) { return args ; } <s> public list < expr > get args ( ) { return new copy on write array list < expr > ( args ) ; }"}
{"source": "the value of this attribute if this attribute is present in the map . otherwise # get default value ( ) <s> public int get ( with attributes attributes ) { return attributes . get attributes ( ) . get ( this ) ; } <s> public int get ( with attributes with attributes ) { return with attributes . get attributes ( ) . get ( this ) ; }"}
{"source": "the component metadata . <s> public element [ ] get components metadata ( ) throws parse exception { return m _ elements [ num ] . get elements ( str ) ; } <s> public element [ ] get components metadata ( ) throws parse exception { element [ ] components = m _ elements [ num ] . get elements ( str ) ; element [ ] composites = m _ elements [ num ] . get elements ( str ) ; element [ ] all = new element [ components . length + composites . length ] ; int l = num ; for ( int i = num ; i < components . length ; i + + ) { all [ l ] = components [ i ] ; l + + ; } for ( int i = num ; i < composites . length ; i + + ) { all [ l ] = composites [ i ] ; l + + ; } return all ; }"}
{"source": "time , expressed as milliseconds since the epoch . <s> public long get commit time ( ) { return commit time ; } <s> public int get commit time ( ) { return commit time ; }"}
{"source": "the jenkins job name for the given namespace and build config name and default namesapce <s> public static string jenkins job name ( string namespace , string build config name , string default namespace ) { if ( namespace = = null | | namespace . length ( ) = = num | | namespace . equals ( default namespace ) ) { return build config name ; } return namespace + str + build config name ; } <s> public static string jenkins job name ( string namespace , string build config name ) { return namespace + str + build config name ; }"}
{"source": "the port <s> public int get port ( ) { return port ; } <s> public int get port ( ) { return server port ; }"}
{"source": "cube request cube change request <s> @ request mapping ( value = str , method = { request method . post } ) @ response body public cube request save cube desc ( @ request body cube request cube request ) { metadata manager meta manager = metadata manager . get instance ( cube service . get config ( ) ) ; data model desc model desc = deserialize data model desc ( cube request ) ; if ( model desc = = null ) { return error request ( cube request , str ) ; } if ( string utils . is empty ( model desc . get name ( ) ) ) { return error request ( cube request , str ) ; } try { data model desc existing model = meta manager . get data model desc ( model desc . get name ( ) ) ; if ( existing model = = null ) { meta manager . create data model desc ( model desc ) ; } else { model desc . set last modified ( existing model . get last modified ( ) ) ; meta manager . update data model desc ( model desc ) ; } } catch ( ioexception e ) { logger . error ( str + e . get localized message ( ) , e ) ; throw new internal error exception ( str + e . get localized message ( ) ) ; } cube desc desc = deserialize cube desc ( cube request ) ; if ( desc = = null ) { return cube request ; } if ( string utils . is empty ( desc . get name ( ) ) ) { logger . info ( str ) ; return error request ( cube request , str ) ; } try { desc . set uuid ( uuid . random uuid ( ) . to string ( ) ) ; string project name = ( null = = cube request . get project ( ) ) ? project instance . default _ project _ name : cube request . get project ( ) ; cube instance created cube = cube service . create cube and desc ( desc . get name ( ) , project name , desc ) ; access service . init ( created cube , acl permission . administration ) ; project instance project = cube service . get project manager ( ) . get project ( project name ) ; access service . inherit ( created cube , project ) ; } catch ( exception e ) { logger . error ( str , e ) ; throw new internal error exception ( e . get localized message ( ) , e ) ; } cube request . set uuid ( desc . get uuid ( ) ) ; cube request . set successful ( true ) <s> @ request mapping ( value = str , method = { request method . post } ) @ response body public cube request save cube desc ( @ request body cube request cube request ) { cube desc desc = deserialize cube desc ( cube request ) ; if ( desc = = null ) { cube request . set message ( str ) ; return cube request ; } string name = cube service . get cube name from desc ( desc . get name ( ) ) ; if ( string utils . is empty ( name ) ) { logger . info ( str ) ; throw new bad request exception ( str ) ; } cube instance cube instance ; try { desc . set uuid ( uuid . random uuid ( ) . to string ( ) ) ; string project name = ( null = = cube request . get project ( ) ) ? project instance . default _ project _ name : cube request . get project ( ) ; cube instance = cube service . create cube and desc ( name , project name , desc ) ; } catch ( exception e ) { logger . error ( str , e ) ; throw new internal error exception ( e . get localized message ( ) , e ) ; } boolean create streaming config success = false , create kafka config success = false ; streaming config streaming config = null ; kafka config kafka config = null ; boolean is streaming cube = cube request . get streaming cube ( ) ! = null & & cube request . get streaming cube ( ) . equals ( str ) ; try { if ( is streaming cube ) { streaming config = deserialize streaming desc ( cube request ) ; kafka config = deserialize kafka desc ( cube request ) ; if ( kafka config = = null ) { cube request . set message ( str ) ; return cube request ; } if ( streaming config = = null ) { cube request . set message ( str ) ; return cube request ; } try { streaming config . set uuid ( uuid . random uuid ( ) . to string ( ) ) ; streaming service . create streaming config ( streaming config ) ; create streaming config success = true ; } catch ( ioexception e ) { logger . error ( str + e . get localized message ( ) , e ) ; throw new internal error exception ( str + e . get localized message ( ) ) ; } try { kafka config . set uuid ( uuid . random uuid ( ) . to string ( ) ) ; kafka config service . create kafka config ( kafka config ) ;"}
{"source": "a file value <s> public string get document path ( ) { return get publication ( ) . get path mapper ( ) . get path ( get document ( ) . get uuid ( ) , get document ( ) . get language ( ) ) ; } <s> public string get document path ( ) { if ( this . path = = null ) { final document doc = get document ( ) ; try { this . path = doc ! = null ? doc . get path ( ) : get publication ( ) . get document builder ( ) . get locator ( this . factory , this . webapp url ) . get path ( ) ; } catch ( final exception e ) { throw new runtime exception ( e ) ; } } return this . path ; }"}
{"source": "an instance of the specified class <s> public async support new comet support ( final class < ? extends async support > target class ) { try { return ( async support ) target class . get declared constructor ( new class [ ] { atmosphere config . class } ) . new instance ( config ) ; } catch ( final exception e ) { logger . error ( str , target class , e ) ; logger . error ( str ) ; return new blocking iocomet support ( config ) ; } } <s> public async support new comet support ( final class < ? extends async support > target class ) { try { return ( async support ) target class . get declared constructor ( new class [ ] { atmosphere config . class } ) . new instance ( config ) ; } catch ( final exception e ) { logger . warn ( str , target class , e ) ; return null ; } }"}
{"source": "a dcc chat object that can be used to send and recieve lines of text . returns null if the connection could not be made . <s> public dcc chat dcc send chat request ( user sender , int timeout ) throws ioexception , socket timeout exception { if ( sender = = null ) throw new illegal argument exception ( str ) ; server socket ss = null ; ss . set so timeout ( timeout ) ; int server port = ss . get local port ( ) ; inet address our address = get dcc inet address ( ) ; if ( our address = = null ) our address = get inet address ( ) ; string ip num = dcc manager . address to integer ( our address ) ; send ctcpcommand ( sender , str + ip num + str + server port ) ; socket user socket = ss . accept ( ) ; ss . close ( ) ; return new dcc chat ( this , sender , user socket ) ; } <s> public chat dcc send chat request ( user sender , int timeout ) throws ioexception , socket timeout exception { return dcc handler . send chat request ( sender ) ; }"}
{"source": "true if the left and right side of the viewer are mirrored . default is false . <s> public boolean is mirrored ( ) { object property = get property ( mirrored ) ; return property instanceof boolean & & ( boolean ) property ; } <s> public boolean is mirrored ( ) { if ( ! f mirroring enabled ) return false ; object property = get property ( mirrored ) ; return property instanceof boolean & & ( boolean ) property ; }"}
{"source": "the stored value or null if it doesn ' t exist in specified form . <s> public double get extra double ( string key ) { return m extra data . opt double ( key ) ; } <s> public double get extra double ( string key ) throws jsonexception { return m extra data . get double ( key ) ; }"}
{"source": "the memory usage in # unit <s> public long get usage ( ) { return usage ; } <s> public double get usage ( ) { return usage ; }"}
{"source": "sentence index or const # nonexist if stack doesn ' t have an element at this index <s> public int get buffer ( int k ) { return ( k > = num & & k < get buffer size ( ) ) ? buffer . get ( k ) : const . nonexist ; } <s> public int get buffer ( int k ) { return ( k > = num & & k < get buffer size ( ) ) ? buffer . get ( k ) : config . nonexist ; }"}
{"source": "a repository method metadata initializer corresponding to the method parameter . <s> public repository method metadata lookup method ( class < ? > repo class , method method ) { return lookup component ( repo class ) . get methods metadata ( ) . get ( method ) ; } <s> public repository method metadata lookup method ( repository metadata repository metadata , method method ) { return repository metadata . get methods metadata ( ) . get ( method ) ; }"}
{"source": "the error encountered , or null if the request succeeded <s> public final facebook exception get error ( ) { return error ; } <s> public final facebook request error get error ( ) { return error ; }"}
{"source": "map of document id - > string [ ' val1 ' , ' val2 ' . . . ] <s> public java . util . map < string , string [ ] > get metadata by name ( string name , string [ ] docs ) throws repository access exception { hash map < string , string [ ] > vals = new hash map < string , string [ ] > ( ) ; hash set < string > active fields = new hash set < string > ( ) ; hash set < string > lazy fields = new hash set < string > ( ) ; active fields . add ( lucene _ docid _ field ) ; lazy fields . add ( name ) ; set based field selector fsel = new set based field selector ( active fields , lazy fields ) ; index reader lreader ; try { lreader = this . get index reader ( ) ; int last = lreader . max doc ( ) ; document d ; string doc id ; for ( int i = num ; i < last ; + + i ) { if ( ! lreader . is deleted ( i ) ) { d = lreader . document ( i , fsel ) ; doc id = d . get ( lucene _ docid _ field ) ; for ( string did : docs ) if ( did . equals ( doc id ) ) vals . put ( doc id , d . get values ( name ) ) ; } } lreader . close ( ) ; } catch ( java . io . ioexception ioe ) { throw new repository access exception ( str + ioe . get message ( ) ) ; } return vals ; } <s> public document collection get metadata by name ( string name , string [ ] docs ) throws repository access exception { string [ ] names = { name } ; return this . get doc collection ( names , docs ) ; }"}
{"source": "the stored value or null if it doesn ' t exist in specified form . <s> public jsonarray get extra jsonarray ( string key ) { return m extra data . opt jsonarray ( key ) ; } <s> public jsonarray get extra jsonarray ( string key ) throws jsonexception { return m extra data . get jsonarray ( key ) ; }"}
{"source": "the list of currently open projects in the workspace in the order in which they would be built by iworkspace . build . <s> public iproject [ ] get build order ( ) { if ( build order ! = null ) { return build order ; } string [ ] order = description . get build order ( false ) ; if ( order ! = null ) { list project list = new array list ( order . length ) ; for ( int i = num ; i < order . length ; i + + ) { iproject project = get root ( ) . get project ( order [ i ] ) ; if ( project . is accessible ( ) ) { project list . add ( project ) ; } } build order = new iproject [ project list . size ( ) ] ; project list . to array ( build order ) ; } else { build order = compute full project order ( ) . projects ; } return build order ; } <s> public ibuild configuration [ ] get build order ( ) { if ( build order ! = null ) return build order ; string [ ] order = description . get build order ( false ) ; if ( order ! = null ) { linked hash set configs = new linked hash set ( ) ; for ( int i = num ; i < order . length ; i + + ) { iproject project = get root ( ) . get project ( order [ i ] ) ; if ( project . is accessible ( ) ) configs . add ( ( ( project ) project ) . internal get active build config ( ) ) ; } configs . add all ( arrays . as list ( vertex order to project build config order ( compute active build configuration order ( ) ) . build configurations ) ) ; ibuild configuration [ ] bo = new ibuild configuration [ configs . size ( ) ] ; configs . to array ( bo ) ; this . build order = bo ; } else build order = vertex order to project build config order ( compute active build configuration order ( ) ) . build configurations ; return build order ; }"}
{"source": "a list of sqlrow . <s> private list < sqlrow > get tree ( sqlrow row , boolean archived ) { check ( row ) ; final list < sqlrow > descs and me = new array list < sqlrow > ( ) ; try { this . for descendants do ( row , new child processor < sqlrow > ( ) { public void process ( sqlrow parent , sqlfield joint , sqlrow desc ) throws sqlexception { descs and me . add ( desc ) ; } } , true , true , archived ) ; } catch ( sqlexception e ) { e . print stack trace ( ) ; } if ( row . is archived ( ) = = archived ) descs and me . add ( row ) ; return descs and me ; } <s> private sqlrow values get tree ( sqlrow row , boolean archived ) { check ( row ) ; final sqlrow values res = row . as row values ( ) ; try { this . for descendants do ( res , new child processor < sqlrow values > ( ) { public void process ( sqlrow values parent , sqlfield joint , sqlrow values desc ) throws sqlexception { desc . put ( joint . get name ( ) , parent ) ; } } , true , false , archived ) ; } catch ( sqlexception e ) { e . print stack trace ( ) ; } return res ; }"}
{"source": "a data set with test entries <s> static list < object [ ] > prepare parameters ( final int binary operator result calc ) { final list < object [ ] > test data = new array list < > ( ) ; for ( int i = - num ; i < num ; i + + ) { for ( int j = - num ; j < num ; j + + ) { test data . add ( new object [ ] { new number expression ( i ) , new number expression ( j ) , result calc . apply as int ( i , j ) } ) ; } } return test data ; } <s> static stream < arguments > prepare parameters ( final int binary operator result calc ) { final list < arguments > test data = new array list < > ( ) ; for ( int i = - num ; i < num ; i + + ) { for ( int j = - num ; j < num ; j + + ) { test data . add ( arguments . of ( new number expression ( i ) , new number expression ( j ) , result calc . apply as int ( i , j ) ) ) ; } } return test data . stream ( ) ; }"}
{"source": "media list , should not be released . <s> public synchronized media list get media list ( ) { if ( m media list = = null & & ! is released ( ) ) m media list = new media list ( this ) ; return m media list ; } <s> public media list get media list ( ) { synchronized ( this ) { if ( m media list ! = null ) { m media list . retain ( ) ; return m media list ; } } final media list media list = new media list ( this ) ; synchronized ( this ) { m media list = media list ; m media list . retain ( ) ; return m media list ; } }"}
{"source": "the set of file ids which are currently on the queue will be normally be used when deciding which data files can be deleted <s> synchronized set < integer > get file ids ( ) { return new hash set < integer > ( file idcounts . key set ( ) ) ; } <s> synchronized sorted set < integer > get file ids ( ) { return new tree set < integer > ( file idcounts . key set ( ) ) ; }"}
{"source": "string with no directional formatting characters . <s> public static string deprocess ( string str ) { if ( ( str = = null ) | | ( str . length ( ) < = num ) | | ! is processing needed ( ) ) return str ; string buffer buf = new string buffer ( ) ; int str len = str . length ( ) ; for ( int i = num ; i < str len ; i + + ) { char c = str . char at ( i ) ; switch ( c ) { case lrm : continue ; case lre : continue ; case pdf : continue ; default : buf . append ( c ) ; } } return buf . to string ( ) ; } <s> public static string deprocess ( string str ) { if ( ( str = = null ) | | ( str . length ( ) < = num ) ) return str ; stext environment env = new stext environment ( null , false , stext environment . orient _ unknown ) ; if ( ! env . is processing needed ( ) ) return str ; string buffer buf = new string buffer ( ) ; int str len = str . length ( ) ; for ( int i = num ; i < str len ; i + + ) { char c = str . char at ( i ) ; switch ( c ) { case lrm : continue ; case lre : continue ; case pdf : continue ; default : buf . append ( c ) ; } } return buf . to string ( ) ; }"}
{"source": "boolean denoting if query has expired . <s> @ override public boolean is closed ( ) { return window . is closed ( ) ; } <s> @ override public boolean is closed ( ) { return mode = = mode . partition ? window . is closed for partition ( ) : window . is closed ( ) ; }"}
{"source": "ok status if deployment information is complete and valid . error if failed to validate , or is invalid ( i . e . it is missing information ) . <s> public synchronized istatus validate deployment info ( ) { abstract application delegate delegate = application registry . get application delegate ( get local module ( ) ) ; if ( delegate = = null ) { return cloud util . basic validate deployment info ( deployment info ) ; } istatus status = delegate . validate deployment info ( deployment info ) ; set status ( status ) ; return status ; } <s> public synchronized istatus validate deployment info ( ) { if ( deployment info = = null ) { string message = nls . bind ( messages . cloud foundry application module _ server _ out _ of _ sync , server . get id ( ) ) ; istatus status = cloud foundry plugin . get error status ( message ) ; set status ( status ) ; return status ; } else { abstract application delegate delegate = application registry . get application delegate ( get local module ( ) ) ; istatus status = delegate ! = null ? delegate . validate deployment info ( deployment info ) : cloud util . basic validate deployment info ( deployment info ) ; if ( status = = null ) { status = status . ok _ status ; } if ( ! status . is ok ( ) ) { status = cloud foundry plugin . get error status ( nls . bind ( messages . error _ app _ deployment _ validation _ error , get deployed application name ( ) , status . get message ( ) ) ) ; } set status ( status ) ; return status ; } }"}
{"source": "the player by the name of the raw arg - null if ( s ) he isn ' t online <s> public player as player ( ) { return bukkit . get player ( arg ) ; } <s> public player as player ( ) { return bukkit . get player ( raw ) ; }"}
{"source": "the reply , or null if no reply arrives before the timeout . <s> public message ping and wait for reply ( message message , long timeout ) throws jmsexception , interrupted exception { _ producer . send ( message ) ; string message id = message . get jmsmessage id ( ) ; commit tx ( ) ; boolean latch traffic light = new boolean latch ( ) ; traffic lights . put ( message id , traffic light ) ; traffic light . await ( timeout * num ) ; message result = replies . get ( message id ) ; return result ; } <s> public int ping and wait for reply ( message message , int num pings , long timeout ) throws jmsexception , interrupted exception { string message correlation id = long . to string ( id generator . increment and get ( ) ) ; message . set jmscorrelation id ( message correlation id ) ; for ( int i = num ; i < num pings ; i + + ) { message . set long property ( str , system . current time millis ( ) ) ; _ producer . send ( message ) ; } commit tx ( get producer session ( ) ) ; if ( _ verbose ) { _ logger . info ( timestamp formatter . format ( new date ( ) ) + str + message correlation id ) ; } count down latch traffic light = new count down latch ( num pings ) ; traffic lights . put ( message correlation id , traffic light ) ; traffic light . await ( timeout , time unit . milliseconds ) ; int num replies = num pings - ( int ) traffic light . get count ( ) ; if ( ( num replies < num pings ) & & _ verbose ) { _ logger . info ( str + message correlation id ) ; } else if ( _ verbose ) { _ logger . info ( str + message correlation id ) ; } return num replies ; }"}
{"source": "get method or null if none found . <s> public static method find get method ( field field , boolean throw exceptions ) { string method name = method from field ( field , str ) ; method field get method ; try { try { field get method = field . get declaring class ( ) . get method ( method name ) ; } catch ( no such method exception nsme ) { if ( field . get type ( ) = = boolean . class | | field . get type ( ) = = boolean . class ) { method name = method from field ( field , str ) ; field get method = field . get declaring class ( ) . get method ( method name ) ; } else { throw nsme ; } } } catch ( exception e ) { if ( throw exceptions ) { throw new illegal argument exception ( str + field ) ; } else { return null ; } } if ( field get method . get return type ( ) ! = field . get type ( ) ) { if ( throw exceptions ) { throw new illegal argument exception ( str + method name + str + field . get type ( ) ) ; } else { return null ; } } return field get method ; } <s> public static method find get method ( field field , boolean throw exceptions ) throws illegal argument exception { method field get method ; if ( locale . english . equals ( locale . get default ( ) ) ) { field get method = find method from names ( field , true , throw exceptions , method from field ( field , str , null ) , method from field ( field , str , null ) ) ; } else { field get method = find method from names ( field , true , throw exceptions , method from field ( field , str , null ) , method from field ( field , str , locale . english ) , method from field ( field , str , null ) , method from field ( field , str , locale . english ) ) ; } if ( field get method = = null ) { return null ; } if ( field get method . get return type ( ) ! = field . get type ( ) ) { if ( throw exceptions ) { throw new illegal argument exception ( str + field get method . get name ( ) + str + field . get type ( ) ) ; } else { return null ; } } return field get method ; }"}
{"source": "map with columns names as keys and their values <s> public map < string , string > populate implicit columns ( file work work , string selection root ) { return populate implicit columns ( work . get path ( ) , selection root ) ; } <s> public map < string , string > populate implicit columns ( string file path , list < string > partition values , boolean include file implicit columns ) { map < string , string > implicit values = new linked hash map < > ( ) ; for ( int i = num ; i < partition values . size ( ) ; i + + ) { if ( is star query | | selected partition columns . contains ( i ) ) { implicit values . put ( partition designator + i , partition values . get ( i ) ) ; } } if ( include file implicit columns ) { path path = path . get path without scheme and authority ( new path ( file path ) ) ; for ( map . entry < string , implicit file columns > entry : selected implicit columns . entry set ( ) ) { implicit values . put ( entry . get key ( ) , entry . get value ( ) . get value ( path ) ) ; } } return implicit values ; }"}
{"source": "the forge direction in which this conveyor belt is slanting against . the direction given is the high point of the slant . return unknown if not slanting . <s> public forge direction get slant ( world world , vector3 position ) { tile entity t = position . get tile entity ( world ) ; if ( t ! = null ) { if ( t instanceof tile entity conveyor belt ) { tile entity conveyor belt tile entity = ( tile entity conveyor belt ) t ; vector3 high check = position . clone ( ) ; high check . modify position from side ( tile entity . get direction ( ) ) ; } } return forge direction . unknown ; } <s> public static slant type get slant ( world world , vector3 position ) { tile entity t = position . get tile entity ( world ) ; if ( t ! = null ) { if ( t instanceof tile entity conveyor belt ) { tile entity conveyor belt tile entity = ( tile entity conveyor belt ) t ; vector3 front check = position . clone ( ) ; front check . modify position from side ( tile entity . get direction ( ) ) ; vector3 back check = position . clone ( ) ; back check . modify position from side ( tile entity . get direction ( ) . get opposite ( ) ) ; if ( vector3 . add ( front check , new vector3 ( num , num , num ) ) . get block id ( world ) = = assembly line . block conveyor belt . block id & & vector3 . add ( back check , new vector3 ( num , - num , num ) ) . get block id ( world ) = = assembly line . block conveyor belt . block id ) { return slant type . up ; } else if ( vector3 . add ( front check , new vector3 ( num , - num , num ) ) . get block id ( world ) = = assembly line . block conveyor belt . block id & & vector3 . add ( back check , new vector3 ( num , num , num ) ) . get block id ( world ) = = assembly line . block conveyor belt . block id ) { return slant type . down ; } } } return null ; }"}
{"source": "a hashtable representation of a workflow instance page . <s> public static hashtable get xml rpc workflow instance page ( workflow instance page page ) { hashtable page hash = new hashtable ( ) ; page hash . put ( str , string . value of ( page . get total pages ( ) ) ) ; page hash . put ( str , string . value of ( page . get page num ( ) ) ) ; page hash . put ( str , string . value of ( page . get page size ( ) ) ) ; page hash . put ( str , get xml rpc workflow instances ( page . get page workflows ( ) ) ) ; return page hash ; } <s> public static hash map get xml rpc workflow instance page ( workflow instance page page ) { hash map page hash = new hash map ( ) ; page hash . put ( str , string . value of ( page . get total pages ( ) ) ) ; page hash . put ( str , string . value of ( page . get page num ( ) ) ) ; page hash . put ( str , string . value of ( page . get page size ( ) ) ) ; page hash . put ( str , get xml rpc workflow instances ( page . get page workflows ( ) ) ) ; return page hash ; }"}
{"source": "this & & right <s> public boolean expression and ( @ nullable predicate right ) { right = ( predicate ) expression utils . extract ( right ) ; if ( right ! = null ) { return boolean operation . create ( ops . and , mixin , right ) ; } else { return this ; } } <s> public boolean expression and ( @ nullable predicate right ) { right = ( predicate ) expression utils . extract ( right ) ; if ( right ! = null ) { return expressions . boolean operation ( ops . and , mixin , right ) ; } else { return this ; } }"}
{"source": "the component key to adapter cache <s> protected map < object , component adapter < ? > > get component key to adapter cache ( ) { return component key to adapter cache ; } <s> protected map < object , component adapter < ? > > get component key to adapter cache ( ) { return key to adapter cache ; }"}
{"source": "a com . r0adkll . slidableactivity . slide lock interface that allows the user to lock / unlock the sliding mechanism for whatever purpose . <s> public static slide lock interface attach ( final activity activity ) { view group decor view = ( view group ) activity . get window ( ) . get decor view ( ) ; view old screen = decor view . get child at ( num ) ; decor view . remove view at ( num ) ; final slider panel panel = new slider panel ( activity , old screen ) ; panel . set id ( r . id . slidable _ panel ) ; panel . add view ( old screen ) ; decor view . add view ( panel , num ) ; panel . set on panel slide listener ( new slider panel . on panel slide listener ( ) { @ override public void on closed ( ) { activity . finish ( ) ; activity . override pending transition ( num , num ) ; } @ override public void on opened ( ) { } } ) ; slide lock interface lock interface = new slide lock interface ( ) { @ override public void lock ( ) { panel . lock ( ) ; } @ override public void unlock ( ) { panel . unlock ( ) ; } } ; return lock interface ; } <s> public static slidr interface attach ( final activity activity , final int status bar color1 , final int status bar color2 ) { view group decor view = ( view group ) activity . get window ( ) . get decor view ( ) ; view old screen = decor view . get child at ( num ) ; decor view . remove view at ( num ) ; final slider panel panel = new slider panel ( activity , old screen ) ; panel . set id ( r . id . slidable _ panel ) ; panel . add view ( old screen ) ; decor view . add view ( panel , num ) ; panel . set on panel slide listener ( new slider panel . on panel slide listener ( ) { private final argb evaluator m evaluator = new argb evaluator ( ) ; @ override public void on closed ( ) { activity . finish ( ) ; activity . override pending transition ( num , num ) ; } @ override public void on opened ( ) { } @ override public void on slide change ( float percent ) { if ( build . version . sdk _ int > = build . version _ codes . lollipop ) { int new color = ( int ) m evaluator . evaluate ( percent , status bar color1 , status bar color2 ) ; activity . get window ( ) . set status bar color ( new color ) ; } } } ) ; slidr interface slidr interface = new slidr interface ( ) { @ override public void lock ( ) { panel . lock ( ) ; } @ override public void unlock ( ) { panel . unlock ( ) ; } } ; return slidr interface ; }"}
{"source": "true if the extension is \" . gz \" , false otherwise <s> public static boolean is gzip file ( string file ) { return str . equals ( get extension ( file ) ) ; } <s> public static boolean is gzip file ( string file ) { string ext = get extension ( file ) ; return str . equals ( ext ) | | str . equals ( ext ) ; }"}
{"source": "the associated http servlet request <s> public http servlet request get request ( ) { return atmosphere request ; } <s> public atmosphere request get request ( ) { return atmosphere request ; }"}
{"source": "an array of vir vcpu info object describing the vcpus <s> public vir vcpu info [ ] get vcpus info ( ) throws libvirt exception { return _ get vcpus info ( vdp ) ; } <s> public vcpu info [ ] get vcpus info ( ) throws libvirt exception { return _ get vcpus info ( vdp ) ; }"}
{"source": "if an error occurs . <s> public static document factory create document factory ( service manager manager , session session ) { document factory map ; document manager doc manager = null ; try { doc manager = ( document manager ) manager . lookup ( document manager . role ) ; map = doc manager . create document identity map ( session ) ; } catch ( service exception e ) { throw new runtime exception ( e ) ; } finally { if ( doc manager ! = null ) { manager . release ( doc manager ) ; } } return map ; } <s> public static document factory create document factory ( service manager manager , session session ) { document factory factory ; document manager doc manager = null ; try { doc manager = ( document manager ) manager . lookup ( document manager . role ) ; factory = doc manager . create document identity map ( session ) ; } catch ( service exception e ) { throw new runtime exception ( e ) ; } finally { if ( doc manager ! = null ) { manager . release ( doc manager ) ; } } return factory ; }"}
{"source": "column name <s> public static string get column name ( string element type ) { if ( element type . equals ( elementtype _ organization ) ) return str ; else if ( element type . equals ( elementtype _ account ) ) return str ; else if ( element type . equals ( elementtype _ bpartner ) ) return str ; else if ( element type . equals ( elementtype _ product ) ) return str ; else if ( element type . equals ( elementtype _ activity ) ) return str ; else if ( element type . equals ( elementtype _ location from ) ) return str ; else if ( element type . equals ( elementtype _ location to ) ) return str ; else if ( element type . equals ( elementtype _ campaign ) ) return str ; else if ( element type . equals ( elementtype _ org trx ) ) return str ; else if ( element type . equals ( elementtype _ project ) ) return str ; else if ( element type . equals ( elementtype _ sales region ) ) return str ; else if ( element type . equals ( elementtype _ user list1 ) ) return str ; else if ( element type . equals ( elementtype _ user list2 ) ) return str ; else if ( element type . equals ( elementtype _ user element1 ) ) return str ; else if ( element type . equals ( elementtype _ user element2 ) ) return str ; return str ; } <s> public static string get column name ( string element type ) { if ( element type . equals ( elementtype _ organization ) ) return str ; else if ( element type . equals ( elementtype _ account ) ) return i _ c _ valid combination . columnname _ account _ id ; else if ( element type . equals ( elementtype _ bpartner ) ) return i _ c _ valid combination . columnname _ c _ bpartner _ id ; else if ( element type . equals ( elementtype _ product ) ) return i _ c _ valid combination . columnname _ m _ product _ id ; else if ( element type . equals ( elementtype _ activity ) ) return i _ c _ valid combination . columnname _ c _ activity _ id ; else if ( element type . equals ( elementtype _ location from ) ) return i _ c _ valid combination . columnname _ c _ loc from _ id ; else if ( element type . equals ( elementtype _ location to ) ) return i _ c _ valid combination . columnname _ c _ loc to _ id ; else if ( element type . equals ( elementtype _ campaign ) ) return i _ c _ valid combination . columnname _ c _ campaign _ id ; else if ( element type . equals ( elementtype _ org trx ) ) return i _ c _ valid combination . columnname _ ad _ org trx _ id ; else if ( element type . equals ( elementtype _ project ) ) return i _ c _ valid combination . columnname _ c _ project _ id ; else if ( element type . equals ( elementtype _ sales region ) ) return i _ c _ valid combination . columnname _ c _ sales region _ id ; else if ( element type . equals ( elementtype _ user list1 ) ) return i _ c _ valid combination . columnname _ user1 _ id ; else if ( element type . equals ( elementtype _ user list2 ) ) return i _ c _ valid combination . columnname _ user2 _ id ; else if ( element type . equals ( elementtype _ user element1 ) ) return i _ c _ valid combination . columnname _ user element1 _ id ; else if ( element type . equals ( elementtype _ user element2 ) ) return i _ c _ valid combination . columnname _ user element2 _ id ; return str ; }"}
{"source": "the maximum line length ( currently fixed at 512 ) <s> public int get max line length ( ) { return input thread . max _ line _ length ; } <s> public int get max line length ( ) { return max line length ; }"}
{"source": "new hssfworkbook generated by inserting beans into corresponding excel template <s> public hssfworkbook transform xls ( input stream is , map bean params ) throws parse property exception { hssfworkbook hssf workbook = null ; try { poifsfile system fs = new poifsfile system ( is ) ; hssf workbook = new hssfworkbook ( fs ) ; transform workbook ( hssf workbook , bean params ) ; } catch ( ioexception e ) { e . print stack trace ( ) ; } return hssf workbook ; } <s> public org . apache . poi . ss . usermodel . workbook transform xls ( input stream is , map bean params ) throws parse property exception , invalid format exception { org . apache . poi . ss . usermodel . workbook hssf workbook = null ; try { hssf workbook = workbook factory . create ( is ) ; transform workbook ( hssf workbook , bean params ) ; } catch ( ioexception e ) { e . print stack trace ( ) ; } return hssf workbook ; }"}
{"source": "# execute sql ( int , int , int ) <s> @ override public abstract object parser execute sql ( ) throws exception { return execute sql ( num , num , num ) ; } <s> @ override public abstract object parser execute sql ( ) throws exception { if ( is table = = false ) { sql reponse = new jsonobject ( sql request ) ; } else { try { sql reponse = on sqlexecute ( ) ; } catch ( exception e ) { log . e ( tag , str ) ; if ( e instanceof not exist exception ) { sql reponse = null ; } else { throw e ; } } if ( drop ) { sql reponse = null ; } } return this ; }"}
{"source": "the list of kdcs <s> public string get kdclist ( string realm ) { if ( realm = = null ) { realm = get default realm ( ) ; } string kdcs = get default ( str , realm ) ; if ( kdcs = = null ) { return null ; } return kdcs ; } <s> public string get kdclist ( string realm ) throws krb exception { if ( realm = = null ) { realm = get default realm ( ) ; } exception cause = null ; string kdcs = get default ( str , realm ) ; if ( kdcs = = null ) { kdcs = java . security . access controller . do privileged ( new java . security . privileged action < string > ( ) { @ override public string run ( ) { string osname = system . get property ( str ) ; if ( osname . starts with ( str ) ) { string logon server = system . getenv ( str ) ; if ( logon server ! = null & & logon server . starts with ( str ) ) { logon server = logon server . substring ( num ) ; } return logon server ; } return null ; } } ) ; } if ( kdcs = = null ) { krb exception ke = new krb exception ( str ) ; if ( cause ! = null ) { ke . init cause ( cause ) ; } throw ke ; } return kdcs ; }"}
{"source": "the time of the last record or null if there are no records <s> public date get end ( ) { if ( records . size ( ) = = num ) { return null ; } else { date last = records . get ( num ) . get date ( ) ; for ( entry e : records ) { if ( e . get date ( ) . after ( last ) ) { last = e . get date ( ) ; } } return last ; } } <s> public date get end ( ) { if ( records . size ( ) = = num ) { return new date ( ) ; } else { date last = records . get ( num ) . get date ( ) ; for ( entry e : records ) { if ( e . get date ( ) . after ( last ) ) { last = e . get date ( ) ; } } return last ; } }"}
{"source": "the factory that creates entity managers configured according to the specified persistence unit . <s> public static entity manager factory create entity manager factory ( string persistence unit name , map properties ) { entity manager factory factory = null ; if ( properties = = null ) { properties = collections . empty _ map ; } object provider name = properties . get ( persistence _ provider _ property ) ; if ( provider name instanceof string ) { factory = create factory ( provider name . to string ( ) , persistence unit name , properties ) ; } if ( factory = = null ) { persistence provider resolver resolver = persistence provider resolver holder . get persistence provider resolver ( ) ; list < persistence provider > providers = resolver . get persistence providers ( ) ; for ( persistence provider provider : providers ) { try { factory = provider . create entity manager factory ( persistence unit name , properties ) ; } catch ( exception e ) { throw new persistence exception ( str + provider name , e ) ; } if ( factory ! = null ) { break ; } } } return factory ; } <s> public static entity manager factory create entity manager factory ( string persistence unit name , map properties ) { entity manager factory factory = null ; map props = properties ; if ( props = = null ) { props = collections . empty _ map ; } persistence provider resolver resolver = persistence provider resolver holder . get persistence provider resolver ( ) ; list < persistence provider > providers = resolver . get persistence providers ( ) ; object provider name = props . get ( persistence _ provider _ property ) ; if ( ( provider name ! = null ) & & ( provider name instanceof string ) ) { boolean is loaded = false ; for ( persistence provider provider : providers ) { if ( provider . get class ( ) . get name ( ) . compare to ( provider name . to string ( ) ) = = num ) { is loaded = true ; break ; } } if ( ! is loaded ) { factory = create factory ( provider name . to string ( ) , persistence unit name , props ) ; if ( factory ! = null ) { return factory ; } } } if ( providers . size ( ) = = num ) { return providers . get ( num ) . create entity manager factory ( persistence unit name , props ) ; } else { for ( persistence provider provider : providers ) { try { factory = provider . create entity manager factory ( persistence unit name , props ) ; } catch ( exception e ) { } if ( factory ! = null ) { return factory ; } } } throw new persistence exception ( str + persistence unit name ) ; }"}
{"source": "a list with instances of org . mule . module . google . drive . model . comment <s> @ processor @ oauth protected @ oauth invalidate access token on ( exception = oauth token expired exception . class ) @ inject public list < comment > list comments ( mule message message , string file id , @ optional @ default ( str ) boolean include deleted , @ optional @ default ( str ) int max results , @ optional @ default ( str ) string page token , @ optional string updated min ) throws ioexception { comment list response = this . client . comments ( ) . list ( file id ) . set include deleted ( include deleted ) . set max results ( max results ) . set page token ( page token ) . set updated min ( updated min ) . execute ( ) ; pagination utils . save page token ( next _ page _ token , response . get next page token ( ) , message ) ; return comment . value of ( response . get items ( ) , comment . class ) ; } <s> @ processor @ oauth protected @ oauth invalidate access token on ( exception = oauth token expired exception . class ) @ paged public paging delegate < comment > list comments ( final string file id , @ optional @ default ( str ) final boolean include deleted , @ optional @ default ( str ) final int max results , @ optional final string updated min , final paging configuration paging configuration ) throws ioexception { return new token based paging delegate < comment > ( ) { @ override protected list < comment > do get page ( ) throws ioexception { comment list response = client . comments ( ) . list ( file id ) . set include deleted ( include deleted ) . set max results ( max results ) . set page token ( this . get page token ( ) ) . set updated min ( updated min ) . execute ( ) ; this . set page token ( response . get next page token ( ) ) ; return comment . value of ( response . get items ( ) , comment . class ) ; } } ; }"}
{"source": "ok , 404 <s> public java . util . list parse page ( string url string ) { string status = str ; try { url current url = new java . net . url ( url string ) ; string current urlpath = url string . substring ( num , url string . last index of ( str ) ) ; http urlconnection http con = ( http urlconnection ) current url . open connection ( ) ; http con . set request property ( str , str ) ; http con . connect ( ) ; long last modified = http con . get last modified ( ) ; if ( http con . get response code ( ) = = http urlconnection . http _ ok ) { string content type = http con . get content type ( ) ; if ( content type . index of ( str ) ! = - num ) { return handle html ( http con ) ; } else if ( content type . index of ( str ) ! = - num ) { handle pdf ( http con ) ; } else { status = str + content type ; } } else { status = str ; } http con . disconnect ( ) ; } catch ( java . net . malformed urlexception mue ) { status = mue . to string ( ) ; } catch ( java . net . unknown host exception uh ) { status = uh . to string ( ) ; } catch ( java . io . ioexception ioe ) { status = ioe . to string ( ) ; } catch ( exception e ) { status = e . to string ( ) ; } return null ; } <s> public list parse page ( string url string ) { string status = str ; try { url current url = new java . net . url ( url string ) ; http urlconnection http con = ( http urlconnection ) current url . open connection ( ) ; http con . set request property ( str , str ) ; http con . connect ( ) ; if ( http con . get response code ( ) = = http urlconnection . http _ ok ) { string content type = http con . get content type ( ) ; if ( content type . index of ( str ) ! = - num ) { return handle html ( http con ) ; } else if ( content type . index of ( str ) ! = - num ) { handle pdf ( http con ) ; } else { status = str + content type ; } } else { status = str ; } http con . disconnect ( ) ; } catch ( java . net . malformed urlexception mue ) { status = mue . to string ( ) ; } catch ( java . net . unknown host exception uh ) { status = uh . to string ( ) ; } catch ( java . io . ioexception ioe ) { status = ioe . to string ( ) ; } catch ( exception e ) { status = e . to string ( ) ; } return null ; }"}
{"source": "cube request cube change request <s> @ request mapping ( value = str , method = { request method . put } ) @ response body public cube request update cube desc ( @ request body cube request cube request ) throws json processing exception { cube desc desc = deserialize cube desc ( cube request ) ; if ( desc = = null ) { return cube request ; } final string cube name = cube request . get cube name ( ) ; if ( string utils . is empty ( cube name ) ) { return error request ( cube request , str ) ; } metadata manager metadata manager = metadata manager . get instance ( cube service . get config ( ) ) ; data model desc model desc = null ; data model desc old model desc = null ; if ( string utils . is not empty ( cube request . get model desc data ( ) ) ) { model desc = deserialize data model desc ( cube request ) ; if ( model desc = = null ) { return cube request ; } final string mode name = model desc . get name ( ) ; if ( ! string utils . equals ( desc . get model name ( ) , mode name ) ) { return error request ( cube request , str + desc . get model name ( ) + str + mode name ) ; } old model desc = metadata manager . get data model desc ( mode name ) ; if ( old model desc = = null ) { return error request ( cube request , str + mode name + str ) ; } } if ( ! cube service . is cube desc editable ( desc ) ) { string error = str + desc . get name ( ) . to upper case ( ) + str ; return error request ( cube request , error ) ; } boolean update model success = false , update cube success = false ; try { if ( model desc ! = null ) { metadata manager . update data model desc ( model desc ) ; update model success = true ; } cube instance cube = cube service . get cube manager ( ) . get cube ( cube name ) ; string project name = ( null = = cube request . get project ( ) ) ? project instance . default _ project _ name : cube request . get project ( ) ; desc = cube service . update cube and desc ( cube , desc , project name ) ; project manager project manager = cube service . get project manager ( ) ; if ( ! cube service . is cube in project ( project name , cube ) ) { string owner = <s> @ request mapping ( value = str , method = { request method . put } ) @ response body public cube request update cube desc ( @ request body cube request cube request ) throws json processing exception { cube desc desc = deserialize cube desc ( cube request ) ; cube desc old cube desc = null ; if ( desc = = null ) { return cube request ; } if ( ! cube service . is cube desc editable ( desc ) ) { string error = str + desc . get name ( ) ; update request ( cube request , false , error ) ; return cube request ; } if ( ! cube request . get cube name ( ) . equals ignore case ( cube service . get cube name from desc ( desc . get name ( ) ) ) ) { delete cube ( cube request . get cube name ( ) ) ; save cube desc ( cube request ) ; } string project name = ( null = = cube request . get project ( ) ) ? project instance . default _ project _ name : cube request . get project ( ) ; try { cube instance cube = cube service . get cube manager ( ) . get cube ( cube request . get cube name ( ) ) ; old cube desc = cube . get descriptor ( ) ; desc = cube service . update cube and desc ( cube , desc , project name ) ; } catch ( access denied exception access denied exception ) { throw new forbidden exception ( str ) ; } catch ( exception e ) { logger . error ( str + e . get localized message ( ) , e ) ; throw new internal error exception ( str + e . get localized message ( ) ) ; } if ( ! desc . get error ( ) . is empty ( ) ) { logger . warn ( str + desc . get name ( ) + str + desc . get error ( ) ) ; update request ( cube request , false , omit message ( desc . get error ( ) ) ) ; return cube request ; } string desc data = json util . write value as indent string ( desc ) ; cube request . set cube desc data ( desc data ) ; cube request . set successful ( true ) ; return cube request ; }"}
{"source": "list of all selected objects . <s> public collection < osm primitive > get selected ( ) { return new array list < osm primitive > ( selected primitives ) ; } <s> public collection < osm primitive > get selected ( ) { return collections . unmodifiable set ( selected primitives ) ; }"}
{"source": "the year when this device would have been considered top - of - the - line . <s> private static int categorize by year ( context c ) { array list < integer > component years = new array list < integer > ( ) ; conditionally add ( component years , get num cores year ( ) ) ; conditionally add ( component years , get clock speed year ( ) ) ; conditionally add ( component years , get ram year ( c ) ) ; if ( component years . is empty ( ) ) return class _ unknown ; collections . sort ( component years ) ; if ( ( component years . size ( ) & num ) = = num ) { return component years . get ( component years . size ( ) / num ) ; } else { int base index = component years . size ( ) / num - num ; return component years . get ( base index ) + ( component years . get ( base index + num ) - component years . get ( base index ) ) / num ; } } <s> private static year class categorize by year ( context c ) { array list < year class > component years = new array list < year class > ( ) ; conditionally add ( component years , year class . from number of cores ( ) ) ; conditionally add ( component years , year class . from clock speed ( ) ) ; conditionally add ( component years , year class . from ram total ( c ) ) ; if ( component years . is empty ( ) ) return year class . class _ unknown ; collections . sort ( component years ) ; if ( ( component years . size ( ) & num ) = = num ) { return component years . get ( component years . size ( ) / num ) ; } else { int base index = component years . size ( ) / num - num ; int average rounded down = component years . get ( base index ) . m int value + ( component years . get ( base index + num ) . m int value - component years . get ( base index ) . m int value ) / num ; return year class . from int value ( average rounded down ) ; } }"}
{"source": "the time of the first record or null if there are no records <s> public date get start ( ) { if ( records . size ( ) = = num ) { return null ; } else { date first = records . get ( num ) . get date ( ) ; for ( entry e : records ) { if ( e . get date ( ) . before ( first ) ) { first = e . get date ( ) ; } } return first ; } } <s> public date get start ( ) { if ( records . size ( ) = = num ) { return new date ( ) ; } else { date first = records . get ( num ) . get date ( ) ; for ( entry e : records ) { if ( e . get date ( ) . before ( first ) ) { first = e . get date ( ) ; } } return first ; } }"}
{"source": "the scmsource criteria . probe or null if this source cannot be probed . <s> @ check for null protected scmprobe create probe ( @ non null final scmhead head , @ check for null final scmrevision revision ) throws ioexception { return null ; } <s> @ non null protected scmprobe create probe ( @ non null final scmhead head , @ check for null final scmrevision revision ) throws ioexception { throw new abstract method error ( ) ; }"}
{"source": "array of configuration elements or null if this container has no contributions . <s> public synchronized iconfiguration element [ ] get container configurations ( string containerid ) { if ( container to contributions = = null ) process proxy contribution extension point ( ) ; return ( iconfiguration element [ ] ) container to contributions . get ( containerid ) ; } <s> public synchronized iconfiguration element [ ] get container configurations ( string containerid , string [ ] container paths ) { if ( contributions = = null ) process proxy contribution extension point ( ) ; return ( iconfiguration element [ ] ) contributions . container path contributions . get contributors ( containerid , container paths ) ; }"}
{"source": "uri with properties on <s> public static string add properties to uri ( uri uri , map < string , string > props ) throws exception { return add properties to uri ( uri . to string ( ) , props ) ; } <s> public static string add properties to uri ( uri uri , map < string , string > properties ) throws exception { return add properties to uri ( uri . to string ( ) , properties ) ; }"}
{"source": "true if there is some ( valid ) value available for this option . <s> public boolean has value ( option < ? > option ) { return try get option ( option ) ! = null ; } <s> public boolean has value ( option < ? > option ) { string val = config . get value ( get config key ( option ) ) ; return val ! = null | | option . get default value ( ) ! = null ; }"}
{"source": "double the pitch euler angle . <s> public double get rot z ( ) { return m orientation . get rotation z ( ) ; } <s> public double get rot z ( ) { return math . to degrees ( m orientation . get rotation z ( ) ) ; }"}
{"source": "subject or null if there is no subject <s> public string get subject ( ) { subject header subject = ( subject header ) get stack message ( ) . get header ( subject header . name ) ; if ( subject ! = null ) { return subject . get subject ( ) ; } else { return null ; } } <s> public string get subject ( ) { subject header subject = ( subject header ) get stack message ( ) . get header ( subject header . name ) ; if ( subject ! = null ) { return subject . get subject ( ) ; } else { return str ; } }"}
{"source": "apiresule - succeeded or failed <s> public apiresult validate ( http servlet request request , string type , boolean skip dry run ) { try { entity type entity type = entity type . get enum ( type ) ; entity entity = deserialize entity ( request , entity type ) ; validate ( entity ) ; if ( entity . get entity type ( ) . is schedulable ( ) ) { set < string > clusters = entity util . get clusters defined in colos ( entity ) ; for ( string cluster : clusters ) { try { get workflow engine ( ) . dry run ( entity , cluster , skip dry run ) ; } catch ( falcon exception e ) { throw new falcon exception ( str + cluster , e ) ; } } } return new apiresult ( apiresult . status . succeeded , str + entity type + str + entity . get name ( ) ) ; } catch ( throwable e ) { log . error ( str , type , e ) ; throw falcon web exception . new exception ( e , response . status . bad _ request ) ; } } <s> public apiresult validate ( http servlet request request , string type , boolean skip dry run ) { try { return validate ( request . get input stream ( ) , type , skip dry run ) ; } catch ( ioexception e ) { log . error ( str , request , e ) ; throw falcon web exception . new exception ( e , response . status . bad _ request ) ; } }"}
{"source": "true if the clazz ( or one of its superclasses ) implements the given method . returns false if the method doesn ' t exist anywhere in the class hierarchy or it is abstract . <s> static boolean implements method ( type element clazz , method spec method , types type utils ) { executable element method on class = get method on class ( clazz , method , type utils ) ; if ( method on class = = null ) { return false ; } set < modifier > modifiers = method on class . get modifiers ( ) ; return ! modifiers . contains ( modifier . abstract ) ; } <s> static boolean implements method ( type element clazz , method spec method , types type utils ) { executable element method on class = get method on class ( clazz , method , type utils ) ; if ( method on class = = null ) { return false ; } element implementing class = method on class . get enclosing element ( ) ; if ( implementing class . get simple name ( ) . to string ( ) . equals ( str ) ) { return false ; } set < modifier > modifiers = method on class . get modifiers ( ) ; return ! modifiers . contains ( modifier . abstract ) ; }"}
{"source": "boolean returns a boolean to indicate whether the operation was successful . <s> public boolean add ( string tag id , string category ) { return is category valid ( category ) & & m selected topics . add ( tag id ) ; } <s> public boolean add ( tag tag ) { return is category valid ( tag . get category ( ) ) & & m selected topics . add ( tag ) ; }"}
{"source": "the last element in this list <s> public list < user > get friends ( long id , int from , int to , friends types type ) throws ioexception , jsonexception { list < user > friends = new linked list < user > ( ) ; url url = new url ( str + type . name ( ) + str + from + str + to + str + id + str + sid ) ; string json text = get text from url ( url ) ; jsonarray fr ; if ( type = = friends types . friends ) { fr = new jsonarray ( json text ) ; } else { fr = new jsonobject ( json text ) . get jsonarray ( str ) ; } for ( int i = num ; i < fr . length ( ) ; i + + ) { jsonarray user info = ( jsonarray ) fr . get ( i ) ; friends . add ( new user ( user info , this ) ) ; } return friends ; } <s> public list with total < user > get friends ( long id , int from , int to , friends types type ) throws ioexception , jsonexception { list < user > friends = new linked list < user > ( ) ; url url = new url ( str + type . name ( ) + str + from + str + to + str + id + str + sid ) ; string json text = get text from url ( url ) ; system . out . println ( json text ) ; jsonarray fr ; long count = - num ; if ( type = = friends types . friends _ new ) { jsonobject object = new jsonobject ( json text ) ; count = object . get long ( str ) ; fr = object . get jsonarray ( str ) ; } else { fr = new jsonarray ( json text ) ; } for ( int i = num ; i < fr . length ( ) ; i + + ) { jsonarray user info = ( jsonarray ) fr . get ( i ) ; friends . add ( new user ( user info , this ) ) ; } return new list with total < user > ( friends , count ) ; }"}
{"source": "the action of the previous build , or null if no such build exists <s> public build result get previous result ( ) { return get previous action ( ) . get result ( ) ; } <s> public build result get previous result ( ) { result action < ? extends build result > action = get previous action ( ) ; if ( action ! = null ) { return action . get result ( ) ; } throw new no such element exception ( str ) ; }"}
{"source": "if the device is local or not . <s> public static boolean is resolvable device ( url device url device ) { try { url device . get extra string ( title _ key ) ; } catch ( jsonexception e ) { return false ; } return true ; } <s> public static boolean is resolvable device ( url device url device ) { string type = url device . opt extra string ( type _ key , str ) ; return type . equals ( ble _ device _ type ) | | type . equals ( ssdp _ device _ type ) | | type . equals ( mdns _ public _ device _ type ) ; }"}
{"source": "a data store which contains the grant information . <s> public data store get table grants ( table identifier table ) { string [ ] columns = new string [ ] { str , str , str , str , str } ; int [ ] col types = new int [ ] { types . varchar , types . varchar , types . varchar , types . varchar , types . varchar } ; data store result = new data store ( columns , col types ) ; result set rs = null ; try { table identifier tbl = table . create copy ( ) ; tbl . adjust case ( this . db connection ) ; rs = this . meta data . get table privileges ( tbl . get catalog ( ) , tbl . get schema ( ) , tbl . get table name ( ) ) ; while ( rs . next ( ) ) { int row = result . add row ( ) ; result . set value ( row , column _ idx _ table _ grants _ object _ name , rs . get string ( num ) ) ; result . set value ( row , column _ idx _ table _ grants _ grantor , rs . get string ( num ) ) ; result . set value ( row , column _ idx _ table _ grants _ grantee , rs . get string ( num ) ) ; result . set value ( row , column _ idx _ table _ grants _ priv , rs . get string ( num ) ) ; result . set value ( row , column _ idx _ table _ grants _ grantable , rs . get string ( num ) ) ; } } catch ( exception e ) { log mgr . log error ( str , str , e ) ; result . reset ( ) ; } finally { try { rs . close ( ) ; } catch ( throwable th ) { } } return result ; } <s> public collection < table grant > get table grants ( table identifier table ) { collection < table grant > result = new hash set < table grant > ( ) ; result set rs = null ; try { table identifier tbl = table . create copy ( ) ; tbl . adjust case ( this . db connection ) ; rs = this . meta data . get table privileges ( tbl . get catalog ( ) , tbl . get schema ( ) , tbl . get table name ( ) ) ; while ( rs . next ( ) ) { string from = rs . get string ( num ) ; string to = rs . get string ( num ) ; string what = rs . get string ( num ) ; boolean grantable = string util . string to bool ( rs . get string ( num ) ) ; table grant grant = new table grant ( to , what , grantable ) ; result . add ( grant ) ; } } catch ( exception e ) { log mgr . log error ( str , str , e ) ; } finally { try { rs . close ( ) ; } catch ( throwable th ) { } } return result ; }"}
{"source": "the multi join rel corresponding to this multijoin <s> public multi join rel get multi join rel ( ) { return multi join ; } <s> public multi join get multi join rel ( ) { return multi join ; }"}
{"source": "whether this chat section ' s argument can be parsed as a boolean <s> public boolean is boolean ( ) { return arg . equals ( str ) | | arg . equals ( str ) ; } <s> public boolean is boolean ( ) { return raw . equals ( str ) | | raw . equals ( str ) ; }"}
{"source": "true if the annotated type mirror contains the unknown val or array len annotation mirror , false otherwise <s> private boolean non value anno ( annotated type mirror mirror ) { return annotation utils . are same ignoring values ( get value annotation ( mirror ) , unknownval ) | | annotation utils . are same ignoring values ( mirror . get annotation in hierarchy ( arraylen ) , arraylen ) ; } <s> private boolean non value anno ( annotated type mirror mirror ) { annotation mirror value anno = get value annotation ( mirror ) ; return annotation utils . are same ignoring values ( value anno , unknownval ) | | annotation utils . are same by class ( value anno , bottom val . class ) | | annotation utils . are same ignoring values ( mirror . get annotation in hierarchy ( arraylen ) , arraylen ) ; }"}
{"source": "a jsonarray which is the value . <s> public jsonarray get jsonarray ( string key ) { object object = this . get ( key ) ; if ( object instanceof jsonarray ) { return ( jsonarray ) object ; } throw new runtime exception ( str + quote ( key ) + str ) ; } <s> public jsonarray get jsonarray ( string key ) { object object = this . get ( key ) ; if ( object = = null ) { return null ; } if ( object instanceof jsonarray ) { return ( jsonarray ) object ; } throw new runtime exception ( str + quote ( key ) + str ) ; }"}
{"source": "the balance <s> public double get balance ( ) { return balance ; } <s> public double get balance ( world world ) { if ( ! config . multi world ) return get balance ( currency handler . get currency ( config . currency default , true ) ) ; return get balance ( currency handler . get currency ( config . currency default , true ) , world ) ; }"}
{"source": "the rule set <s> public rule set get rule set ( ) { return this . rule set ; } <s> public package get rule set ( ) { return this . pkg ; }"}
{"source": "true for visible , false for invisible <s> public static boolean is visible in explain ( rel node rel , sql explain level explain level ) { boolean b = ( boolean ) rel . get cluster ( ) . get metadata provider ( ) . get rel metadata ( rel , str , new object [ ] { explain level } ) ; if ( b = = null ) { return true ; } else { return b ; } } <s> public static boolean is visible in explain ( rel node rel , sql explain level explain level ) { final built in metadata . explain visibility metadata = rel . metadata ( built in metadata . explain visibility . class ) ; boolean b = metadata . is visible in explain ( explain level ) ; return b = = null | | b ; }"}
{"source": "the component meta data <s> protected component meta data get meta data ( final object entry ) { return ( component meta data ) entry ; } <s> protected component template get meta data ( final object entry ) { return ( component template ) entry ; }"}
{"source": "index name and index stats <s> public map < string , index stats > get all graylog deflector indices ( ) { final immutable map . builder < string , index stats > result = immutable map . builder ( ) ; for ( map . entry < string , index stats > e : indices . get all ( ) . entry set ( ) ) { final string name = e . get key ( ) ; if ( is graylog deflector index ( name ) ) { result . put ( name , e . get value ( ) ) ; } } return result . build ( ) ; } <s> public map < string , set < string > > get all graylog deflector indices ( ) { final map < string , set < string > > index names and aliases = indices . get index names and aliases ( get deflector wildcard ( ) ) ; return index names and aliases . entry set ( ) . stream ( ) . filter ( e - > is graylog deflector index ( e . get key ( ) ) ) . collect ( collectors . to map ( map . entry : : get key , map . entry : : get value ) ) ; }"}
{"source": "the currently selected day , or null if no selection <s> public calendar day get selected date ( ) { return adapter . get selected date ( ) ; } <s> public calendar day get selected date ( ) { list < calendar day > dates = adapter . get selected dates ( ) ; if ( dates . is empty ( ) ) { return null ; } else { return dates . get ( dates . size ( ) - num ) ; } }"}
{"source": "the annotation type string , or null if the supplied destination is null or can ' t be classified <s> private string to type annotation ( jms destination destination ) { if ( destination = = null ) { return null ; } if ( destination . is queue ( ) ) { if ( destination . is temporary ( ) ) { return temp _ queue _ attributes _ string ; } else { return queue _ attributes _ string ; } } else if ( destination . is topic ( ) ) { if ( destination . is temporary ( ) ) { return temp _ topic _ attributes _ string ; } else { return topic _ attributes _ string ; } } return null ; } <s> private object to type annotation ( jms destination destination , boolean use byte value ) { if ( destination = = null ) { return null ; } if ( use byte value ) { if ( destination . is queue ( ) ) { if ( destination . is temporary ( ) ) { return temp _ queue _ type ; } else { return queue _ type ; } } else if ( destination . is topic ( ) ) { if ( destination . is temporary ( ) ) { return temp _ topic _ type ; } else { return topic _ type ; } } } else { if ( destination . is queue ( ) ) { if ( destination . is temporary ( ) ) { return temp _ queue _ attributes _ string ; } else { return queue _ attributes _ string ; } } else if ( destination . is topic ( ) ) { if ( destination . is temporary ( ) ) { return temp _ topic _ attributes _ string ; } else { return topic _ attributes _ string ; } } } return null ; }"}
{"source": "the current draw queue object for this scene <s> public draw queue get draw queue ( ) { return draw queue ; } <s> public int get draw queue ( ) { return draw queue type ; }"}
{"source": "built ct . timestamped entry . <s> public static ct . timestamped entry parse timestamped entry ( input stream in ) { ct . timestamped entry . builder timestamped entry = ct . timestamped entry . new builder ( ) ; long timestamp = read number ( in , ctconstants . timestamp _ length ) ; timestamped entry . set timestamp ( timestamp ) ; int entry type = ( int ) read number ( in , ctconstants . log _ entry _ type _ length ) ; timestamped entry . set entry type ( ct . log entry type . value of ( entry type ) ) ; ct . signed entry . builder signed entry builder = ct . signed entry . new builder ( ) ; if ( entry type = = ct . log entry type . x509 _ entry _ value ) { int length = ( int ) read number ( in , num ) ; byte string x509 = byte string . copy from ( read fixed length ( in , length ) ) ; signed entry builder . set x509 ( x509 ) ; } else if ( entry type = = ct . log entry type . precert _ entry _ value ) { ct . pre cert . builder pre cert builder = ct . pre cert . new builder ( ) ; byte [ ] arr = read fixed length ( in , num ) ; pre cert builder . set issuer key hash ( byte string . copy from ( arr ) ) ; arr = read fixed length ( in , num ) ; int length = ( int ) read number ( in , num ) ; pre cert builder . set tbs certificate ( byte string . copy from ( read fixed length ( in , length ) ) ) ; pre cert builder . build ( ) ; signed entry builder . set precert ( pre cert builder ) ; } else { throw new serialization exception ( string . format ( str , entry type ) ) ; } signed entry builder . build ( ) ; timestamped entry . set signed entry ( signed entry builder ) ; return timestamped entry . build ( ) ; } <s> public static timestamped entry parse timestamped entry ( input stream in ) { timestamped entry timestamped entry = new timestamped entry ( ) ; timestamped entry . timestamp = read number ( in , ctconstants . timestamp _ length ) ; int entry type = ( int ) read number ( in , ctconstants . log _ entry _ type _ length ) ; timestamped entry . entry type = ct . log entry type . value of ( entry type ) ; ct . signed entry . builder signed entry builder = ct . signed entry . new builder ( ) ; if ( entry type = = ct . log entry type . x509 _ entry _ value ) { int length = ( int ) read number ( in , num ) ; byte string x509 = byte string . copy from ( read fixed length ( in , length ) ) ; signed entry builder . set x509 ( x509 ) ; } else if ( entry type = = ct . log entry type . precert _ entry _ value ) { ct . pre cert . builder pre cert builder = ct . pre cert . new builder ( ) ; byte [ ] arr = read fixed length ( in , num ) ; pre cert builder . set issuer key hash ( byte string . copy from ( arr ) ) ; arr = read fixed length ( in , num ) ; int length = ( int ) read number ( in , num ) ; pre cert builder . set tbs certificate ( byte string . copy from ( read fixed length ( in , length ) ) ) ; pre cert builder . build ( ) ; signed entry builder . set precert ( pre cert builder ) ; } else { throw new serialization exception ( string . format ( str , entry type ) ) ; } timestamped entry . signed entry = signed entry builder . build ( ) ; return timestamped entry ; }"}
{"source": "the decoded value type or # x if the char does not map to a value type <s> public static value type decode ( final string value ) { if ( value = = null | | value . trim ( ) . is empty ( ) ) throw new illegal argument exception ( str ) ; final value type v = decode by int . get ( value . trim ( ) . char at ( num ) ) ; return v = = null ? x : v ; } <s> public static value type decode ( final string value ) { if ( value = = null | | value . trim ( ) . is empty ( ) ) throw new illegal argument exception ( str ) ; final value type v = decode by int . get ( value . trim ( ) . char at ( num ) ) ; return v = = null ? directed : v ; }"}
{"source": "a hashtable with keys string ( values . to string ( ) ) and with values version apk <s> public hashtable < string , version apk > get versions ( ) { hashtable < string , version apk > versions = new hashtable < string , version apk > ( ) ; try { node list nl = dom . get elements by tag name ( str ) ; if ( nl ! = null & & nl . get length ( ) > num ) { for ( int i = num ; i < nl . get length ( ) ; i + + ) { string version = get version tag text ( i , str , nl ) ; versions . put ( version , new version apk ( version , get version tag text ( i , str , nl ) , get version tag text ( i , str , nl ) ) ) ; } } } catch ( malformed urlexception e ) { e . print stack trace ( ) ; } return versions ; } <s> public array list < version apk > get versions ( ) { array list < version apk > versions = new array list < version apk > ( ) ; try { node list nl = dom . get elements by tag name ( str ) ; if ( nl ! = null & & nl . get length ( ) > num ) { for ( int i = num ; i < nl . get length ( ) ; i + + ) { versions . add ( new version apk ( get version tag text ( i , str , nl ) , get version tag text ( i , str , nl ) , get version tag text ( i , str , nl ) ) ) ; } } } catch ( malformed urlexception e ) { e . print stack trace ( ) ; } return versions ; }"}
{"source": "array of component type codes <s> public static int [ ] get all supported component types ( ) { return supported _ component _ types ; } <s> public static set < string > get all supported component types ( ) { return supported _ component _ types ; }"}
{"source": "the encoding used to send outgoing messages , or null if not set . <s> public string get encoding ( ) { return _ charset ; } <s> public charset get encoding ( ) { return _ charset ; }"}
{"source": "true if the method has a jsecurity roles required or permissions required annotation , false otherwise . <s> public boolean matches ( method method , class target class ) { return ( ( method . get annotation ( permissions required . class ) ! = null ) | | ( method . get annotation ( roles required . class ) ! = null ) ) ; } <s> public boolean matches ( method method , class target class ) { return ( ( method . get annotation ( requires permissions . class ) ! = null ) | | ( method . get annotation ( requires roles . class ) ! = null ) ) ; }"}
{"source": "abstract custom builder node ( this ) to allow for method chaining . <s> protected abstract custom builder node add attribute ( final string name ) { supported attributes . add ( name ) ; return this ; } <s> protected abstract builder node add attribute ( final string name ) { supported attributes . add ( name ) ; return this ; }"}
{"source": "a list with instance of org . mule . module . google . drive . model . change <s> @ processor @ oauth protected @ oauth invalidate access token on ( exception = oauth token expired exception . class ) @ inject public list < change > list changes ( mule message message , @ optional @ default ( str ) boolean include deleted , @ optional @ default ( str ) boolean include subscribed , @ optional @ default ( str ) int max results , @ optional @ default ( str ) string page token , @ optional long start change id ) throws ioexception { change list response = this . client . changes ( ) . list ( ) . set include deleted ( include deleted ) . set include subscribed ( include subscribed ) . set max results ( max results ) . set page token ( page token ) . set start change id ( start change id ) . execute ( ) ; pagination utils . save page token ( next _ page _ token , response . get next page token ( ) , message ) ; return change . value of ( response . get items ( ) , change . class ) ; } <s> @ processor @ oauth protected @ oauth invalidate access token on ( exception = oauth token expired exception . class ) @ paged public paging delegate < change > list changes ( @ optional @ default ( str ) final boolean include deleted , @ optional @ default ( str ) final boolean include subscribed , @ optional @ default ( str ) final int max results , @ optional final long start change id , final paging configuration paging configuration ) throws ioexception { return new token based paging delegate < change > ( ) { @ override protected list < change > do get page ( ) throws ioexception { change list response = client . changes ( ) . list ( ) . set include deleted ( include deleted ) . set include subscribed ( include subscribed ) . set max results ( max results ) . set page token ( this . get page token ( ) ) . set start change id ( start change id ) . execute ( ) ; this . set page token ( response . get next page token ( ) ) ; return change . value of ( response . get items ( ) , change . class ) ; } } ; }"}
{"source": "the currently attached trash fragment . <s> public trash fragment get trash fragment ( ) { return m trash fragment ; } <s> public flyout fragment get trash fragment ( ) { return m trash fragment ; }"}
{"source": "double the roll euler angle . <s> public double get rot x ( ) { return m orientation . get rotation x ( ) ; } <s> public double get rot x ( ) { return math . to degrees ( m orientation . get rotation x ( ) ) ; }"}
{"source": "opaque string handle for this terminal instance , or null if terminal has never been attached to a process <s> public string get handle ( ) { if ( console process _ = = null ) { return terminal handle _ ; } return console process _ . get process info ( ) . get terminal handle ( ) ; } <s> public string get handle ( ) { if ( console process _ = = null ) { return terminal handle _ ; } return console process _ . get process info ( ) . get handle ( ) ; }"}
{"source": "the x location of the center of this circle <s> public float get x ( ) { return center [ num ] ; } <s> public float get x ( ) { if ( left = = null ) { calculate left ( ) ; } return left . float value ( ) ; }"}
{"source": "the corresponding sla event list . <s> public static list < slaevent > from jsonarray ( jsonarray array ) { list < slaevent > list = new array list < slaevent > ( ) ; for ( object obj : array ) { list . add ( new json slaregistration event ( ( jsonobject ) obj ) ) ; } return list ; } <s> public static list < slaregistration bean > from jsonarray ( jsonarray array ) { list < slaregistration bean > list = new array list < slaregistration bean > ( ) ; for ( object obj : array ) { list . add ( new slaregistration bean ( ( jsonobject ) obj ) ) ; } return list ; }"}
{"source": "string the date of birth different providers may use different formats <s> public string get dob ( ) { return dob ; } <s> public birth date get dob ( ) { return dob ; }"}
{"source": "true if transformation was successfully applied on referenced child , otherwise child be not the target and therefore animation was skipped <s> public boolean transform ( canvas canvas , view child ) { final reveal values reveal data = targets . get ( child ) ; return reveal data ! = null & & reveal data . apply transformation ( canvas , child ) ; } <s> public final boolean transform ( canvas canvas , view child ) { final reveal values reveal data = targets . get ( child ) ; if ( reveal data = = null ) { return false ; } else if ( reveal data . target ! = child ) { throw new illegal state exception ( str ) ; } else if ( ! reveal data . clipping ) { return false ; } return view transformation . transform ( canvas , child , reveal data ) ; }"}
{"source": "a read lock if the underlying graph is a lockable mgraph it returns its lock , otherwise null <s> public lock read lock ( ) { if ( get graph ( ) instanceof lockable mgraph ) { return ( ( lockable mgraph ) get graph ( ) ) . get lock ( ) . read lock ( ) ; } return new fake lock ( ) ; } <s> public lock read lock ( ) { return get graph ( ) . get lock ( ) . read lock ( ) ; }"}
{"source": "the collection the x _ ad _ replication table <s> public collection < x _ ad _ replication table > get replication tables ( ) { final string where clause = new string buffer ( x _ ad _ replication table . columnname _ ad _ replication strategy _ id ) + str ; return new query ( get ctx ( ) , x _ ad _ replication table . table _ name , where clause , get _ trx name ( ) ) . set client _ id ( ) . set parameters ( get ad _ replication strategy _ id ( ) ) . set only active records ( true ) . set apply access filter ( false ) . list ( ) ; } <s> public list < x _ ad _ replication table > get replication tables ( ) { final string where clause = i _ ad _ replication table . columnname _ ad _ replication strategy _ id + str ; return new query ( get ctx ( ) , i _ ad _ replication table . table _ name , where clause , get _ trx name ( ) ) . set client _ id ( ) . set parameters ( get ad _ replication strategy _ id ( ) ) . set only active records ( true ) . set apply access filter ( false ) . list ( ) ; }"}
{"source": "the results of the active directory search . <s> protected active directory info perform authentication ( string username , char [ ] password ) { if ( search base = = null ) { throw new illegal state exception ( str ) ; } if ( url = = null ) { throw new illegal state exception ( str ) ; } if ( principal suffix ! = null ) { username = username + principal suffix ; } hashtable < string , string > env = new hashtable < string , string > ( num ) ; env . put ( context . security _ authentication , authentication ) ; env . put ( context . security _ principal , username ) ; env . put ( context . security _ credentials , new string ( password ) ) ; env . put ( context . initial _ context _ factory , context factory ) ; env . put ( context . provider _ url , url ) ; env . put ( context . referral , refferal ) ; if ( log . is debug enabled ( ) ) { log . debug ( str + env + str ) ; } ldap context ctx = null ; try { ctx = new initial ldap context ( env , null ) ; return get active directory info ( username , ctx ) ; } catch ( javax . naming . authentication exception e ) { throw new incorrect credential exception ( str , e ) ; } catch ( naming exception e ) { throw new authentication exception ( str , e ) ; } finally { try { if ( ctx ! = null ) { ctx . close ( ) ; } } catch ( naming exception e ) { if ( log . is error enabled ( ) ) { log . error ( str , e ) ; } } } } <s> protected ldap directory info perform authentication ( string username , char [ ] password ) { if ( search base = = null ) { throw new illegal state exception ( str ) ; } if ( url = = null ) { throw new illegal state exception ( str ) ; } if ( principal suffix ! = null ) { username = username + principal suffix ; } hashtable < string , string > env = new hashtable < string , string > ( num ) ; env . put ( context . security _ authentication , authentication ) ; env . put ( context . security _ principal , username ) ; env . put ( context . security _ credentials , new string ( password ) ) ; env . put ( context . initial _ context _ factory , context factory ) ; env . put ( context . provider _ url , url ) ; env . put ( context . referral , refferal ) ; if ( log . is debug enabled ( ) ) { log . debug ( str + env + str ) ; } ldap context ctx = null ; try { ctx = new initial ldap context ( env , null ) ; return get ldap directory info ( username , ctx ) ; } catch ( javax . naming . authentication exception e ) { throw new incorrect credential exception ( str , e ) ; } catch ( naming exception e ) { throw new authentication exception ( str , e ) ; } finally { try { if ( ctx ! = null ) { ctx . close ( ) ; } } catch ( naming exception e ) { if ( log . is error enabled ( ) ) { log . error ( str , e ) ; } } } }"}
{"source": "a binary predicate that will call write ( x ) on the java . io . writer y <s> public static binary predicate < string , writer > write ( ) { return new write ( ) ; } <s> public static binary visitor < string , writer > write ( ) { return new write ( ) ; }"}
{"source": "an aggregated account instance representing account data across all the successfully consulted realms . <s> protected account do multi realm authentication ( collection < ? extends realm > realms , authentication token token ) { modular authentication strategy strategy = get modular authentication strategy ( ) ; account aggregate = strategy . before all attempts ( realms , token ) ; if ( log . is debug enabled ( ) ) { log . debug ( str + realms . size ( ) + str ) ; } for ( realm realm : realms ) { if ( realm . supports ( token ) ) { if ( log . is debug enabled ( ) ) { log . debug ( str + token + str + str + realm + str ) ; } aggregate = strategy . before attempt ( realm , token , aggregate ) ; account account = null ; throwable t = null ; try { account = realm . get account ( token ) ; } catch ( throwable throwable ) { t = throwable ; if ( log . is trace enabled ( ) ) { string msg = str + realm + str ; log . trace ( msg , t ) ; } } aggregate = strategy . after attempt ( realm , token , account , aggregate , t ) ; } else { if ( log . is debug enabled ( ) ) { log . debug ( str + realm + str + str + token + str ) ; } } } aggregate = strategy . after all attempts ( token , aggregate ) ; return aggregate ; } <s> protected authentication info do multi realm authentication ( collection < ? extends realm > realms , authentication token token ) { modular authentication strategy strategy = get modular authentication strategy ( ) ; authentication info aggregate = strategy . before all attempts ( realms , token ) ; if ( log . is debug enabled ( ) ) { log . debug ( str + realms . size ( ) + str ) ; } for ( realm realm : realms ) { if ( realm . supports ( token ) ) { if ( log . is debug enabled ( ) ) { log . debug ( str + token + str + str + realm + str ) ; } authentication info info = null ; throwable t = null ; try { info = realm . get authentication info ( token ) ; } catch ( throwable throwable ) { t = throwable ; if ( log . is trace enabled ( ) ) { string msg = str + realm + str ; log . trace ( msg , t ) ; } } aggregate = strategy . after attempt ( realm , token , info , aggregate , t ) ; } else { if ( log . is debug enabled ( ) ) { log . debug ( str + realm + str + str + token + str ) ; } } } aggregate = strategy . after all attempts ( token , aggregate ) ; return aggregate ; }"}
{"source": "hash map of product type ids mapped to their parent id <s> public hash map < string , string > get sub to super map ( ) { return sub to super map ; } <s> public concurrent hash map < string , string > get sub to super map ( ) { return sub to super map ; }"}
{"source": "the cursor backing this squid cursor <s> public cursor get cursor ( ) { return cursor ; } <s> public icursor get cursor ( ) { return cursor ; }"}
{"source": "the place type corresponding to the provided name , or null . <s> public place type get place type ( string place type ) { return place types cache . get ( place type ) ; } <s> public place type get place type ( string place type name ) throws invalid place type { place type type = place type name cache . get ( place type name ) ; if ( type = = null ) throw new invalid place type ( place type name ) ; return type ; }"}
{"source": "the itype of the iastname parameter <s> public static itype create type ( iastname name ) { if ( ! ( name . get parent ( ) instanceof iastdeclarator ) ) return null ; iastdecl specifier decl spec = null ; iastdeclarator declarator = ( iastdeclarator ) name . get parent ( ) ; iastnode node = declarator . get parent ( ) ; while ( node instanceof iastdeclarator ) { declarator = ( iastdeclarator ) node ; node = node . get parent ( ) ; } if ( node instanceof iastparameter declaration ) decl spec = ( ( iastparameter declaration ) node ) . get decl specifier ( ) ; else if ( node instanceof iastsimple declaration ) decl spec = ( ( iastsimple declaration ) node ) . get decl specifier ( ) ; else if ( node instanceof iastfunction definition ) decl spec = ( ( iastfunction definition ) node ) . get decl specifier ( ) ; else if ( node instanceof iasttype id ) decl spec = ( ( iasttype id ) node ) . get decl specifier ( ) ; boolean is parameter = ( node instanceof iastparameter declaration | | node . get parent ( ) instanceof icastkn rfunction declarator ) ; itype type = null ; if ( is parameter & & node . get parent ( ) . get parent ( ) instanceof iastfunction definition ) { type = create base type ( decl spec ) ; } else { type = create type ( decl spec ) ; } type = create type ( type , declarator ) ; if ( is parameter ) { if ( type instanceof iarray type ) { carray type at = ( carray type ) type ; type = new cqualified pointer type ( at . get type ( ) , at . get modifier ( ) ) ; } else if ( type instanceof ifunction type ) { type = new cpointer type ( type ) ; } } return type ; } <s> public static itype create type ( iastdeclarator declarator ) { iastdecl specifier decl spec = null ; iastnode node = declarator . get parent ( ) ; while ( node instanceof iastdeclarator ) { declarator = ( iastdeclarator ) node ; node = node . get parent ( ) ; } if ( node instanceof iastparameter declaration ) decl spec = ( ( iastparameter declaration ) node ) . get decl specifier ( ) ; else if ( node instanceof iastsimple declaration ) decl spec = ( ( iastsimple declaration ) node ) . get decl specifier ( ) ; else if ( node instanceof iastfunction definition ) decl spec = ( ( iastfunction definition ) node ) . get decl specifier ( ) ; else if ( node instanceof iasttype id ) decl spec = ( ( iasttype id ) node ) . get decl specifier ( ) ; boolean is parameter = ( node instanceof iastparameter declaration | | node . get parent ( ) instanceof icastkn rfunction declarator ) ; itype type = null ; if ( is parameter & & node . get parent ( ) . get parent ( ) instanceof iastfunction definition ) { type = create base type ( decl spec ) ; } else { type = create type ( decl spec ) ; } type = create type ( type , declarator ) ; if ( is parameter ) { if ( type instanceof iarray type ) { carray type at = ( carray type ) type ; type = new cqualified pointer type ( at . get type ( ) , at . get modifier ( ) ) ; } else if ( type instanceof ifunction type ) { type = new cpointer type ( type ) ; } } return type ; }"}
{"source": "the created project , or null if file was not writable . <s> public static project create thellier project ( file file ) { return create project ( file , type . thellier ) ; } <s> public static project create thellier project ( file file ) { return create project ( file , thellier ) ; }"}
{"source": "the current transaction isolation level . if no transaction is active , this may be null . <s> protected transaction isolation get transaction isolation ( ) { return this . transaction isolation level ; } <s> protected isolation level get transaction isolation ( ) { return this . transaction isolation level ; }"}
{"source": "predicate <s> public < p extends visitor < ? super x > > p visit ( p predicate ) { for ( x x : this ) { predicate . visit ( x ) ; } return predicate ; } <s> public < v extends visitor < ? super x > > v visit ( v visitor ) { for ( x x : this ) { visitor . visit ( x ) ; } return visitor ; }"}
{"source": "object as a json ast node <s> public static json node as json ( object object ) throws ioexception { return json . write value as tree ( object ) ; } <s> public static string as json ( object object ) throws ioexception { return json . write value as string ( object ) ; }"}
{"source": "true if item collection contains the key , false otherwise . <s> private static boolean contains item ( collection item collection , string key ) { return item collection . contains ( key . to lower case ( ) ) ; } <s> private static boolean contains item ( collection < string > item collection , string item ) { return item collection . contains ( item . to lower case ( ) ) ; }"}
{"source": "a rex kind value , never null <s> public rex kind get kind ( ) { return rex kind . other ; } <s> public sql kind get kind ( ) { return sql kind . other ; }"}
{"source": "42 . <s> public int hash code ( ) { assert false : str ; return num ; } <s> @ override public int hash code ( ) { int hash = num ; hash = hash * num + double . value of ( get rank ( ) ) . hash code ( ) ; hash = hash * num + m url device . hash code ( ) ; hash = hash * num + m pws result . hash code ( ) ; return hash ; }"}
{"source": "the user info response object <s> protected user info response handle user info response ( oidcconfiguration oidc context configuration , string access token ) throws user info exception { user info response user info response ; user info response = oidc agent . get user info ( oidc context configuration , access token ) ; return user info response ; } <s> protected user information response handle user info response ( oidcconfiguration oidc context configuration , string access token ) throws user info exception { user information response user info response ; user info response = oidc agent . get user info ( oidc context configuration , access token ) ; return user info response ; }"}
{"source": "wsdl document <s> public document emit ( class cls , string allowed methods ) throws exception { this . cls = cls ; this . allowed methods = allowed methods ; string name = cls . get name ( ) ; name = name . substring ( name . last index of ( str ) + num ) ; set service name ( name ) ; return emit ( ) ; } <s> public definition emit ( class cls , string allowed methods ) throws exception { this . cls = cls ; this . allowed methods = allowed methods ; string name = cls . get name ( ) ; name = name . substring ( name . last index of ( str ) + num ) ; set service name ( name ) ; return emit ( ) ; }"}
{"source": "the map the value type <s> public static < k , v > fluent map < k , v > new map ( class < k > key type , class < v > value type ) { return new map ( null ) ; } <s> public static < k , v > fluent map < k , v > new map ( final class < k > key type , final class < v > value type ) { return new map ( null , key type , value type ) ; }"}
{"source": "global configuration table name including the correct escaped schema <s> private string get configuration table ( connection con ) { try { if ( storage manager . get storage impl ( con . get meta data ( ) . get database product name ( ) ) . escape schema ( ) ) return str + database const . get config schema ( ) + str + tbl _ global _ config ; } catch ( sqlexception e ) { log . warn ( e ) ; } return database const . get config schema ( ) + str + tbl _ global _ config ; } <s> private string get configuration table ( connection con ) { try { if ( storage manager . get storage impl ( con . get meta data ( ) . get database product name ( ) ) . requires config schema ( ) ) { if ( database const . get config schema ( ) . ends with ( str ) ) return database const . get config schema ( ) + tbl _ global _ config ; else return database const . get config schema ( ) + str + tbl _ global _ config ; } } catch ( sqlexception e ) { log . warn ( e ) ; } return tbl _ global _ config ; }"}
{"source": "corresponding session key <s> static protected string session ( final string query ) { return query . arg ( null , query , str ) ; } <s> static protected string session ( final string query ) { return query . arg ( str , query , str ) ; }"}
{"source": "the cause of this exception or null if no cause was specified . <s> public throwable get cause ( ) { return cause ; } <s> public throwable get cause ( ) { return super . get cause ( ) ; }"}
{"source": "int <s> public int get measure ( ) { return measure ; } <s> public number get measure ( ) { return measure ; }"}
{"source": "effect the next effect to use <s> public static effect get next effect ( ) { int effect = preferences . general . effects . get effect types ( ) ; if ( effect = = effects . random . ordinal ( ) ) { int low = effects . no _ effect . ordinal ( ) ; int hight = effects . values ( ) . length - num ; effect = low + ( int ) ( math . random ( ) * ( ( hight - low ) + num ) ) ; } if ( effect = = effects . black _ and _ white . ordinal ( ) ) { return new black and white effect ( ) ; } if ( effect = = effects . sepia . ordinal ( ) ) { return new sepia effect ( ) ; } return new null effect ( ) ; } <s> public static effect get next effect ( effect context effect context ) { effect factory effect factory = effect context . get factory ( ) ; int effect = preferences . general . effects . get effect types ( ) ; if ( effect = = effects . random . ordinal ( ) ) { int low = effects . no _ effect . ordinal ( ) ; int hight = effects . values ( ) . length - num ; effect = low + ( int ) ( math . random ( ) * ( ( hight - low ) + num ) ) ; } if ( effect = = effects . grayscale . ordinal ( ) ) { if ( effect factory . is effect supported ( effect factory . effect _ grayscale ) ) { return effect factory . create effect ( effect factory . effect _ grayscale ) ; } } if ( effect = = effects . sepia . ordinal ( ) ) { if ( effect factory . is effect supported ( effect factory . effect _ sepia ) ) { return effect factory . create effect ( effect factory . effect _ sepia ) ; } } return null ; }"}
{"source": "if the first result is an update count , if it ' s a result set <s> private boolean process results ( boolean return keys , boolean update ) throws sqlexception { while ( ! tds . is end of response ( ) ) { if ( ! tds . get more results ( ) ) { if ( tds . is update count ( ) ) { if ( update & & connection . is last update count ( ) ) { result queue . clear ( ) ; } result queue . add last ( new integer ( tds . get update count ( ) ) ) ; } } else { if ( return keys ) { if ( tds . get next row ( ) ) { gen key result set = new cached result set ( this , tds . get columns ( ) , tds . get row data ( ) ) ; } } else { if ( update & & result queue . is empty ( ) ) { throw new sqlexception ( messages . get ( str ) , str ) ; } jtds result set rs = new jtds result set ( this , result set . type _ forward _ only , result set . concur _ read _ only , tds . get columns ( ) , false ) ; if ( result queue . is empty ( ) ) { current result = rs ; return true ; } else { result queue . add ( rs ) ; return false ; } } } } return false ; } <s> private boolean process results ( boolean return keys , boolean update ) throws sqlexception { if ( ! result queue . is empty ( ) ) { throw new illegal state exception ( str ) ; } while ( ! tds . is end of response ( ) ) { if ( ! tds . get more results ( ) ) { if ( tds . is update count ( ) ) { if ( update & & connection . is last update count ( ) ) { result queue . clear ( ) ; } result queue . add last ( new integer ( tds . get update count ( ) ) ) ; } } else { if ( return keys ) { if ( tds . get next row ( ) ) { gen key result set = new cached result set ( this , tds . get columns ( ) , tds . get row data ( ) ) ; } } else { if ( update & & result queue . is empty ( ) ) { throw new sqlexception ( messages . get ( str ) , str ) ; } result queue . add ( new jtds result set ( this , result set . type _ forward _ only , result set . concur _ read _ only , tds . get columns ( ) ) ) ; break ; } } } return ! result queue . is empty ( ) ; }"}
{"source": "if wait time is more than 200ms , it returns value * 10 , otherwise - 1 . <s> @ override public long do remote function ( int value ) { long wait time = ( long ) math . floor ( math . random ( ) * num ) ; try { sleep ( wait time ) ; } catch ( interrupted exception e ) { logger . error ( str , e ) ; } return wait time > = num ? value * num : - num ; } <s> @ override public long do remote function ( int value ) { long wait time = ( long ) math . floor ( random provider . random ( ) * num ) ; try { sleep ( wait time ) ; } catch ( interrupted exception e ) { logger . error ( str , e ) ; } return wait time < = threshold ? value * num : failure ; }"}
{"source": "the hash or null if no object digest info is set . <s> public byte [ ] get object digest ( ) { if ( holder . get object digest info ( ) ! = null ) { holder . get object digest info ( ) . get object digest ( ) . get bytes ( ) ; } return null ; } <s> public byte [ ] get object digest ( ) { if ( holder . get object digest info ( ) ! = null ) { return holder . get object digest info ( ) . get object digest ( ) . get bytes ( ) ; } return null ; }"}
{"source": "map of properties <s> public static map < string , string > get properties ( object object ) throws exception { map < string , string > props = new linked hash map < string , string > ( ) ; bean info bean info = introspector . get bean info ( object . get class ( ) ) ; object [ ] null _ arg = { } ; property descriptor [ ] property descriptors = bean info . get property descriptors ( ) ; if ( property descriptors ! = null ) { for ( int i = num ; i < property descriptors . length ; i + + ) { property descriptor pd = property descriptors [ i ] ; if ( pd . get read method ( ) ! = null & & ! pd . get name ( ) . equals ( str ) & & ! pd . get name ( ) . equals ( str ) & & ! pd . get name ( ) . equals ( str ) ) { object value = pd . get read method ( ) . invoke ( object , null _ arg ) ; if ( value ! = null ) { if ( value instanceof boolean | | value instanceof number | | value instanceof string | | value instanceof uri | | value instanceof url ) { props . put ( pd . get name ( ) , ( str + value ) ) ; } else if ( value instanceof sslcontext ) { } else { map < string , string > inner = get properties ( value ) ; for ( map . entry < string , string > entry : inner . entry set ( ) ) { props . put ( pd . get name ( ) + str + entry . get key ( ) , entry . get value ( ) ) ; } } } } } } return props ; } <s> public static map < string , string > get properties ( object object ) throws exception { if ( object = = null ) { return collections . empty map ( ) ; } map < string , string > props = new linked hash map < string , string > ( ) ; bean info bean info = introspector . get bean info ( object . get class ( ) ) ; object [ ] null _ arg = { } ; property descriptor [ ] property descriptors = bean info . get property descriptors ( ) ; if ( property descriptors ! = null ) { for ( int i = num ; i < property descriptors . length ; i + + ) { property descriptor pd = property descriptors [ i ] ; if ( pd . get read method ( ) ! = null & & ! pd . get name ( ) . equals ( str ) & & ! pd . get name ( ) . equals ( str ) & & ! pd . get name ( ) . equals ( str ) ) { object value = pd . get read method ( ) . invoke ( object , null _ arg ) ; if ( value ! = null ) { if ( value instanceof boolean | | value instanceof number | | value instanceof string | | value instanceof uri | | value instanceof url ) { props . put ( pd . get name ( ) , ( str + value ) ) ; } else if ( value instanceof sslcontext ) { } else { map < string , string > inner = get properties ( value ) ; for ( map . entry < string , string > entry : inner . entry set ( ) ) { props . put ( pd . get name ( ) + str + entry . get key ( ) , entry . get value ( ) ) ; } } } } } } return props ; }"}
{"source": "the entry for the given unescaped tag . <s> public entry value for ( string unescaped tag ) { entry entry = attributes . get ( unescaped tag ) ; return entry = = null ? entry . null _ entry : entry ; } <s> public value value for ( string unescaped tag ) { value value = attributes . get ( tag . from ( escape tag ( unescaped tag ) , false ) ) ; return value = = null ? value . null _ value : value ; }"}
{"source": "item in given position <s> public complex get complex ( final int i ) { return get ( i ) ; } <s> public complex get complex ( ) { return get ( ) ; }"}
{"source": "an iterator <s> public iterator get roles ( ) { return super . get items ( ) ; } <s> public role [ ] get roles ( ) { item [ ] items = super . get items ( ) ; role [ ] roles = new role [ items . length ] ; for ( int i = num ; i < roles . length ; i + + ) { roles [ i ] = ( role ) items [ i ] ; } return roles ; }"}
{"source": "a string representation disregarding any parameters <s> public string to string ( ) { return message ; } <s> public string to string ( ) { string buffer msg = new string buffer ( get message ( ) ) ; string [ ] params = get parameters ( ) ; for ( int i = num ; i < params . length ; i + + ) { msg . append ( str + params [ i ] ) ; } return msg . to string ( ) ; }"}
{"source": "true if fast slew is on , false if not <s> public boolean get slew ( ) { return false ; } <s> public boolean [ ] get slew ( ) { boolean [ ] data = new boolean [ num ] ; string answer = this . get data ( str , str , str ) ; data [ num ] = ( ! answer . equals ( str ) ) ; answer = this . get data ( str , str , str ) ; data [ num ] = ( ! answer . equals ( str ) ) ; answer = this . get data ( str , str , str ) ; data [ num ] = ( ! answer . equals ( str ) ) ; return data ; }"}
{"source": "newly created portlet container <s> public portlet container create container ( string container name , portlet container services services ) throws portlet container exception { return create container ( container name , services , new default optional services ( ) ) ; } <s> public portlet container create container ( string container name , required container services required services ) throws portlet container exception { return create container ( container name , required services , new default optional container services ( ) ) ; }"}
{"source": "an array of name value pair , won ' t be null or empty ( at least 2 entries : group and job ) <s> private name value pair [ ] prepare query string ( string group path , string job name , properties options ) { list < name value pair > query string = new array list < name value pair > ( ) ; query string . add ( new name value pair ( str , group path ) ) ; query string . add ( new name value pair ( str , job name ) ) ; if ( options ! = null ) { for ( entry < object , object > option : options . entry set ( ) ) { query string . add ( new name value pair ( str + option . get key ( ) , string . value of ( option . get value ( ) ) ) ) ; } } return query string . to array ( new name value pair [ query string . size ( ) ] ) ; } <s> private string prepare query string ( string group path , string job name , properties options ) { list < name value pair > parameters = new array list < name value pair > ( ) ; parameters . add ( new basic name value pair ( str , group path ) ) ; parameters . add ( new basic name value pair ( str , job name ) ) ; if ( options ! = null ) { for ( entry < object , object > option : options . entry set ( ) ) { parameters . add ( new basic name value pair ( str + option . get key ( ) , string . value of ( option . get value ( ) ) ) ) ; } } return urlencoded utils . format ( parameters , http . utf _ 8 ) ; }"}
{"source": "an aggregated token stream <s> public static final token stream of ( token stream . . . streams ) { return new token stream aggregator ( streams ) ; } <s> public static final twitter token stream of ( twitter token stream . . . streams ) { return new token stream aggregator ( streams ) ; }"}
{"source": "score for that day <s> public int get value ( long timestamp ) { compute all ( ) ; string [ ] args = { habit . get id ( ) . to string ( ) , long . to string ( timestamp ) } ; return sqlite utils . int query ( str , args ) ; } <s> public final int get value ( long timestamp ) { score s = get by timestamp ( timestamp ) ; if ( s ! = null ) return s . get value ( ) ; return num ; }"}
{"source": "boolean flag indicating if multiple values are allowed <s> public boolean has args ( ) { return number of args > num | | number of args = = unlimited _ values ; } <s> public builder has args ( ) { number of args = option . unlimited _ values ; return this ; }"}
{"source": "any subset of orphaned , representing those children which ought to be removed from the folder now ( by default , all of them ) ; items not listed will be left alone for the time being <s> protected collection < i > orphaned items ( collection < i > orphaned , task listener listener ) throws ioexception , interrupted exception { return orphaned ; } <s> protected collection < i > orphaned items ( collection < i > orphaned , task listener listener ) throws ioexception , interrupted exception { return get orphaned item strategy ( ) . orphaned items ( this , orphaned , listener ) ; }"}
{"source": "the hornet qconnection factory <s> public static hornet qconnection factory create connection factory without ha ( jmsfactory type jms factory type , final transport configuration . . . transport configurations ) { hornet qconnection factory factory = null ; if ( jms factory type . equals ( jmsfactory type . cf ) ) { factory = new hornet qjmsconnection factory ( false , transport configurations ) ; } else if ( jms factory type . equals ( jmsfactory type . queue _ cf ) ) { factory = new hornet qqueue connection factory ( false , transport configurations ) ; } else if ( jms factory type . equals ( jmsfactory type . topic _ cf ) ) { factory = new hornet qtopic connection factory ( false , transport configurations ) ; } else if ( jms factory type . equals ( jmsfactory type . xa _ cf ) ) { factory = new hornet qxaconnection factory ( false , transport configurations ) ; } else if ( jms factory type . equals ( jmsfactory type . queue _ xa _ cf ) ) { factory = new hornet qxaqueue connection factory ( false , transport configurations ) ; } else if ( jms factory type . equals ( jmsfactory type . topic _ xa _ cf ) ) { factory = new hornet qxatopic connection factory ( false , transport configurations ) ; } return factory ; } <s> public static active mqconnection factory create connection factory without ha ( jmsfactory type jms factory type , final transport configuration . . . transport configurations ) { active mqconnection factory factory = null ; if ( jms factory type . equals ( jmsfactory type . cf ) ) { factory = new active mqjmsconnection factory ( false , transport configurations ) ; } else if ( jms factory type . equals ( jmsfactory type . queue _ cf ) ) { factory = new active mqqueue connection factory ( false , transport configurations ) ; } else if ( jms factory type . equals ( jmsfactory type . topic _ cf ) ) { factory = new active mqtopic connection factory ( false , transport configurations ) ; } else if ( jms factory type . equals ( jmsfactory type . xa _ cf ) ) { factory = new active mqxaconnection factory ( false , transport configurations ) ; } else if ( jms factory type . equals ( jmsfactory type . queue _ xa _ cf ) ) { factory = new active mqxaqueue connection factory ( false , transport configurations ) ; } else if ( jms factory type . equals ( jmsfactory type . topic _ xa _ cf ) ) { factory = new active mqxatopic connection factory ( false , transport configurations ) ; } return factory ; }"}
{"source": "the buffered <s> public boolean is buffered ( ) { return buffered ; } <s> public boolean is buffered ( ) { return queue . buffered ( ) ; }"}
{"source": "the wrapping rounded drawable , or the original drawable if the wrapping didn ' t take place or it took place on a drawable ' s child <s> static drawable maybe apply leaf rounding ( @ nullable drawable drawable , @ nullable rounding params rounding params , resources resources ) { if ( drawable = = null | | rounding params = = null | | rounding params . get rounding method ( ) ! = rounding params . rounding method . bitmap _ only ) { return drawable ; } if ( drawable instanceof bitmap drawable | | drawable instanceof color drawable ) { return apply leaf rounding ( drawable , rounding params , resources ) ; } else { drawable parent = drawable ; drawable child = parent . get current ( ) ; while ( child ! = null & & parent ! = child ) { if ( parent instanceof forwarding drawable & & ( child instanceof bitmap drawable | | child instanceof color drawable ) ) { ( ( forwarding drawable ) parent ) . set drawable ( s empty drawable ) ; child = apply leaf rounding ( child , rounding params , resources ) ; ( ( forwarding drawable ) parent ) . set drawable ( child ) ; break ; } parent = child ; child = parent . get current ( ) ; } } return drawable ; } <s> static drawable maybe apply leaf rounding ( @ nullable drawable drawable , @ nullable rounding params rounding params , resources resources ) { if ( drawable = = null | | rounding params = = null | | rounding params . get rounding method ( ) ! = rounding params . rounding method . bitmap _ only ) { return drawable ; } if ( drawable instanceof forwarding drawable ) { drawable parent parent = find drawable parent for leaf ( ( forwarding drawable ) drawable ) ; drawable child = parent . set drawable ( s empty drawable ) ; child = apply leaf rounding ( child , rounding params , resources ) ; parent . set drawable ( child ) ; return drawable ; } else { return apply leaf rounding ( drawable , rounding params , resources ) ; } }"}
{"source": "true if end of char [ ] is reached , false is the character is encountered . <s> protected boolean scan to ( char c ) { for ( ; cursor < length ; cursor + + ) { if ( expr [ cursor ] = = c ) { return false ; } } return true ; } <s> protected boolean scan to ( char c ) { for ( ; cursor < length ; cursor + + ) { switch ( expr [ cursor ] ) { case str : case str : cursor = capture string literal ( expr [ cursor ] , expr , cursor , expr . length ) ; default : if ( expr [ cursor ] = = c ) { return false ; } } } return true ; }"}
{"source": "a builder which will support plain object # equals ( object ) equals & plain object # hash code ( ) hash code but not support plain comparable # compare to ( object ) compare to . <s> public incomparable builder < t > with field ( final function < t , object > field ) { return new incomparable builder < > ( expected type , field ) ; } <s> public incomparable builder < t > with field ( final function < t , object > field ) { return new incomparable builder < > ( expected type , fields ) . with field ( field ) ; }"}
{"source": "a filtered environment for the calling user . <s> public static fx environment get filtered environment ( ) { return new filtered environment ( get environment ( ) ) ; } <s> public static fx environment get filtered environment ( ) { return new fx filtered environment ( get environment ( ) ) ; }"}
{"source": "the next power of two that is larger than the specified int value . <s> public static int next power of two ( int value ) { if ( ! is power of two ( value ) ) { value - - ; value | = value > > num ; value | = value > > num ; value | = value > > num ; value | = value > > num ; value | = value > > num ; value + + ; } return value ; } <s> public static int next power of two ( final int value ) { return num < < ( num - integer . number of leading zeros ( value - num ) ) ; }"}
{"source": "a pair of binary train treebank , binary tune treebank . <s> public static triple < treebank , treebank , treebank > get annotated binary treebank from treebank ( treebank train treebank , treebank secondary treebank , treebank tune treebank , options op ) { treebank lang parser params tlp params = op . tlp params ; treebank language pack tlp = tlp params . treebank language pack ( ) ; if ( op . test options . verbose ) { print writer pw err = tlp params . pw ( system . err ) ; pw err . print ( str ) ; pw err . println ( train treebank . textual summary ( tlp ) ) ; if ( secondary treebank ! = null ) { pw err . print ( str ) ; pw err . println ( secondary treebank . textual summary ( tlp ) ) ; } } system . err . print ( str ) ; tree annotator and binarizer binarizer = build train binarizer ( op ) ; composite tree transformer train transformer = build train transformer ( op , binarizer ) ; treebank whole treebank ; if ( secondary treebank = = null ) { whole treebank = train treebank ; } else { whole treebank = new composite treebank ( train treebank , secondary treebank ) ; } if ( op . train options . selective split ) { op . train options . splitters = parent annotation stats . get split categories ( whole treebank , op . train options . tag selective split , num , op . train options . selective split cut off , op . train options . tag selective split cut off , tlp ) ; remove delete splitters from splitters ( tlp , op ) ; if ( op . test options . verbose ) { list < string > list = new array list < string > ( op . train options . splitters ) ; collections . sort ( list ) ; system . err . println ( str + list ) ; } } if ( op . train options . selective post split ) { tree transformer my transformer = new tree annotator ( tlp params . head finder ( ) , tlp params , op ) ; whole treebank = whole treebank . transform ( my transformer ) ; op . train options . post splitters = parent annotation stats . get split categories ( whole treebank , true , num <s> @ suppress warnings ( str ) public static triple < treebank , treebank , treebank > get annotated binary treebank from treebank ( treebank train treebank , treebank secondary treebank , treebank tune treebank , options op ) { treebank lang parser params tlp params = op . tlp params ; treebank language pack tlp = tlp params . treebank language pack ( ) ; if ( op . test options . verbose ) { print writer pw err = tlp params . pw ( system . err ) ; pw err . print ( str ) ; pw err . println ( train treebank . textual summary ( tlp ) ) ; if ( secondary treebank ! = null ) { pw err . print ( str ) ; pw err . println ( secondary treebank . textual summary ( tlp ) ) ; } } system . err . print ( str ) ; tree annotator and binarizer binarizer = build train binarizer ( op ) ; composite tree transformer train transformer = build train transformer ( op , binarizer ) ; treebank whole treebank ; if ( secondary treebank = = null ) { whole treebank = train treebank ; } else { whole treebank = new composite treebank ( train treebank , secondary treebank ) ; } if ( op . train options . selective split ) { op . train options . splitters = parent annotation stats . get split categories ( whole treebank , op . train options . tag selective split , num , op . train options . selective split cut off , op . train options . tag selective split cut off , tlp ) ; remove delete splitters from splitters ( tlp , op ) ; if ( op . test options . verbose ) { list < string > list = new array list < string > ( op . train options . splitters ) ; collections . sort ( list ) ; system . err . println ( str + list ) ; } } if ( op . train options . selective post split ) { tree transformer my transformer = new tree annotator ( tlp params . head finder ( ) , tlp params , op ) ; whole treebank = whole treebank . transform ( my transformer ) ; op . train options . post splitters = parent annotation stats . get split categories ( whole"}
{"source": "the map of action instances to persist , keyed by the class of action . keys with null values indicate actions that should be removed if present . <s> @ non null protected map < class < ? extends action > , action > retrieve actions ( @ non null task listener listener ) throws ioexception , interrupted exception { return collections . empty map ( ) ; } <s> @ non null protected list < action > retrieve actions ( @ non null scmsource event event , @ non null task listener listener ) throws ioexception , interrupted exception { return collections . empty list ( ) ; }"}
{"source": "the web client for the current http session or null if there is not a web client created yet <s> public static web client get web client ( http session session ) { return ( web client ) session . get attribute ( web client attribute ) ; } <s> public static web client get web client ( http servlet request request ) { http session session = request . get session ( true ) ; web client client = get web client ( session ) ; if ( client = = null | | client . is closed ( ) ) { client = web client . create web client ( request ) ; session . set attribute ( web client attribute , client ) ; } return client ; }"}
{"source": "an open input stream , or null if no suitable output was produced <s> public input stream get generated output ( ) throws curn exception { return null ; } <s> public file get generated output ( ) throws curn exception { return null ; }"}
{"source": "the maximum query evaluation time , in milliseconds . <s> public long get max query time ( ) { return max query time ; } <s> public int get max query time ( ) { return max query time ; }"}
{"source": "requisition line <s> public static mrequisition line for c _ order line _ id ( properties ctx , int c _ order line _ id , string trx name ) { final string where clause = columnname _ c _ order line _ id + str ; return new query ( ctx , mrequisition line . table _ name , where clause , trx name ) . set parameters ( new object [ ] { c _ order line _ id } ) . first only ( ) ; } <s> public static mrequisition line [ ] for c _ order line _ id ( properties ctx , int c _ order line _ id , string trx name ) { final string where clause = columnname _ c _ order line _ id + str ; list < mrequisition line > list = new query ( ctx , mrequisition line . table _ name , where clause , trx name ) . set parameters ( new object [ ] { c _ order line _ id } ) . list ( ) ; return list . to array ( new mrequisition line [ list . size ( ) ] ) ; }"}
{"source": "a matcher that is the logical disjunction of given matchers <s> public static element matcher any of ( final element matcher . . . matchers ) { return new element matcher ( ) { @ override public boolean matches ( ui element element ) { for ( element matcher matcher : matchers ) { if ( matcher . matches ( element ) ) { return true ; } } return false ; } @ override public string to string ( ) { return str + joiner . on ( str ) . join ( matchers ) + str ; } } ; } <s> public static match finder any of ( final match finder . . . finders ) { return new match finder ( ) { @ override public boolean matches ( ui element element ) { for ( match finder finder : finders ) { if ( finder . matches ( element ) ) { return true ; } } return false ; } @ override public string to string ( ) { return str + joiner . on ( str ) . join ( finders ) + str ; } } ; }"}
{"source": "true if the element could not be added because the buffer needs to be drained <s> public boolean submit ( e e ) { final int segment index = segment index ( ) ; final atomic long counter = write count [ segment index ] ; final long writes = counter . get ( ) ; final int index = ( int ) ( writes & ring _ buffer _ mask ) ; final atomic reference < object > slot = table [ segment index ] [ index ] ; final object value = slot . get ( ) ; if ( ! ( value instanceof long ) ) { return true ; } else if ( ( ( long ) value ) . long value ( ) ! = writes ) { return false ; } else if ( slot . compare and set ( value , e ) ) { counter . lazy set ( new long ( writes + num ) ) ; } return false ; } <s> public boolean submit ( e e ) { final int segment index = segment index ( ) ; final atomic long read counter = read count [ segment index ] ; final atomic long write counter = write count [ segment index ] ; long head = read counter . get ( ) ; long tail = write counter . get ( ) ; long size = ( tail - head ) ; if ( size > = ring _ buffer _ size ) { return false ; } if ( write counter . compare and set ( tail , tail + num ) ) { int index = ( int ) ( tail & ring _ buffer _ mask ) ; table [ segment index ] [ index ] . lazy set ( e ) ; } return true ; }"}
{"source": "true the instance of the collection type or null <s> public boolean is resolvable ( pico container container , component adapter adapter , class expected type ) { final class collection type = get collection type ( expected type ) ; if ( collection type ! = null ) { return empty collection | | ! get matching component adapters ( container , adapter , component key type , get value type ( expected type ) ) . is empty ( ) ; } return false ; } <s> public boolean is resolvable ( pico container container , component adapter adapter , class expected type ) { final class collection type = get collection type ( expected type ) ; return collection type ! = null & & ( empty collection | | get resolving adapters ( container , adapter , expected type ) . length > num ) ; }"}
{"source": "a stream for reading the resource , or null if not found . <s> input stream open source file ( string resource name ) throws ioexception { url resource = recompiler . get resource loader ( ) . get resource ( resource name ) ; return resource = = null ? null : resource . open stream ( ) ; } <s> input stream open source file ( string path ) throws ioexception { if ( path . starts with ( str ) ) { string rest = path . substring ( str . length ( ) ) ; file file in gen dir = new file ( get gen dir ( ) , rest ) ; if ( ! file in gen dir . is file ( ) ) { return null ; } return new buffered input stream ( new file input stream ( file in gen dir ) ) ; } else { url resource = recompiler . get resource loader ( ) . get resource ( path ) ; if ( resource = = null ) { return null ; } return resource . open stream ( ) ; } }"}
{"source": "the value of this attribute if this attribute is present in the map . otherwise # get default value ( ) <s> public short get ( with attributes attributes ) { return attributes . get attributes ( ) . get ( this ) ; } <s> public short get ( with attributes with attributes ) { return with attributes . get attributes ( ) . get ( this ) ; }"}
{"source": "the list of init params defined in web . xml or application . xml <s> public string get init parameter ( string name ) { try { return framework . get servlet config ( ) . get init parameter ( name ) ; } catch ( throwable ex ) { return null ; } } <s> public string get init parameter ( string name ) { try { string value = framework . get servlet config ( ) . get init parameter ( name ) ; if ( value = = null ) { value = framework . get servlet context ( ) . get init parameter ( name ) ; } return value ; } catch ( throwable ex ) { return null ; } }"}
{"source": "the new method or an existing method with that signature . <s> public method info create method ( signature signature , string [ ] arg names ) { return create method ( signature , arg names , null ) ; } <s> public method info create method ( member id member id , string [ ] arg names ) { return create method ( member id , arg names , null ) ; }"}
{"source": "the project configurations of an empty array if none exist . <s> public ibuild configuration [ ] get build configurations ( boolean make copy ) { if ( build configs . length = = num ) return empty _ build _ configs ; return make copy ? ( ibuild configuration [ ] ) build configs . clone ( ) : build configs ; } <s> public ibuild configuration [ ] get build configurations ( iproject project , boolean make copy ) { ibuild configuration [ ] configs = cached build configs ; if ( configs ! = null & & ! project . equals ( configs [ num ] . get project ( ) ) ) configs = null ; if ( configs = = null ) { if ( config names . length = = num ) configs = new ibuild configuration [ ] { new build configuration ( project ) } ; else { configs = new ibuild configuration [ config names . length ] ; for ( int i = num ; i < configs . length ; i + + ) configs [ i ] = new build configuration ( project , config names [ i ] ) ; } cached build configs = configs ; } return make copy ? ( ibuild configuration [ ] ) configs . clone ( ) : configs ; }"}
{"source": "the cloud associated with the specified cloud name <s> public cloud get cloud ( ) { return ( cloud ) jenkins . get instance ( ) . get cloud ( cloud name ) ; } <s> public scaleway cloud get cloud ( ) { jenkins instance = jenkins . get instance ( ) ; if ( instance ! = null ) { return ( scaleway cloud ) instance . get cloud ( cloud name ) ; } return null ; }"}
{"source": "connected node <s> public string get connected server ( access token access token ) { agent mgt dao agent mgt dao = new agent mgt dao ( ) ; return agent mgt dao . get connected server ( access token . get id ( ) ) ; } <s> public string get connected server ( access token access token , string node ) { agent mgt dao agent mgt dao = new agent mgt dao ( ) ; return agent mgt dao . get connected server ( access token . get id ( ) , node ) ; }"}
{"source": "an xml - rpc hashtable representation of the workflow condition to send over the wire . <s> public static hashtable get xml rpc workflow condition ( workflow condition c ) { hashtable condition = new hashtable ( ) ; condition . put ( str , c . get condition instance class name ( ) ) ; condition . put ( str , c . get condition id ( ) ) ; condition . put ( str , c . get condition name ( ) ) ; condition . put ( str , string . value of ( c . get order ( ) ) ) ; condition . put ( str , string . value of ( c . get timeout seconds ( ) ) ) ; condition . put ( str , string . value of ( c . is optional ( ) ) ) ; condition . put ( str , get xml rpc workflow condition config ( c . get cond config ( ) ) ) ; return condition ; } <s> public static hash map get xml rpc workflow condition ( workflow condition c ) { hash map condition = new hash map ( ) ; condition . put ( str , c . get condition instance class name ( ) ) ; condition . put ( str , c . get condition id ( ) ) ; condition . put ( str , c . get condition name ( ) ) ; condition . put ( str , string . value of ( c . get order ( ) ) ) ; condition . put ( str , string . value of ( c . get timeout seconds ( ) ) ) ; condition . put ( str , string . value of ( c . is optional ( ) ) ) ; condition . put ( str , get xml rpc workflow condition config ( c . get cond config ( ) ) ) ; return condition ; }"}
{"source": "ipath to the idl base folder <s> public ipath get unoidl location ( ) { return project . get folder ( company prefix . replace ( str , str ) ) . get project relative path ( ) ; } <s> public ipath get unoidl location ( ) { ipath result = null ; if ( null ! = company prefix ) { result = project . get folder ( company prefix . replace ( str , str ) ) . get project relative path ( ) ; } return result ; }"}
{"source": "the number of writes on the chosen read buffer <s> long record read ( int buffer index , node < k , v > node ) { final atomic long counter = read buffer write count ( ) [ buffer index ] ; final long write count = counter . get ( ) ; counter . lazy set ( write count + num ) ; final int index = ( int ) ( write count & read _ buffer _ index _ mask ) ; read buffers ( ) [ buffer index ] [ index ] . lazy set ( node ) ; return write count ; } <s> boolean record read ( int buffer index , node < k , v > node ) { final atomic long counter = read buffer write count ( ) [ buffer index ] ; final long write count = counter . get ( ) ; final int index = ( int ) ( write count & read _ buffer _ index _ mask ) ; atomic reference < node < k , v > > slot = read buffers ( ) [ buffer index ] [ index ] ; if ( slot . get ( ) ! = null ) { return false ; } else if ( slot . compare and set ( null , node ) ) { counter . lazy set ( write count + num ) ; } return true ; }"}
{"source": "a new lookup service with the default server url <s> public lookup service create lookup service ( ) { return create lookup service ( default server url ) ; } <s> public lookup service create lookup service ( ) { return create lookup service ( default endpoint url ) ; }"}
{"source": "a matcher that is the logical conjunction of given matchers <s> public static element matcher all of ( final element matcher . . . matchers ) { return new element matcher ( ) { @ override public boolean matches ( ui element element ) { for ( element matcher matcher : matchers ) { if ( ! matcher . matches ( element ) ) { return false ; } } return true ; } @ override public string to string ( ) { return str + joiner . on ( str ) . join ( matchers ) + str ; } } ; } <s> public static match finder all of ( final match finder . . . finders ) { return new match finder ( ) { @ override public boolean matches ( ui element element ) { for ( match finder finder : finders ) { if ( ! finder . matches ( element ) ) { return false ; } } return true ; } @ override public string to string ( ) { return str + joiner . on ( str ) . join ( finders ) + str ; } } ; }"}
{"source": "an approximate of the current time in milliseconds <s> protected long current time millis ( ) { return nano to millis ( ticker . read ( ) ) ; } <s> protected final long current time millis ( ) { return nanos to millis ( ticker . read ( ) ) ; }"}
{"source": "the name of the table that this column comes from . null if not a column reference . <s> public string get source table name ( ) { return ( ( table name ! = null ) ? table name . get table name ( ) : ( ( source ! = null ) ? source . get table name ( ) : null ) ) ; } <s> public string get source table name ( ) { return ( ( source ! = null ) ? source . get table name ( ) : null ) ; }"}
{"source": "whether the first user can modify the second <s> public static boolean can edit ( user manager , user to edit ) { if ( is admin ( manager ) ) return true ; if ( is admin ( to edit ) ) return false ; return get management level ( manager ) > get management level ( to edit ) ; } <s> public static boolean can edit ( permissions perms , permissions user2 perms ) { if ( is admin ( perms ) ) return true ; if ( is admin ( user2 perms ) ) return false ; return get management level ( perms ) > get management level ( user2 perms ) ; }"}
{"source": "true if the ( non - wildcard ) type has the annotation or , if a wildcard , the type has the annotation on its extends bound <s> protected boolean has annotation ( annotated type mirror type , annotation mirror annotation ) { if ( ! ( type instanceof annotated wildcard type ) ) return type . has annotation ( annotation ) ; annotated wildcard type wc = ( annotated wildcard type ) type ; annotated type mirror bound = wc . get extends bound ( ) ; if ( bound ! = null & & bound . has annotation ( annotation ) ) return true ; return false ; } <s> protected boolean has annotation ( annotated type mirror type , annotation mirror annotation ) { return annotated types . get effective annotations ( type ) . contains ( annotation ) ; }"}
{"source": "sha - 1 of pattern , or encrypted string of its . <s> private char [ ] encode pattern ( list < cell > pattern ) { if ( m encrypter = = null ) { return lock pattern utils . pattern to sha1 ( pattern ) . to char array ( ) ; } else { try { return m encrypter . encrypt ( this , lock pattern utils . pattern to sha1 ( pattern ) . to char array ( ) ) ; } catch ( throwable t ) { throw new invalid encrypter exception ( ) ; } } } <s> private char [ ] encode pattern ( list < cell > pattern ) { return m encrypter ! = null ? m encrypter . encrypt ( this , pattern ) : lock pattern utils . pattern to sha1 ( pattern ) . to char array ( ) ; }"}
{"source": "the value of this attribute if this attribute is present in the map . otherwise # get default value ( ) <s> public double get ( with attributes attributes ) { return attributes . get attributes ( ) . get ( this ) ; } <s> public double get ( with attributes with attributes ) { return with attributes . get attributes ( ) . get ( this ) ; }"}
{"source": "an iterator <s> public iterator get groups ( ) { return super . get items ( ) ; } <s> public group [ ] get groups ( ) { item [ ] items = super . get items ( ) ; group [ ] groups = new group [ items . length ] ; for ( int i = num ; i < groups . length ; i + + ) { groups [ i ] = ( group ) items [ i ] ; } return groups ; }"}
{"source": "non - null if sibling was found , null otherwise . <s> public static treepath get previous sibling ( treepath treepath ) { if ( treepath . get height ( ) < num ) { throw new illegal argument exception ( str ) ; } final tree tree to move = treepath . get bottom ( ) ; final tree parent = treepath . get tree at height ( num ) ; for ( int i = parent . get child count ( ) - num ; i > num ; i - - ) { final tree child = parent . get child at ( i ) ; if ( child = = tree to move ) { return treepath . create ( treepath . get parent ( ) , parent . get child at ( i - num ) ) ; } } return null ; } <s> public static treepath get previous sibling ( treepath treepath ) throws illegal argument exception { if ( treepath . get height ( ) < num ) { throw new illegal argument exception ( str ) ; } final tree tree to move = treepath . get bottom ( ) ; final tree parent = treepath . get tree at height ( num ) ; for ( int i = parent . get child count ( ) - num ; i > num ; i - - ) { final tree child = parent . get child at ( i ) ; if ( child = = tree to move ) { return treepath . create ( treepath . get parent ( ) , parent . get child at ( i - num ) ) ; } } throw new illegal argument exception ( str ) ; }"}
{"source": "java . util . date <s> public java . util . date get create date ( ) { return this . create date ; } <s> public date get create date ( ) { return this . create date ; }"}
{"source": "window to show in the portlet <s> protected window get portlet window ( portlet request request , application application ) { portlet mode mode = request . get portlet mode ( ) ; if ( portlet mode . view . equals ( mode ) ) { return application . get main window ( ) ; } else { window window = application . get window ( mode . to string ( ) ) ; if ( window ! = null ) { return window ; } } return application . get main window ( ) ; } <s> protected window get portlet window ( portlet request request , application application ) { portlet mode mode = request . get portlet mode ( ) ; window window = application . get window ( mode . to string ( ) ) ; if ( window ! = null ) { return window ; } return application . get main window ( ) ; }"}
{"source": "the edit text found or null if nothing is found <s> public edit text search edit text ( string search ) { array list < edit text > edit text list = get current edit texts ( ) ; iterator < edit text > iterator = edit text list . iterator ( ) ; while ( iterator . has next ( ) ) { edit text edit text = ( edit text ) iterator . next ( ) ; if ( edit text . get text ( ) . to string ( ) . equals ( search ) ) { return edit text ; } } return null ; } <s> public boolean search edit text ( string search ) { pattern p = pattern . compile ( search ) ; matcher matcher ; array list < edit text > edit text list = get current edit texts ( ) ; iterator < edit text > iterator = edit text list . iterator ( ) ; while ( iterator . has next ( ) ) { edit text edit text = ( edit text ) iterator . next ( ) ; matcher = p . matcher ( edit text . get text ( ) . to string ( ) ) ; if ( matcher . matches ( ) ) { return true ; } } if ( scroll down list ( ) ) return search edit text ( search ) ; else return false ; }"}
{"source": "always returns derby database # protocol . <s> protected string get url protocol ( ) { return protocol ; } <s> protected string get url protocol ( ) { return str + ( get port ( ) > num ? get port ( ) : default _ port ) + str ; }"}
{"source": "the extended fluent pipeline <s> public t e ( ) { return this . add ( new edges pipe ( ) ) ; } <s> public gremlin pipeline < s , edge > e ( ) { return this . add ( new edges pipe ( ) ) ; }"}
{"source": "the package names that will be searched for property editors . <s> public static list get editor search path ( ) { string [ ] path = property editor manager . get editor search path ( ) ; list list = new array list ( path . length ) ; for ( int i = num ; i < path . length ; i + + ) { list . add ( path [ i ] ) ; } return list ; } <s> public static list get editor search path ( ) { string [ ] paths = property editor manager . get editor search path ( ) ; list path list = new array list ( paths . length ) ; for ( int i = num ; i < paths . length ; i + + ) { path list . add ( paths [ i ] ) ; } return path list ; }"}
{"source": "new background color based on the supplied foreground color <s> private int invert bg color ( ) { if ( current color _ . default color ( ) ) { if ( ! inverted _ ) clazzes _ . add ( inverse _ bg _ style ) ; return color . default _ color ; } else if ( current color _ . code ( ) > = foreground _ min & & current color _ . code ( ) < = foreground _ max ) { int new bg = current color _ . code ( ) + ( background _ min - foreground _ min ) ; clazzes _ . add ( background _ style + integer . to string ( new bg - background _ min ) ) ; return new bg ; } else { int new bg = current color _ . code ( ) + ( background _ intense _ min - foreground _ intense _ min ) ; clazzes _ . add ( background _ style + integer . to string ( new bg + num - background _ intense _ min ) ) ; return new bg ; } } <s> private color invert bg color ( ) { if ( current color _ . default color ( ) ) { if ( ! inverted _ ) clazzes _ . add ( inverse _ bg _ style ) ; return new color ( ) ; } else if ( current color _ . is extended ( ) ) { clazzes _ . add ( color . clazz for color index ( current color _ . code ( ) , true ) ) ; return new color ( true , current color _ . code ( ) ) ; } else if ( current color _ . code ( ) > = foreground _ min & & current color _ . code ( ) < = foreground _ max ) { int new bg = current color _ . code ( ) + ( background _ min - foreground _ min ) ; clazzes _ . add ( background _ style + integer . to string ( new bg - background _ min ) ) ; return new color ( false , new bg ) ; } else { int new bg = current color _ . code ( ) + ( background _ intense _ min - foreground _ intense _ min ) ; clazzes _ . add ( background _ style + integer . to string ( new bg + num - background _ intense _ min ) ) ; return new color ( false , new bg ) ; } }"}
{"source": "a list with instances of org . mule . module . google . task . model . task list <s> @ processor @ oauth protected @ oauth invalidate access token on ( exception = oauth token expired exception . class ) @ inject public list < task list > get task lists ( mule message message , @ optional @ default ( str ) long max results , @ optional string page token ) throws ioexception { task lists list = this . client . tasklists ( ) . list ( ) . set max results ( max results ) . set page token ( page token ) . execute ( ) ; pagination utils . save page token ( next _ page _ token , list . get next page token ( ) , message ) ; return task list . value of ( list . get items ( ) , task list . class ) ; } <s> @ processor @ oauth protected @ oauth invalidate access token on ( exception = oauth token expired exception . class ) @ paged public paging delegate < task list > get task lists ( final paging configuration paging configuration ) throws ioexception { return new token based paging delegate < task list > ( ) { @ override protected list < task list > do get page ( ) throws ioexception { task lists list = client . tasklists ( ) . list ( ) . set max results ( new long ( paging configuration . get fetch size ( ) ) ) . set page token ( this . get page token ( ) ) . execute ( ) ; this . set page token ( list . get next page token ( ) ) ; return task list . value of ( list . get items ( ) , task list . class ) ; } } ; }"}
{"source": "the extended fluent pipeline <s> public t both v ( ) { return this . add ( new both vertices pipe ( ) ) ; } <s> public gremlin pipeline < s , vertex > both v ( ) { return this . add ( new both vertices pipe ( ) ) ; }"}
{"source": "the newly built configuration . <s> public static configuration builder ( ) { return new configuration ( ) ; } <s> public static builder builder ( ) { return new builder ( ) ; }"}
{"source": "a subset configuration using the prefix # reporter _ prefix with the reporter parameter appended . any change made to subset will be reflected in this configuration , but with the prefix added . <s> public configuration get reporter configuration ( string reporter ) { return subset ( reporter _ prefix + str + reporter ) ; } <s> public simple configuration get reporter configuration ( string reporter ) { return subset ( reporter _ prefix + str + reporter ) ; }"}
{"source": "object value of the property - or null <s> public object get property ( string name ) { if ( name ! = null ) return call properties . get ( name ) ; return null ; } <s> public object get property ( string name ) { if ( name = = null | | ! is property supported ( name ) ) throw new illegal argument exception ( ) ; return call properties . get ( name ) ; }"}
{"source": "true if the component is \" alive \" a . k . a . not disposing or disposed . <s> static boolean observe ( @ nonnull final object object ) { return as component observable ( object ) . observe ( ) ; } <s> static boolean observe ( @ nullable final object object ) { return ! ( object instanceof component observable ) | | as component observable ( object ) . observe ( ) ; }"}
{"source": "the sink file <s> public file get sink file ( ) { return sink file ; } <s> public file get sink file ( ) { return queue . file ( ) ; }"}
{"source": "a list with instances of org . mule . module . google . drive . model . file <s> @ processor @ oauth protected @ oauth invalidate access token on ( exception = oauth token expired exception . class ) @ inject public list < file > list files ( mule message message , @ optional @ default ( str ) int max results , @ optional string query , @ optional @ default ( str ) string page token ) throws ioexception { file list response = this . client . files ( ) . list ( ) . set max results ( max results ) . set page token ( page token ) . set q ( query ) . execute ( ) ; pagination utils . save page token ( next _ page _ token , response . get next page token ( ) , message ) ; return file . value of ( response . get items ( ) , file . class ) ; } <s> @ processor @ oauth protected @ oauth invalidate access token on ( exception = oauth token expired exception . class ) @ paged public paging delegate < file > list files ( @ optional @ default ( str ) final int max results , @ optional final string query , final paging configuration paging configuration ) throws ioexception { return new token based paging delegate < file > ( ) { @ override public list < file > do get page ( ) throws ioexception { file list response = client . files ( ) . list ( ) . set max results ( max results ) . set page token ( this . get page token ( ) ) . set q ( query ) . execute ( ) ; this . set page token ( response . get next page token ( ) ) ; return file . value of ( response . get items ( ) , file . class ) ; } } ; }"}
{"source": "scale animation builder instance . call com . davemorrissey . labs . subscaleview . subsampling scale image view . scale animation builder # start ( ) to start the anim . <s> public scale animation builder animate scale and center ( float scale , point f s center ) { if ( ! is image ready ( ) ) { return null ; } return new scale animation builder ( scale , s center ) ; } <s> public animation builder animate scale and center ( float scale , point f s center ) { if ( ! is image ready ( ) ) { return null ; } return new animation builder ( scale , s center ) ; }"}
{"source": "# to array ( int , int , string , boolean ) <s> public jsonrequest to array ( int count , int page , string name ) { return to array ( count , page , name , true ) ; } <s> public jsonrequest to array ( int count , int page , string name ) { return new jsonrequest ( string util . get string ( name ) + key _ array , this . set count ( count ) . set page ( page ) ) ; }"}
{"source": "whether the objects are equal in terms of numeric value . <s> @ override public boolean equals ( object obj ) { return obj . get class ( ) . equals ( nsnumber . class ) & & obj . hash code ( ) = = hash code ( ) ; } <s> @ override public boolean equals ( object obj ) { if ( ! ( obj instanceof nsnumber ) ) return false ; nsnumber n = ( nsnumber ) obj ; return type = = n . type & & long value = = n . long value & & double value = = n . double value & & bool value = = n . bool value ; }"}
{"source": "connection result state return true , otherwise it returns false . <s> public static boolean is connected ( net type net type , network info network info ) { if ( net type = = net type . any & & network info ! = null & & is connected ( network info ) ) return true ; else if ( net type = = net type . wifi & & network info ! = null & & network info . get type ( ) = = connectivity manager . type _ wifi & & is connected ( network info ) ) return true ; else if ( net type = = net type . mobile & & network info ! = null & & network info . get type ( ) = = connectivity manager . type _ mobile & & is connected ( network info ) ) return true ; return false ; } <s> private static boolean is connected ( net type net type , network info network info ) { switch ( net type ) { case any : return network info ! = null & & is connected ( network info ) ; case wifi : return network info ! = null & & network info . get type ( ) = = connectivity manager . type _ wifi & & is connected ( network info ) ; case mobile : return network info ! = null & & network info . get type ( ) = = connectivity manager . type _ mobile & & is connected ( network info ) ; } return false ; }"}
{"source": "the stored value or null if it doesn ' t exist in specified form . <s> public boolean get extra boolean ( string key ) { return m extra data . opt boolean ( key ) ; } <s> public boolean get extra boolean ( string key ) throws jsonexception { return m extra data . get boolean ( key ) ; }"}
{"source": "long total of values seen <s> public long sum ( ) { return sum ; } <s> public t sum ( ) { return sum ; }"}
{"source": "total count <s> @ transactional ( read only = true ) @ override public int get all count ( final string current user , final set < string > current role ) { return batch instance dao . get all count ( current user , current role ) ; } <s> @ transactional ( read only = true ) @ override public int get all count ( final string current user , final set < string > user roles , ephesoft user ephesoft user ) { return batch instance dao . get all count ( current user , user roles , ephesoft user ) ; }"}
{"source": "lsit of objects whose view has been filtered <s> protected list filter view collection ( collection result , set view filter ) { list new collection = new array list ( ) ; for ( iterator i = result . iterator ( ) ; i . has next ( ) ; ) { new collection . add ( filter view ( ( map ) i . next ( ) ) ) ; } return new collection ; } <s> protected list < map < object , object > > filter view collection ( collection < map < object , object > > result , set view filter ) { list < map < object , object > > new collection = new array list < map < object , object > > ( ) ; for ( iterator < map < object , object > > i = result . iterator ( ) ; i . has next ( ) ; ) { new collection . add ( filter view ( i . next ( ) ) ) ; } return new collection ; }"}
{"source": "returns a ipath <s> public ipath get root ( ) { return root ; } <s> public url get root ( ) { return root url ; }"}
{"source": "a map containing the query string parameters <s> public map < string , string > get query string params ( ) { try { map < string , string > params = new hash map < string , string > ( ) ; string query string = new url ( url ) . get query ( ) ; params . put all ( map utils . query string to map ( query string ) ) ; params . put all ( this . querystring params ) ; return params ; } catch ( malformed urlexception mue ) { throw new oauth exception ( str , mue ) ; } } <s> public parameter list get query string params ( ) { try { parameter list result = new parameter list ( ) ; string query string = new url ( url ) . get query ( ) ; result . add querystring ( query string ) ; result . add all ( querystring params ) ; return result ; } catch ( malformed urlexception mue ) { throw new oauth exception ( str , mue ) ; } }"}
{"source": "an iterator <s> public iterator get items ( ) { return items . values ( ) . iterator ( ) ; } <s> public item [ ] get items ( ) { return ( item [ ] ) items . values ( ) . to array ( new item [ items . values ( ) . size ( ) ] ) ; }"}
{"source": "a widget instance <s> public static widget get widget ( string metadata , string shindig ) throws exception { jsonobject gadget = null ; widget widget = null ; jsonobject response = new jsonobject ( metadata ) ; jsonarray gadgets = response . get jsonarray ( str ) ; if ( gadgets . length ( ) > num ) { gadget = gadgets . get jsonobject ( num ) ; if ( gadget . has ( str ) ) throw new exception ( str ) ; widget = new widget ( ) ; string title = str ; int height = num ; int width = num ; string author = str ; string description = str ; string icon = default _ icon ; if ( ! gadget . has ( str ) ) throw new exception ( str ) ; if ( gadget . get string ( str ) = = null | | gadget . get string ( str ) . equals ( str ) ) throw new exception ( str ) ; try { @ suppress warnings ( str ) url url = new url ( gadget . get string ( str ) ) ; } catch ( exception e ) { throw new exception ( str ) ; } widget . set guid ( gadget . get string ( str ) ) ; start file sf = new start file ( ) ; sf . set widget ( widget ) ; sf . set url ( shindig + str + gadget . get string ( str ) + str ) ; if ( gadget . has ( str ) ) if ( gadget . get int ( str ) ! = num ) height = gadget . get int ( str ) ; if ( gadget . has ( str ) ) if ( gadget . get int ( str ) ! = num ) width = gadget . get int ( str ) ; if ( gadget . has ( str ) ) { if ( gadget . get string ( str ) ! = null ) { if ( ! ( gadget . get string ( str ) . trim ( ) ) . equals ( str ) ) { author = gadget . get string ( str ) ; } } } if ( gadget . has ( str ) ) { if ( gadget . get string ( str ) ! = null ) { if ( ! ( gadget . get string ( str ) . trim ( ) ) . equals ( str ) <s> public static w3 cwidget get widget ( string metadata , string shindig ) throws exception { jsonobject gadget = null ; jsonobject response = new jsonobject ( metadata ) ; jsonarray gadgets = response . get jsonarray ( str ) ; if ( gadgets . length ( ) = = num ) return null ; gadget = gadgets . get jsonobject ( num ) ; return new gadget adapter ( gadget , shindig ) ; }"}
{"source": "the chronology that the date is using <s> public chronology get chronology ( ) { return i chronology ; } <s> protected chronology get chronology ( ) { return i instant . get chronology ( ) ; }"}
{"source": "form encoded string <s> public string get body contents ( ) { try { return new string ( get byte body contents ( ) , get charset ( ) ) ; } catch ( unsupported encoding exception uee ) { throw new oauth exception ( str + charset , uee ) ; } } <s> @ deprecated public string get body contents ( ) { return get string payload ( ) ; }"}
{"source": "a group of accept entities . <s> public static immutable list < accept > parse ( final http servlet request r ) throws illegal argument exception { return parse ( strings . null to empty ( r . get header ( str ) ) ) ; } <s> public static list < accept > parse ( final http servlet request r ) throws illegal argument exception { return parse ( r . get header ( str ) ) ; }"}
{"source": "read operation rdf branch <s> private rdf branch branch ( boolean includeinferred ) throws sail exception { boolean active = is active ( ) ; isolation level level = get isolation level ( ) ; boolean isolated = ! isolation levels . none . is compatible with ( level ) ; if ( includeinferred & & active & & isolated ) { return new delegating rdf branch ( include inferred branch , false ) ; } else if ( active & & isolated ) { return new delegating rdf branch ( explicit only branch , false ) ; } else if ( includeinferred & & active ) { return new union rdf branch ( new rdf not branched source ( store . get inferred rdf source ( level ) ) , new rdf not branched source ( store . get explicit rdf source ( level ) ) ) ; } else if ( active ) { return new rdf not branched source ( store . get explicit rdf source ( level ) ) ; } else if ( includeinferred ) { return new union rdf branch ( store . get inferred rdf source ( level ) . fork ( ) , store . get explicit rdf source ( level ) . fork ( ) ) ; } else { return store . get explicit rdf source ( level ) . fork ( ) ; } } <s> private sail branch branch ( boolean includeinferred ) throws sail exception { boolean active = is active ( ) ; isolation level level = get isolation level ( ) ; boolean isolated = ! isolation levels . none . is compatible with ( level ) ; if ( includeinferred & & active & & isolated ) { return new delegating sail branch ( include inferred branch , false ) ; } else if ( active & & isolated ) { return new delegating sail branch ( explicit only branch , false ) ; } else if ( includeinferred & & active ) { return new union sail branch ( new sail not branched source ( store . get inferred sail source ( level ) ) , new sail not branched source ( store . get explicit sail source ( level ) ) ) ; } else if ( active ) { return new sail not branched source ( store . get explicit sail source ( level ) ) ; } else if ( includeinferred ) { return new union sail branch ( store . get inferred sail source ( level ) . fork ( ) , store . get explicit sail source ( level ) . fork ( ) ) ; } else { return store . get explicit sail source ( level ) . fork ( ) ; } }"}
{"source": "iterator of all derived types <s> public list < fx type > get derived types ( ) { return derived types ; } <s> public list < fx type > get derived types ( ) { return collections . unmodifiable list ( derived types ) ; }"}
{"source": "the empty gmml drawing <s> public gmml drawing create new drawing ( ) { return new gmml drawing ( sc , swt . no _ background ) ; } <s> public pathway create new drawing ( ) { return new pathway ( sc , swt . no _ background ) ; }"}
{"source": "a incompatible change instance or null if the method is not making any blacklisted calls . <s> @ nullable public static incompatible change verify method ( method node method ) { verifier method visitor mv = new verifier method visitor ( method ) ; method . accept ( mv ) ; return mv . incompatible change . or null ( ) ; } <s> @ non null public static instant run verifier status verify method ( method node method ) { verifier method visitor mv = new verifier method visitor ( method ) ; method . accept ( mv ) ; return mv . incompatible change . or ( instant run verifier status . compatible ) ; }"}
{"source": "true if we wrote a schema , false if we didn ' t . <s> public boolean write schema ( types types ) throws exception { if ( ! simple type . class . is assignable from ( java type ) ) return false ; element complex type = types . create element ( str ) ; types . write schema element ( xml type , complex type ) ; complex type . set attribute ( str , xml type . get local part ( ) ) ; element simple content = types . create element ( str ) ; complex type . append child ( simple content ) ; element extension = types . create element ( str ) ; simple content . append child ( extension ) ; string base = str ; for ( int i = num ; i < property descriptor . length ; i + + ) { string prop name = property descriptor [ i ] . get name ( ) ; if ( ! prop name . equals ( str ) ) { if ( type desc ! = null ) { field desc field = type desc . get field by name ( prop name ) ; if ( field ! = null ) { if ( field . is element ( ) ) { } qname qname = field . get xml name ( ) ; if ( qname = = null ) { prop name = prop name ; qname = new qname ( str , prop name ) ; } class field type = property descriptor [ i ] . get type ( ) ; if ( ! types . is acceptable as attribute ( field type ) ) { throw new axis fault ( messages . get message ( str , prop name , field type . get name ( ) ) ) ; } string element type = types . write type ( field type ) ; element elem = types . create attribute element ( prop name , element type , false , extension . get owner document ( ) ) ; extension . append child ( elem ) ; } } continue ; } bean property descriptor bpd = property descriptor [ i ] ; class type = bpd . get type ( ) ; if ( ! types . is acceptable as attribute ( type ) ) { throw new axis fault ( messages . get message ( str , type . get name ( ) ) ) ; } base = types . write type ( type ) ; extension . set attribute ( str , base ) ; } return true ; } <s> public element write schema ( class java type , types types ) throws exception { if ( ! simple type . class . is assignable from ( java type ) ) return null ; element complex type = types . create element ( str ) ; types . write schema element ( xml type , complex type ) ; complex type . set attribute ( str , xml type . get local part ( ) ) ; element simple content = types . create element ( str ) ; complex type . append child ( simple content ) ; element extension = types . create element ( str ) ; simple content . append child ( extension ) ; string base = str ; for ( int i = num ; i < property descriptor . length ; i + + ) { string prop name = property descriptor [ i ] . get name ( ) ; if ( ! prop name . equals ( str ) ) { if ( type desc ! = null ) { field desc field = type desc . get field by name ( prop name ) ; if ( field ! = null ) { if ( field . is element ( ) ) { } qname qname = field . get xml name ( ) ; if ( qname = = null ) { qname = new qname ( str , prop name ) ; } class field type = property descriptor [ i ] . get type ( ) ; if ( ! types . is acceptable as attribute ( field type ) ) { throw new axis fault ( messages . get message ( str , prop name , field type . get name ( ) ) ) ; } element elem = types . create attribute element ( prop name , field type , field . get xml type ( ) , false , extension . get owner document ( ) ) ; extension . append child ( elem ) ; } } continue ; } bean property descriptor bpd = property descriptor [ i ] ; class type = bpd . get type ( ) ; if ( ! types . is acceptable as attribute ( type ) ) { throw new axis fault ( messages . get message ( str , type . get name ( ) ) ) ; } base = types . write type ( type ) ; extension . set attribute ( str , base ) ; } return complex type ; }"}
{"source": "the document fragment or null on error . <s> public document fragment parse xml ( string text , document doc ) { return null ; } <s> public node parse xml ( string text , document doc ) { return null ; }"}
{"source": "a collection containing all primitives of the dataset . the data is ordered after : first come nodes , then ways , then relations . ordering in between the categories is not guaranteed . <s> public list < osm primitive > all primitives ( ) { list < osm primitive > o = new linked list < osm primitive > ( ) ; o . add all ( nodes ) ; o . add all ( ways ) ; o . add all ( relations ) ; return o ; } <s> public collection < osm primitive > all primitives ( ) { return collections . unmodifiable collection ( all primitives ) ; }"}
{"source": "boolean # true if \" default \" is set , boolean # false for other value , or null if nothing is set . <s> private static boolean is xmlspace default ( dom node node ) { for ( ; node instanceof dom element ; node = node . get parent node ( ) ) { final string value = ( ( dom element ) node ) . get attribute ( str ) ; if ( ! value . is empty ( ) ) { if ( str . equals ( value ) ) { return boolean . true ; } return boolean . false ; } } return null ; } <s> private static boolean is xmlspace default ( dom node node ) { for ( ; node instanceof dom element ; node = node . get parent node ( ) ) { final string value = ( ( dom element ) node ) . get attribute ( str ) ; if ( ! value . is empty ( ) ) { if ( str . equals ( value ) ) { return true ; } return false ; } } return false ; }"}
{"source": "bnode if it is a blank node otherwise a uri ref <s> public non literal convert non literal ( node node ) { if ( node = = null ) { throw new illegal argument exception ( str ) ; } if ( node . is blank ( ) ) { return convert jena node2 tria blank node ( node ) ; } if ( node . is uri ( ) ) { return convert jena uri2 uri ref ( node ) ; } throw new runtime exception ( str + node + str ) ; } <s> public blank node or iri convert non literal ( node node ) { if ( node = = null ) { throw new illegal argument exception ( str ) ; } if ( node . is blank ( ) ) { return convert jena node2 tria blank node ( node ) ; } if ( node . is uri ( ) ) { return convert jena uri2 uri ref ( node ) ; } throw new runtime exception ( str + node + str ) ; }"}
{"source": "a new variation service with the default server url <s> public variation service create variation service ( ) { return create variation service ( default server url ) ; } <s> public variation service create variation service ( ) { return create variation service ( default endpoint url ) ; }"}
{"source": "current cost price ll sum current cost price level low for this cost element type <s> private big decimal get current cost price ll ( mppproduct bom bom , mcost element element , int yield ) { log . info ( str + element . get cost element type ( ) ) ; big decimal cost price ll = env . zero ; for ( mppproduct bomline bomline : bom . get lines ( ) ) { mproduct component = mproduct . get ( get ctx ( ) , bomline . get m _ product _ id ( ) ) ; for ( mcost cost : get costs ( component , element . get cost element type ( ) ) ) { if ( element . get cost element type ( ) . equals ( element . get cost element type ( ) ) ) { big decimal qty percentage = bomline . get qty batch ( ) . divide ( env . onehundred , num , big decimal . round _ up ) ; big decimal qty bom = bomline . get qty bom ( ) ; big decimal scrap dec = bomline . get scrap ( ) . divide ( env . onehundred , num , big decimal . round _ up ) ; big decimal qty total = env . zero ; if ( bomline . is qty percentage ( ) ) { qty total = qty percentage . divide ( env . one . subtract ( scrap dec ) , num , big decimal . round _ half _ up ) ; } else { qty total = qty bom . divide ( env . one . subtract ( scrap dec ) , num , big decimal . round _ half _ up ) ; } big decimal cost price = cost . get current cost price ( ) . add ( cost . get current cost price ll ( ) ) ; cost price ll = cost price ll . add ( cost price . multiply ( qty total ) ) ; log . info ( str + element . get name ( ) + str + cost price ll + str + qty percentage + str + qty bom ) ; } } } if ( yield ! = num ) { big decimal decimal yield = new big decimal ( yield / num ) ; cost price ll = cost price ll . divide ( decimal yield , num , big decimal . round _ half _ up ) ; } return cost price ll ; } <s> private big decimal get current cost price ll ( mppproduct bom bom , mcost element element ) { log . info ( str + element . get cost element type ( ) ) ; big decimal cost price ll = env . zero ; if ( bom = = null ) return cost price ll ; for ( mppproduct bomline bomline : bom . get lines ( ) ) { mproduct component = mproduct . get ( get ctx ( ) , bomline . get m _ product _ id ( ) ) ; for ( mcost cost : get costs ( component , element . get cost element type ( ) ) ) { big decimal qty percentage = bomline . get qty batch ( ) . divide ( env . onehundred , num , big decimal . round _ up ) ; big decimal qty bom = bomline . get qty bom ( ) ; big decimal scrap dec = bomline . get scrap ( ) . divide ( env . onehundred , num , big decimal . round _ up ) ; big decimal qty total = env . zero ; if ( bomline . is qty percentage ( ) ) { qty total = qty percentage . divide ( env . one . subtract ( scrap dec ) , num , big decimal . round _ half _ up ) ; } else { qty total = qty bom . divide ( env . one . subtract ( scrap dec ) , num , big decimal . round _ half _ up ) ; } big decimal cost price = cost . get current cost price ( ) . add ( cost . get current cost price ll ( ) ) ; cost price ll = cost price ll . add ( cost price . multiply ( qty total ) ) ; log . info ( str + element . get name ( ) + str + cost price ll + str + qty percentage + str + qty bom ) ; } } return cost price ll ; }"}
{"source": "a long instance of id passed in parameter <s> private long get id from parameter ( ) { string parameter = faces utils . get parameter ( id ) ; if ( parameter = = null | | parameter . is empty ( ) ) { return null ; } try { return long . parse long ( string utils . get only integer numbers ( parameter ) ) ; } catch ( number format exception ex ) { return null ; } } <s> private object get id from parameter ( ) { string parameter = faces utils . get parameter ( id ) ; if ( parameter = = null | | parameter . is empty ( ) ) { return null ; } try { class id type = entity utils . get id type ( entity class ) ; if ( id type . equals ( long . class ) ) { return long . parse long ( string utils . get only integer numbers ( parameter ) ) ; } else if ( id type . equals ( integer . class ) ) { return integer . parse int ( string utils . get only integer numbers ( parameter ) ) ; } else { logger . log ( level . severe , str , new object [ ] { id type . get name ( ) , entity class . get name ( ) } ) ; return null ; } } catch ( number format exception ex ) { return null ; } }"}
{"source": "qname fully qualified name of the port <s> public qname get port type name ( ) { return port name = = null ? new qname ( str ) : port name ; } <s> public qname get port type name ( ) { return port type name = = null ? new qname ( str ) : port type name ; }"}
{"source": "s the location in display coordinates or null iff unchanged <s> private point compute popup location ( int snap position , boolean editor bounds changed ) { if ( f popup = = null | | f popup . is disposed ( ) ) return null ; switch ( snap position ) { case snap _ position _ lower _ right : if ( ! editor bounds changed ) { return null ; } else { styled text e widget = f editor . get viewer ( ) . get text widget ( ) ; rectangle e bounds = e widget . get client area ( ) ; point e lower right = e widget . to display ( e bounds . x + e bounds . width , e bounds . y + e bounds . height ) ; point p size = f popup . get size ( ) ; return new point ( e lower right . x - p size . x - num , e lower right . y - p size . y - num ) ; } case snap _ position _ under _ right _ field : case snap _ position _ over _ right _ field : { linked position position = f rename linked mode . get current linked position ( ) ; if ( position = = null ) return null ; isource viewer viewer = f editor . get viewer ( ) ; itext viewer extension5 viewer5 = ( itext viewer extension5 ) viewer ; int widget offset = viewer5 . model offset2 widget offset ( position . offset + position . length ) ; styled text text widget = viewer . get text widget ( ) ; point pos = text widget . get location at offset ( widget offset ) ; point p size = f popup . get size ( ) ; if ( snap position = = snap _ position _ over _ right _ field ) { pos . y - = p size . y ; } else { pos . y + = text widget . get line height ( widget offset ) ; } pos . x + = num ; point d pos = text widget . to display ( pos ) ; rectangle display bounds = text widget . get display ( ) . get client area ( ) ; rectangle d popup rect = geometry . create rectangle ( d pos , p size ) ; geometry . move inside ( d popup rect , display bounds ) ; return new point ( d popup rect . x , d popup rect . y ) ; } case snap _ position _ under _ left _ field : case snap _ position _ over _ left _ <s> private point compute popup location ( int snap position ) { if ( f popup = = null | | f popup . is disposed ( ) ) return null ; switch ( snap position ) { case snap _ position _ lower _ right : { styled text e widget = f editor . get viewer ( ) . get text widget ( ) ; rectangle e bounds = e widget . get client area ( ) ; point e lower right = e widget . to display ( e bounds . x + e bounds . width , e bounds . y + e bounds . height ) ; point p size = get extent ( ) ; return new point ( e lower right . x - p size . x - num , e lower right . y - p size . y - num ) ; } case snap _ position _ under _ right _ field : case snap _ position _ over _ right _ field : { linked position position = f rename linked mode . get current linked position ( ) ; if ( position = = null ) return null ; isource viewer viewer = f editor . get viewer ( ) ; itext viewer extension5 viewer5 = ( itext viewer extension5 ) viewer ; int widget offset = viewer5 . model offset2 widget offset ( position . offset + position . length ) ; styled text text widget = viewer . get text widget ( ) ; point pos = text widget . get location at offset ( widget offset ) ; point p size = get extent ( ) ; if ( snap position = = snap _ position _ over _ right _ field ) { pos . y - = p size . y + gap ; } else { pos . y + = text widget . get line height ( widget offset ) + gap ; } pos . x + = gap ; point d pos = text widget . to display ( pos ) ; rectangle display bounds = text widget . get display ( ) . get client area ( ) ; rectangle d popup rect = geometry . create rectangle ( d pos , p size ) ; geometry . move inside ( d popup rect , display bounds ) ; return new point ( d popup rect . x , d popup rect . y ) ; } case snap _ position _ under _ left _ field : case snap _ position _ over _ left _ field : default : { linked position position = f rename linked mode . get current linked position ( )"}
{"source": "returns true if it is in melee distance <s> public boolean is in melee distance ( world area other ) { if ( other = = null | | this . get plane ( ) ! = other . get plane ( ) ) { return false ; } point distances = get axis distances ( other ) ; return distances . get x ( ) + distances . get y ( ) = = num ; } <s> public boolean is in melee distance ( world point other ) { return is in melee distance ( new world area ( other , num , num ) ) ; }"}
{"source": "bnode if it is a blank node , uri ref if it is a uri and literal if it is a literal . <s> public resource convert jena node2 resource ( node node ) { if ( node = = null ) { throw new illegal argument exception ( str ) ; } if ( node . is blank ( ) ) { return convert jena node2 tria blank node ( node ) ; } if ( node . is uri ( ) ) { return convert jena uri2 uri ref ( node ) ; } if ( node . is literal ( ) ) { return convert jena literal2 literal ( node ) ; } throw new runtime exception ( str + node + str ) ; } <s> public rdf term convert jena node2 resource ( node node ) { if ( node = = null ) { throw new illegal argument exception ( str ) ; } if ( node . is blank ( ) ) { return convert jena node2 tria blank node ( node ) ; } if ( node . is uri ( ) ) { return convert jena uri2 uri ref ( node ) ; } if ( node . is literal ( ) ) { return convert jena literal2 literal ( node ) ; } throw new runtime exception ( str + node + str ) ; }"}
{"source": "a new resource test rule <s> public resource test rule build ( ) { return new resource test rule ( new resource test jersey configuration ( singletons , providers , properties , mapper , validator , client configurator , test container factory , register default exception mappers ) ) ; } <s> public resource test rule build ( ) { return new resource test rule ( build resource ( ) ) ; }"}
{"source": "an http client <s> public http client build ( string name ) { final basic http params params = create http params ( name ) ; final instrumented client conn manager manager = create connection manager ( registry , name ) ; final instrumented http client client = new instrumented http client ( metric registry , manager , params , name ) ; set strategies for client ( client ) ; return client ; } <s> public closeable http client build ( string name ) { final instrumented http client connection manager manager = create connection manager ( registry , name ) ; return create client ( org . apache . http . impl . client . http client builder . create ( ) , manager , name ) ; }"}
{"source": "the version <s> public static function < product item , string > os version ( ) { return new function < product item , string > ( ) { @ override public string apply ( product item product item ) { check not null ( product item , str ) ; final string description = product item . get description ( ) ; os family family = os family ( ) . apply ( product item ) ; if ( family . equals ( os family . centos ) ) return parse version ( description , centos ) ; else if ( family . equals ( os family . debian ) ) return parse version ( description , debian ) ; else if ( family . equals ( os family . fedora ) ) return parse version ( description , fedora ) ; else if ( family . equals ( os family . rhel ) ) return parse version ( description , rhel ) ; else if ( family . equals ( os family . ubuntu ) ) return parse version ( description , ubuntu ) ; else if ( family . equals ( os family . windows ) ) return parse version ( description , windows ) ; else if ( family . equals ( os family . cloud _ linux ) ) return parse version ( description , cloud _ linux ) ; else throw new no such element exception ( str + product item ) ; } } ; } <s> public static function < string , string > os version ( ) { return new function < string , string > ( ) { @ override public string apply ( final string description ) { os family family = os family ( ) . apply ( description ) ; if ( objects . equal ( family , os family . centos ) ) return parse version ( description , centos ) ; else if ( objects . equal ( family , os family . debian ) ) return parse version ( description , debian ) ; else if ( objects . equal ( family , os family . fedora ) ) return parse version ( description , fedora ) ; else if ( objects . equal ( family , os family . rhel ) ) return parse version ( description , rhel ) ; else if ( objects . equal ( family , os family . ubuntu ) ) return parse version ( description , ubuntu ) ; else if ( objects . equal ( family , os family . windows ) ) return parse version ( description , windows ) ; else if ( objects . equal ( family , os family . cloud _ linux ) ) return parse version ( description , cloud _ linux ) ; return null ; } } ; }"}
{"source": "sdp content <s> private string build remove video sdp proposal ( ) { if ( logger . is activated ( ) ) { logger . info ( str ) ; } string sdp = str ; string ntp time = sip utils . construct ntptime ( system . current time millis ( ) ) ; string ip address = get dialog path ( ) . get sip stack ( ) . get local ip address ( ) ; try { logger . warn ( str ) ; get audio player ( ) . get local rtp port ( ) ; string audio sdp = audio sdp builder . build sdp ( get audio player ( ) . get supported audio codecs ( ) , get audio player ( ) . get local rtp port ( ) ) ; sdp = str + sip utils . crlf + str + ntp time + str + ntp time + str + sdp utils . format address type ( ip address ) + sip utils . crlf + str + sip utils . crlf + str + sdp utils . format address type ( ip address ) + sip utils . crlf + str + sip utils . crlf + audio sdp + str + sip utils . crlf ; } catch ( remote exception e ) { if ( logger . is activated ( ) ) { logger . error ( str , e ) ; } handle error ( new ipcall error ( ipcall error . unexpected _ exception , e . get message ( ) ) ) ; } return sdp ; } <s> private string build remove video sdp proposal ( ) { if ( logger . is activated ( ) ) { logger . debug ( str ) ; } try { string ntp time = sip utils . construct ntptime ( system . current time millis ( ) ) ; string ip address = get dialog path ( ) . get sip stack ( ) . get local ip address ( ) ; get audio player ( ) . get local rtp port ( ) ; string audio sdp = audio sdp builder . build sdp offer ( get audio player ( ) . get supported audio codecs ( ) , get audio player ( ) . get local rtp port ( ) ) ; return str + sip utils . crlf + str + ntp time + str + ntp time + str + sdp utils . format address type ( ip address ) + sip utils . crlf + str + sip utils . crlf + str + sdp utils . format address type ( ip address ) + sip utils . crlf + str + sip utils . crlf + audio sdp + str + sip utils . crlf ; } catch ( remote exception e ) { if ( logger . is activated ( ) ) { logger . error ( str , e ) ; } handle error ( new ipcall error ( ipcall error . unexpected _ exception , e . get message ( ) ) ) ; return null ; } }"}
{"source": "roller an instance of roller . <s> public static final roller get roller ( ) { if ( roller instance = = null ) { throw new illegal state exception ( str ) ; } return roller instance ; } <s> public static final weblogger get roller ( ) { if ( roller instance = = null ) { throw new illegal state exception ( str ) ; } return roller instance ; }"}
{"source": "the source path or null if not defined <s> private string get script source path ( xml tag node node ) { for ( xml attribute node attribute : node . get attributes ( ) ) { if ( attribute . get name ( ) . get lexeme ( ) . equals ( src ) ) { string text = attribute . get text ( ) ; return text ! = null & & text . length ( ) > num ? text : null ; } } return null ; } <s> private xml attribute node get script source path ( xml tag node node ) { for ( xml attribute node attribute : node . get attributes ( ) ) { if ( attribute . get name ( ) . get lexeme ( ) . equals ( src ) ) { return attribute ; } } return null ; }"}
{"source": "whether cv1t1 is reference - related to cv2t2 <s> private static final boolean is reference related ( itype cv1t1 , itype cv2t2 ) throws domexception { itype t1 = semantic util . get ultimate type upto pointers ( cv1t1 ) ; itype t2 = semantic util . get ultimate type upto pointers ( cv2t2 ) ; if ( t1 instanceof ipointer type & & t2 instanceof ipointer type ) { itype ptt1 = ( ( ipointer type ) t1 ) . get type ( ) ; itype ptt2 = ( ( ipointer type ) t2 ) . get type ( ) ; return ptt1 ! = null & & ptt2 ! = null ? ptt1 . is same type ( ptt2 ) : ptt1 = = ptt2 ; } t1 = t1 instanceof iqualifier type ? ( ( iqualifier type ) t1 ) . get type ( ) : t1 ; t2 = t2 instanceof iqualifier type ? ( ( iqualifier type ) t2 ) . get type ( ) : t2 ; if ( t1 instanceof icppclass type & & t2 instanceof icppclass type ) { return calculate inheritance depth ( cppsemantics . max _ inheritance _ depth , t2 , t1 ) > = num ; } return t1 ! = null & & t2 ! = null ? t1 . is same type ( t2 ) : t1 = = t2 ; } <s> private static final int is reference related ( itype cv1 target , itype cv2 source ) throws domexception { itype t = semantic util . get nested type ( cv1 target , typedefs | references ) ; itype s = semantic util . get nested type ( cv2 source , typedefs | references ) ; if ( t instanceof ipointer type & & s instanceof ipointer type ) { t = ( ( ipointer type ) t ) . get type ( ) ; s = ( ( ipointer type ) s ) . get type ( ) ; } else { t = t instanceof iqualifier type ? ( ( iqualifier type ) t ) . get type ( ) : t ; s = s instanceof iqualifier type ? ( ( iqualifier type ) s ) . get type ( ) : s ; if ( t instanceof icppclass type & & s instanceof icppclass type ) { return calculate inheritance depth ( cppsemantics . max _ inheritance _ depth , s , t ) ; } } if ( t = = s | | ( t ! = null & & s ! = null & & t . is same type ( s ) ) ) { return num ; } return - num ; }"}
{"source": "component info representing the implementation type metadata <s> public component info introspect ( class < ? > impl class ) throws configuration load exception { component info comp type = factory . create component info ( ) ; return introspect ( impl class , comp type ) ; } <s> public component type introspect ( class < ? > impl class ) throws configuration load exception { component type comp type = factory . create component type ( ) ; return introspect ( impl class , comp type ) ; }"}
{"source": "the object name for the given exchange on the test virtual host . <s> public object name get queue object name ( string virtual host name , string queue ) { all objects all object = new all objects ( _ mbsc ) ; all object . querystring = str + virtual host name + str + queue + str ; set < object name > object names = all object . return objects ( ) ; _ test . assert not null ( str , object names ) ; _ test . assert equals ( str + all object . querystring + str , num , object names . size ( ) ) ; return object names . iterator ( ) . next ( ) ; } <s> @ suppress warnings ( str ) public object name get queue object name ( string virtual host name , string queue ) { all objects all object = new all objects ( _ mbsc ) ; all object . querystring = str + virtual host name + str + queue + str ; set < object name > object names = all object . return objects ( ) ; _ test . assert not null ( str , object names ) ; _ test . assert equals ( str + all object . querystring + str , num , object names . size ( ) ) ; object name object name = object names . iterator ( ) . next ( ) ; _ test . get logger ( ) . info ( str + object name ) ; return object name ; }"}
{"source": "the value of this attribute if this attribute is present in the map . otherwise # get default value ( ) <s> public float get ( with attributes attributes ) { return attributes . get attributes ( ) . get ( this ) ; } <s> public float get ( with attributes with attributes ) { return with attributes . get attributes ( ) . get ( this ) ; }"}
{"source": "status : 200 / / 200 400 token 500 msg : \" ok \" / / token . data : \" username \" : \" xbin \" / / <s> @ override public xbin result token ( string token , string callback ) { if ( string utils . is not blank ( callback ) ) { return xbin result . ok ( callback ) ; } try { string username = jedis client . get ( user _ session + token ) ; if ( string utils . is not blank ( username ) ) { return xbin result . ok ( username ) ; } } catch ( exception e ) { logger . error ( str ) ; } return xbin result . build ( num , str ) ; } <s> @ override public xbin result token ( string token , string callback ) { if ( string utils . is not blank ( callback ) ) { return xbin result . ok ( callback ) ; } try { string user = jedis client . get ( user _ session + token ) ; if ( string utils . is not blank ( user ) ) { return xbin result . ok ( user ) ; } } catch ( exception e ) { logger . error ( str ) ; } return xbin result . build ( num , str ) ; }"}
{"source": "this chat section ' s value parsed as a boolean . if the value of the chat section isn ' t a valid boolean , false is returned <s> public boolean as boolean ( ) { return boolean . parse boolean ( arg ) ; } <s> public boolean as boolean ( ) { return boolean . value of ( arg ) ; }"}
{"source": "non - null if sibling was found , null otherwise . <s> public static treepath get next sibling ( treepath treepath ) { throw new unsupported operation exception ( str ) ; } <s> public static treepath get next sibling ( treepath treepath ) { if ( treepath . get height ( ) < num ) { throw new illegal argument exception ( str ) ; } final tree tree to move = treepath . get bottom ( ) ; final tree parent = treepath . get tree at height ( num ) ; for ( int i = num ; i < parent . get child count ( ) - num ; i + + ) { final tree child = parent . get child at ( i ) ; if ( child = = tree to move ) { return treepath . create ( treepath . get parent ( ) , parent . get child at ( i + num ) ) ; } } throw new illegal argument exception ( str ) ; }"}
{"source": "the http response <s> public < t > http response < t > do get ( http request http request , class < t > response type ) { input stream is = null ; try { http urlconnection conn = ( http urlconnection ) new url ( http request . get url ( ) ) . open connection ( ) ; conn . set request method ( str ) ; int connect timeout = http request . get connect timeout ( ) ; if ( connect timeout < num ) { connect timeout = m _ config util . get connect timeout ( ) ; } int read timeout = http request . get read timeout ( ) ; if ( read timeout < num ) { read timeout = m _ config util . get read timeout ( ) ; } conn . set connect timeout ( connect timeout ) ; conn . set read timeout ( read timeout ) ; conn . connect ( ) ; int status code = conn . get response code ( ) ; if ( status code = = num ) { is = conn . get input stream ( ) ; string content = files . io . instance . read from ( is , charsets . utf _ 8 . name ( ) ) ; return new http response < > ( status code , gson . from json ( content , response type ) ) ; } if ( status code = = num ) { return new http response < > ( status code , null ) ; } throw new runtime exception ( string . format ( str , http request . get url ( ) , status code ) ) ; } catch ( throwable ex ) { throw new runtime exception ( str , ex ) ; } finally { if ( is ! = null ) { try { is . close ( ) ; } catch ( ioexception ex ) { } } } } <s> public < t > http response < t > do get ( http request http request , final class < t > response type ) { function < string , t > convert response = new function < string , t > ( ) { @ override public t apply ( string input ) { return gson . from json ( input , response type ) ; } } ; return do get with serialize function ( http request , convert response ) ; }"}
{"source": "the target body information . <s> protected medication medical record body type map body ( final ehrextract ehr extract , final int composition index ) { final composition composition = ehr extract . get all compositions ( ) . get ( composition index ) ; final medication medical record body type body type = new medication medical record body type ( ) ; additional patient information type apit = new additional patient information type ( ) ; apit . set date of birth ( str ) ; cvtype gender = new cvtype ( ) ; gender . set code ( str ) ; gender . set code system ( str ) ; gender . set display name ( str ) ; gender . set original text ( str ) ; apit . set gender ( gender ) ; body type . set additional patient information ( apit ) ; medication prescription type mpt = new medication prescription type ( ) ; mpt . set dispensation authorization ( new dispensation authorization type ( ) ) ; mpt . set end of treatment ( str ) ; mpt . set end of treatment reason ( new cvtype ( ) ) ; mpt . set evaluator ( new healthcare professional type ( ) ) ; mpt . set preceding prescription id ( new iitype ( ) ) ; mpt . set prescriber ( new healthcare professional type ( ) ) ; mpt . set prescription chain id ( new iitype ( ) ) ; mpt . set prescription id ( new iitype ( ) ) ; mpt . set prescription status ( new cvtype ( ) ) ; mpt . set self medication ( false ) ; mpt . set start of first treatment ( str ) ; mpt . set succeeding prescription id ( new iitype ( ) ) ; mpt . set type of prescription ( type of prescription enum . insttning ) ; body type . set medication prescription ( mpt ) ; for ( final content content : composition . get content ( ) ) { for ( final item item : ( ( entry ) content ) . get items ( ) ) { log . debug ( item . get meaning ( ) . get code ( ) + str + item . get meaning ( ) . get display name ( ) . get value ( ) + str + ( item instanceof element ? str : str ) ) ; switch ( item <s> protected medication medical record body type map body ( final ehrextract ehr extract , final int composition index ) { final composition composition = ehr extract . get all compositions ( ) . get ( composition index ) ; map < string , string > ehr13606values = retrieve values ( composition , composition index ) ; return build body ( ehr13606values ) ; }"}
{"source": "the current time in ms <s> private long now ( ) { return m monotonic clock = = null ? system clock . uptime millis ( ) : m monotonic clock . now ( ) ; } <s> private long now ( ) { return system clock . uptime millis ( ) ; }"}
{"source": "a vector containing all the child nodes of this node . <s> protected final vector get contents ( ) { return _ contents ; } <s> protected final list < syntax tree node > get contents ( ) { return _ contents ; }"}
{"source": "log object as a json formatted string <s> public static string export ( ) { request log current = rlog . get ( ) ; record ( new durations ( current . aggregate durations ( ) ) ) ; record ( new threads ( current . thread ids ) ) ; try { return current . mapper . write value as string ( current . info ) ; } catch ( json processing exception jpe ) { string msg = string . format ( str , current . log id ) ; log . warn ( msg , jpe ) ; return msg ; } } <s> public static string export ( ) { request log current = rlog . get ( ) ; record ( new durations ( current . aggregate durations ( ) ) ) ; record ( new threads ( current . thread ids ) ) ; return log formatter provider . get instance ( ) . format ( current . info ) ; }"}
{"source": "listenable future that resolves to cached element or null if one cannot be retrieved ; returned future never rethrows any exception <s> public task < encoded image > get ( final cache key key , final atomic boolean is cancelled ) { preconditions . check not null ( key ) ; preconditions . check not null ( is cancelled ) ; final encoded image pinned image = m staging area . get ( key ) ; if ( pinned image ! = null ) { flog . v ( tag , str , key . to string ( ) ) ; m image cache stats tracker . on staging area hit ( ) ; return task . for result ( pinned image ) ; } try { return task . call ( new callable < encoded image > ( ) { @ override public encoded image call ( ) throws exception { if ( is cancelled . get ( ) ) { throw new cancellation exception ( ) ; } encoded image result = m staging area . get ( key ) ; if ( result ! = null ) { flog . v ( tag , str , key . to string ( ) ) ; m image cache stats tracker . on staging area hit ( ) ; } else { flog . v ( tag , str , key . to string ( ) ) ; m image cache stats tracker . on staging area miss ( ) ; try { final pooled byte buffer buffer = read from disk cache ( key ) ; closeable reference < pooled byte buffer > ref = closeable reference . of ( buffer ) ; try { result = new encoded image ( ref ) ; } finally { closeable reference . close safely ( ref ) ; } } catch ( exception exception ) { return null ; } } if ( thread . interrupted ( ) ) { flog . v ( tag , str ) ; if ( result ! = null ) { result . close ( ) ; } throw new interrupted exception ( ) ; } else { return result ; } } } , m read executor ) ; } catch ( exception exception ) { flog . w ( tag , exception , str , key . to string ( ) ) ; return task . for error ( exception ) ; } } <s> public task < encoded image > get ( cache key key , atomic boolean is cancelled ) { final encoded image pinned image = m staging area . get ( key ) ; if ( pinned image ! = null ) { return found pinned image ( key , pinned image ) ; } return get async ( key , is cancelled ) ; }"}
{"source": "protocol result . <s> public connection result get connection ( ibasic request request ) { logger . d ( str ) ; headers response headers = new http headers ( ) ; input stream input stream = null ; exception exception = null ; network network = null ; string url = request . url ( ) ; try { if ( ! net util . is network available ( ) ) throw new network error ( str + url ) ; network = create connection and write data ( request ) ; logger . d ( str ) ; int response code = network . get response code ( ) ; response headers = parse response headers ( new uri ( request . url ( ) ) , response code , network . get response headers ( ) ) ; if ( response code = = num | | response code = = num | | response code = = num | | response code = = num ) { connection result redirect connection = handle redirect ( request , response headers ) ; response headers = redirect connection . response headers ( ) ; input stream = redirect connection . server stream ( ) ; exception = redirect connection . exception ( ) ; } else if ( has response body ( request . get request method ( ) , response code ) ) { input stream = network . get server stream ( response code , response headers ) ; } logger . d ( str ) ; } catch ( malformed urlexception e ) { exception = new urlerror ( str + url + str ) ; } catch ( unknown host exception e ) { exception = new un known host error ( str + url + str ) ; } catch ( socket timeout exception e ) { exception = new timeout error ( str + url + str ) ; } catch ( exception e ) { exception = e ; } finally { if ( exception ! = null ) logger . e ( exception ) ; } logger . d ( str ) ; return new connection result ( network , response headers , input stream , exception ) ; } <s> public connection get connection ( ibasic request request ) { logger . d ( str ) ; headers response headers = new http headers ( ) ; input stream input stream = null ; exception exception = null ; network network = null ; string url = request . url ( ) ; try { if ( ! net util . is network available ( ) ) throw new network error ( str + str + url ) ; network = create connection and write data ( request ) ; logger . d ( str ) ; int response code = network . get response code ( ) ; response headers = parse response headers ( new uri ( request . url ( ) ) , response code , network . get response headers ( ) ) ; if ( response code = = num | | response code = = num | | response code = = num | | response code = = num ) { connection redirect connection = handle redirect ( request , response headers ) ; response headers = redirect connection . response headers ( ) ; input stream = redirect connection . server stream ( ) ; exception = redirect connection . exception ( ) ; } else if ( has response body ( request . get request method ( ) , response code ) ) { input stream = network . get server stream ( response code , response headers ) ; } logger . d ( str ) ; } catch ( malformed urlexception e ) { exception = new urlerror ( str + url + str ) ; } catch ( unknown host exception e ) { exception = new un known host error ( str + url + str ) ; } catch ( socket timeout exception e ) { exception = new timeout error ( str + url + str ) ; } catch ( exception e ) { exception = e ; } finally { if ( exception ! = null ) logger . e ( exception ) ; } logger . d ( str ) ; return new connection ( network , response headers , input stream , exception ) ; }"}
{"source": "the minimum length of the string . <s> public final int get min length ( ) { return min length ; } <s> public integer get min length ( ) { return min length ; }"}
{"source": "cache statistics impl . <s> public cache statistics impl create cache stat if absent ( string name ) { if ( ! statistics . contains key ( name ) ) { statistics . put if absent ( name , new cache statistics impl ( ) ) ; } return statistics . get ( name ) ; } <s> public cache statistics impl create cache stat if absent ( string name ) { cache statistics impl statistics = new cache statistics impl ( ) ; cache statistics impl temp = this . statistics . put if absent ( name , statistics ) ; if ( temp ! = null ) { statistics = temp ; } return statistics ; }"}
{"source": "true if the reference is a normal var declaration ( only normal vars can be inlined ) . <s> private boolean is valid declaration ( reference declaration ) { return declaration . get parent ( ) . get type ( ) = = token . var & & declaration . get grandparent ( ) . get type ( ) ! = token . for ; } <s> private boolean is valid declaration ( reference declaration ) { return ( declaration . get parent ( ) . get type ( ) = = token . var & & declaration . get grandparent ( ) . get type ( ) ! = token . for ) | | node util . is function declaration ( declaration . get parent ( ) ) ; }"}
{"source": "user info response object <s> user info response process user info response ( httprequest request ) throws user info exception { user info response user info response = new user info response ( ) ; com . nimbusds . openid . connect . sdk . user info response response ; try { response = com . nimbusds . openid . connect . sdk . user info response . parse ( request . send ( ) ) ; } catch ( parse exception | ioexception e ) { throw new user info exception ( str , e ) ; } if ( response instanceof user info error response ) { return user info response ; } user info success response user info success response = ( user info success response ) response ; user info response . set user info ( user info success response . get user info ( ) . to jsonobject ( ) . to jsonstring ( ) ) ; return user info response ; } <s> user information response process user info response ( httprequest request ) throws user info exception { user information response user information response = new user information response ( ) ; user info response response ; try { response = com . nimbusds . openid . connect . sdk . user info response . parse ( request . send ( ) ) ; } catch ( parse exception | ioexception e ) { throw new user info exception ( str , e ) ; } if ( response instanceof user info error response ) { return user information response ; } user info success response user info success response = ( user info success response ) response ; user information response . set user info ( user info success response . get user info ( ) . to jsonobject ( ) . to jsonstring ( ) ) ; return user information response ; }"}
{"source": "the string representation as a comma - separated list of simple annotation names . <s> @ override public string to string ( ) { list < string > l = new linked list < > ( ) ; for ( annotation mirror a : annotations ) { declared type anno type = a . get annotation type ( ) ; type element elm = ( type element ) anno type . as element ( ) ; l . add ( elm . get simple name ( ) . to string ( ) ) ; } string s = l . to string ( ) ; return s . substring ( num , s . length ( ) - num ) ; } <s> @ override public string to string ( ) { return annotations . to string ( ) ; }"}
{"source": "the istext expert instance . <s> static public istext expert get stateful expert ( string type , stext environment environment ) { stext type handler handler = stext type handler factory . get handler ( type ) ; if ( handler = = null ) throw new illegal argument exception ( str ) ; return get stateful expert ( handler , environment ) ; } <s> static public istructured text expert get stateful expert ( string type , structured text environment environment ) { structured text type handler handler = structured text type handler factory . get handler ( type ) ; if ( handler = = null ) throw new illegal argument exception ( str ) ; return get stateful expert ( handler , environment ) ; }"}
{"source": "the node as a string <s> public static < t , n extends tree node < t > > string to string ( final n node ) { final function < n , string > function = new function < n , string > ( ) { @ override public string apply ( final n arg0 ) { return arg0 . to string ( ) ; } } ; return to string ( node , function ) ; } <s> public static < t , n extends tree node < t > > string to string ( final n input node , final function < n , string > to string ) { final string builder builder = new string builder ( ) ; depth first ( input node , new tree visitor < n > ( ) { final set < integer > depths = sets . new hash set ( ) ; @ suppress warnings ( str ) @ override public void on node ( final int depth , final n node ) { if ( ! is root ( node ) & & ! is leaf ( node ) & & ! is last child ( node ) ) { this . depths . add ( depth ) ; } else { this . depths . remove ( depth ) ; } builder . append ( indent ( depth ) ) ; final string node string = to string . apply ( node ) ; builder . append ( str ) . append ( node string ) . append ( strings2 . new _ line ) ; } private string indent ( final int depth ) { final string builder b = new string builder ( ) ; for ( int i = num ; i < depth ; i + + ) { if ( this . depths . contains ( integer . value of ( i ) ) ) { b . append ( str ) ; } else { b . append ( str ) ; } } return b . to string ( ) ; } } ) ; return builder . to string ( ) ; }"}
{"source": "array of key name pairs <s> public static key name pair [ ] get key name pairs ( string sql , boolean optional ) { prepared statement pstmt = null ; result set rs = null ; array list < key name pair > list = new array list < key name pair > ( ) ; if ( optional ) list . add ( new key name pair ( - num , str ) ) ; try { pstmt = db . prepare statement ( sql , null ) ; rs = pstmt . execute query ( ) ; while ( rs . next ( ) ) list . add ( new key name pair ( rs . get int ( num ) , rs . get string ( num ) ) ) ; } catch ( exception e ) { log . log ( level . severe , sql , e ) ; } finally { close ( rs ) ; close ( pstmt ) ; rs = null ; pstmt = null ; } key name pair [ ] ret value = new key name pair [ list . size ( ) ] ; list . to array ( ret value ) ; return ret value ; } <s> public static key name pair [ ] get key name pairs ( string sql , boolean optional ) { return get key name pairs ( sql , optional , ( object [ ] ) null ) ; }"}
{"source": "the service reference ( null if the service is unregistred ) . <s> public service reference get service reference ( ) { return m _ service reference ; } <s> public service reference get service reference ( ) { return m _ ps . get service reference ( ) ; }"}
{"source": "returns the unicode string of an uri ref or the lexical form of a literal or the return value of a to string ( ) on a bnode <s> private static string get value ( resource resource ) { if ( resource instanceof uri ref ) { return ( ( uri ref ) resource ) . get unicode string ( ) ; } else if ( resource instanceof literal ) { return ( ( literal ) resource ) . get lexical form ( ) ; } else { return resource . to string ( ) ; } } <s> private static string get value ( rdfterm resource ) { if ( resource instanceof iri ) { return ( ( iri ) resource ) . get unicode string ( ) ; } else if ( resource instanceof literal ) { return ( ( literal ) resource ) . get lexical form ( ) ; } else { return resource . to string ( ) ; } }"}
{"source": "the wire type <s> public wire type get wire type ( ) { return wire type ; } <s> public wire type get wire type ( ) { return queue . wire type ( ) ; }"}
{"source": "the dart node . <s> public dart node get node ( ) { return node ; } <s> public astnode get node ( ) { return node ; }"}
{"source": "a copy of the stored portlet preferences array . <s> public internal portlet preference [ ] get stored preferences ( portlet window portlet window , portlet request request ) throws portlet container exception { string key = get formatted key ( portlet window , request ) ; internal portlet preference [ ] preferences = storage . get ( key ) ; if ( preferences = = null ) { if ( log . is debug enabled ( ) ) { log . debug ( str + key ) ; } return new internal portlet preference [ num ] ; } else { if ( log . is debug enabled ( ) ) { log . debug ( str + preferences . length + str ) ; } return clone preferences ( preferences ) ; } } <s> public map < string , internal portlet preference > get stored preferences ( portlet window portlet window , portlet request request ) throws portlet container exception { string key = get formatted key ( portlet window , request ) ; map < string , internal portlet preference > preferences = storage . get ( key ) ; if ( preferences = = null ) { if ( log . is debug enabled ( ) ) { log . debug ( str + key ) ; } return collections . empty map ( ) ; } else { if ( log . is debug enabled ( ) ) { log . debug ( str + preferences . size ( ) + str ) ; } return clone preferences ( preferences ) ; } }"}
{"source": "emf refactoring supported by the controller . <s> @ override public emf refactoring get parent ( ) { return this . parent ; } <s> @ override public refactoring get parent ( ) { return this . parent ; }"}
{"source": "the resulting element array ( empty if the search failed ) <s> public element [ ] get elements ( string name ) { element [ ] elems = ( element [ ] ) m _ elements . get ( name . to lower case ( ) ) ; if ( elems = = null ) { return new element [ num ] ; } else { return elems ; } } <s> public element [ ] get elements ( string name ) { element [ ] elems = ( element [ ] ) m _ elements . get ( name . to lower case ( ) ) ; return elems ; }"}
{"source": "a byte representing this operation . <s> public byte to ordinal ( ) { return this . op code ; } <s> public int to ordinal ( ) { return this . op code ; }"}
{"source": "validation function <s> public static function < list , void > elasticsearch checker ( final string . . . strings ) { return new function < list , void > ( ) { @ nullable @ override public void apply ( @ nullable list actual ) { object [ ] actual array = actual = = null | | actual . is empty ( ) ? null : ( ( list ) actual . get ( num ) ) . to array ( ) ; calcite assert . assert array equal ( str , strings , actual array ) ; return null ; } } ; } <s> public static consumer < list > elasticsearch checker ( final string . . . strings ) { return actual - > { object [ ] actual array = actual = = null | | actual . is empty ( ) ? null : ( ( list ) actual . get ( num ) ) . to array ( ) ; calcite assert . assert array equal ( str , strings , actual array ) ; } ; }"}
{"source": "rx java observable with connectivity status <s> public observable < connectivity status > observe network connectivity ( final context context ) { final intent filter filter = new intent filter ( ) ; filter . add action ( connectivity manager . connectivity _ action ) ; return observable . create ( new observable . on subscribe < connectivity status > ( ) { @ override public void call ( final subscriber < ? super connectivity status > subscriber ) { final broadcast receiver receiver = new broadcast receiver ( ) { @ override public void on receive ( context context , intent intent ) { final connectivity status new status = get connectivity status ( context ) ; if ( new status ! = status ) { status = new status ; subscriber . on next ( new status ) ; } } } ; context . register receiver ( receiver , filter ) ; subscriber . add ( unsubscribe in ui thread ( new action0 ( ) { @ override public void call ( ) { context . unregister receiver ( receiver ) ; } } ) ) ; } } ) . default if empty ( connectivity status . offline ) ; } <s> public observable < connectivity > observe network connectivity ( final context context ) { final network observing strategy strategy ; final boolean is at least lollipop = build . version . sdk _ int > = build . version _ codes . lollipop ; if ( is at least lollipop ) { strategy = new lollipop network observing strategy ( ) ; } else { strategy = new pre lollipop network observing strategy ( ) ; } return observe network connectivity ( context , strategy ) ; }"}
{"source": "a line <s> public final sound get sound challenge ( ) { return this . challenge ; } <s> public final audio input stream get sound challenge ( ) { return this . challenge ; }"}
{"source": "the parsed , configured specification . <s> public static specification parse ( string query string , bullet config config ) { specification specification = gson . from json ( query string , specification . class ) ; specification . configure ( config ) ; return specification ; } <s> public static query parse ( string query string , bullet config config ) { query query = gson . from json ( query string , query . class ) ; query . configure ( config ) ; return query ; }"}
{"source": "the extension handler used by this svggraphics2 d instance <s> public extension handler get extension handler ( ) { return extension handler ; } <s> public extension handler get extension handler ( ) { return generator context . get extension handler ( ) ; }"}
{"source": "the hornet qconnection factory <s> public static hornet qconnection factory create connection factory without ha ( final discovery group configuration group configuration , jmsfactory type jms factory type ) { hornet qconnection factory factory = null ; if ( jms factory type . equals ( jmsfactory type . cf ) ) { factory = new hornet qjmsconnection factory ( false , group configuration ) ; } else if ( jms factory type . equals ( jmsfactory type . queue _ cf ) ) { factory = new hornet qqueue connection factory ( false , group configuration ) ; } else if ( jms factory type . equals ( jmsfactory type . topic _ cf ) ) { factory = new hornet qtopic connection factory ( false , group configuration ) ; } else if ( jms factory type . equals ( jmsfactory type . xa _ cf ) ) { factory = new hornet qxaconnection factory ( false , group configuration ) ; } else if ( jms factory type . equals ( jmsfactory type . queue _ xa _ cf ) ) { factory = new hornet qxaqueue connection factory ( false , group configuration ) ; } else if ( jms factory type . equals ( jmsfactory type . topic _ xa _ cf ) ) { factory = new hornet qxatopic connection factory ( false , group configuration ) ; } return factory ; } <s> public static active mqconnection factory create connection factory without ha ( final discovery group configuration group configuration , jmsfactory type jms factory type ) { active mqconnection factory factory = null ; if ( jms factory type . equals ( jmsfactory type . cf ) ) { factory = new active mqjmsconnection factory ( false , group configuration ) ; } else if ( jms factory type . equals ( jmsfactory type . queue _ cf ) ) { factory = new active mqqueue connection factory ( false , group configuration ) ; } else if ( jms factory type . equals ( jmsfactory type . topic _ cf ) ) { factory = new active mqtopic connection factory ( false , group configuration ) ; } else if ( jms factory type . equals ( jmsfactory type . xa _ cf ) ) { factory = new active mqxaconnection factory ( false , group configuration ) ; } else if ( jms factory type . equals ( jmsfactory type . queue _ xa _ cf ) ) { factory = new active mqxaqueue connection factory ( false , group configuration ) ; } else if ( jms factory type . equals ( jmsfactory type . topic _ xa _ cf ) ) { factory = new active mqxatopic connection factory ( false , group configuration ) ; } return factory ; }"}
{"source": "tuple containing the requested the geocoded field <s> private tuple do geo lookup ( final string ip ) throws exec exception { location location = null ; integer ip address type = determine ip address type ( ip ) ; tuple output = tuple factory . new tuple ( this . needed geo field names . size ( ) ) ; switch ( ip address type ) { case num : location = ip4 lookup . get location ( ip ) ; break ; case num : location = ip6 lookup . get location v6 ( ip ) ; break ; case num : warn ( str , pig warning . udf _ warning _ 1 ) ; return null ; default : warn ( str , pig warning . udf _ warning _ 1 ) ; return null ; } if ( location ! = null ) { int i = num ; string value = null ; for ( geo ip lookup field field : this . needed geo field names ) { switch ( field ) { case countrycode : value = location . country code ; break ; case continentcode : value = get continent code ( location . country code ) ; break ; case continentname : value = get continent name ( location . country code ) ; break ; case region : value = location . region ; break ; case city : value = location . city ; break ; case postalcode : value = location . postal code ; break ; case latitude : value = float . to string ( location . latitude ) ; break ; case longitude : value = float . to string ( location . longitude ) ; break ; case dmacode : value = integer . to string ( location . dma _ code ) ; break ; case areacode : value = integer . to string ( location . area _ code ) ; break ; case metrocode : value = integer . to string ( location . metro _ code ) ; break ; default : break ; } output . set ( i , value ) ; i + + ; } } else { warn ( str , pig warning . udf _ warning _ 3 ) ; return null ; } return output ; } <s> public final location do geo lookup ( final string ip ) { location location = null ; integer ip address type = determine ip address type ( ip ) ; switch ( ip address type ) { case num : location = ip4 lookup . get location ( ip ) ; break ; case num : location = ip6 lookup . get location v6 ( ip ) ; break ; default : break ; } return location ; }"}
{"source": "the type . <s> public static type value of ( string name ) { return null ; } <s> public static type < ? > value of ( string name ) { return mod the mod . get game ( ) . get type manager ( ) . get type ( name ) ; }"}
{"source": "the cloned bitmap reference without altering this instance <s> public synchronized closeable reference < bitmap > clone underlying bitmap reference ( ) { preconditions . check not null ( m bitmap reference , str ) ; return m bitmap reference . clone ( ) ; } <s> @ nullable public synchronized closeable reference < bitmap > clone underlying bitmap reference ( ) { return closeable reference . clone or null ( m bitmap reference ) ; }"}
{"source": "the habit at given position <s> @ non null public habit get habit by position ( int position ) { return data . habits . get ( position ) ; } <s> @ nullable public synchronized habit get habit by position ( int position ) { if ( position < num | | position > = data . habits . size ( ) ) return null ; return data . habits . get ( position ) ; }"}
{"source": "a vir error level <s> public vir error level get level ( ) { return level ; } <s> public error level get level ( ) { return level ; }"}
{"source": "a vir error domain <s> public vir error domain get domain ( ) { return domain ; } <s> public error domain get domain ( ) { return domain ; }"}
{"source": "login details instance corresponding to the given login details class . null if no such id found . <s> @ json ignore @ suppress warnings ( str ) @ nullable public < t extends login details > login details get login details ( class < t > login details class ) { return maps . unique index ( this . login details , new function < login details , class < login details > > ( ) { @ override public class < login details > apply ( @ nullable login details login details ) { if ( login details ! = null ) { return ( class < login details > ) login details . get class ( ) ; } return null ; } } ) . get ( login details class ) ; } <s> @ json ignore @ suppress warnings ( str ) @ nullable public < t extends credentials > credentials get login details ( class < t > login details class ) { return maps . unique index ( this . credentials , new function < credentials , class < credentials > > ( ) { @ override public class < credentials > apply ( @ nullable credentials credentials ) { if ( credentials ! = null ) { return ( class < credentials > ) credentials . get class ( ) ; } return null ; } } ) . get ( login details class ) ; }"}
{"source": "the collection the x _ ad _ replication document <s> public collection < x _ ad _ replication document > get replication documents ( ) { string where clause = str ; return new query ( get ctx ( ) , x _ ad _ replication document . table _ name , where clause , get _ trx name ( ) ) . set client _ id ( ) . set parameters ( get ad _ replication strategy _ id ( ) ) . set only active records ( true ) . set apply access filter ( false ) . list ( ) ; } <s> public list < x _ ad _ replication document > get replication documents ( ) { final string where clause = i _ ad _ replication document . columnname _ ad _ replication strategy _ id + str ; return new query ( get ctx ( ) , i _ ad _ replication document . table _ name , where clause , get _ trx name ( ) ) . set client _ id ( ) . set parameters ( get ad _ replication strategy _ id ( ) ) . set only active records ( true ) . set apply access filter ( false ) . list ( ) ; }"}
{"source": "a new string containing the lowercase characters equivalent to the characters in this string . <s> public string to lower case ( ) { return to lower case ( locale . get default ( ) ) ; } <s> public string to lower case ( ) { return case mapper . to lower case ( locale . get default ( ) , this , value , offset , count ) ; }"}
{"source": "if d , l conditions are met , send stream event output with extrema type , actual _ l ( distance at which a value satisfying d condition is found ) , actual _ l ( distance at which a value satisfying d condition is found ) <s> private stream event find if actual min ( attribute details latest event ) { int index current min = value stack . index of ( current min ) ; int actual _ l = value stack . index of ( latest event ) - index current min ; if ( actual _ l > l ) { current min . not eligible for real min ( ) ; return null ; } int actual _ l = num ; double d threshold = current min . get value ( ) + current min . get value ( ) * d / num ; while ( actual _ l < = l & & index current min - actual _ l > = num ) { if ( value stack . get ( index current min - actual _ l ) . get value ( ) > = d threshold ) { stream event output event = event stack . get ( index current min ) ; complex event populater . populate complex event ( output event , new object [ ] { str , actual _ l , actual _ l } ) ; current min . sent output as real min ( ) ; return output event ; } + + actual _ l ; } current min . not eligible for real min ( ) ; return null ; } <s> private stream event find if actual min ( attribute details latest event ) { int index current min = value stack . index of ( current min ) ; int post bound = value stack . index of ( latest event ) - index current min ; if ( post bound > max post bound ) { current min . not eligible for real min ( ) ; return null ; } if ( max pre bound = = num ) { stream event output event = event stack . get ( index current min ) ; complex event populater . populate complex event ( output event , new object [ ] { str , num , post bound } ) ; current min . sent output as real min ( ) ; return output event ; } int pre bound = num ; double d threshold = current min . get value ( ) + current min . get value ( ) * pre bound change / num ; while ( pre bound < = max pre bound & & index current min - pre bound > = num ) { if ( value stack . get ( index current min - pre bound ) . get value ( ) > = d threshold ) { stream event output event = event stack . get ( index current min ) ; complex event populater . populate complex event ( output event , new object [ ] { str , pre bound , post bound } ) ; current min . sent output as real min ( ) ; return output event ; } + + pre bound ; } current min . not eligible for real min ( ) ; return null ; }"}
{"source": "adempiere color or null <s> public compiere color get color ( ) { if ( m _ vo . ad _ color _ id = = num ) return null ; mcolor mc = new mcolor ( m _ vo . ctx , m _ vo . ad _ color _ id , null ) ; return mc . get adempiere color ( ) ; } <s> public mcolor get color ( ) { if ( m _ vo . ad _ color _ id = = num ) return null ; mcolor mc = new mcolor ( m _ vo . ctx , m _ vo . ad _ color _ id , null ) ; return mc ; }"}
{"source": "the extended fluent pipeline <s> public t label ( ) { return this . add ( new label pipe ( ) ) ; } <s> public gremlin pipeline < s , string > label ( ) { return this . add ( new label pipe ( ) ) ; }"}
{"source": "the prior count <s> public long reset ( ) { final long prior count = count ; count = num ; return prior count ; } <s> public nvp < long , double > reset ( final long new start ms , final long new count ) { final long [ ] prior window = time _ window _ updater . get and set ( this , window range from ms ( new start ms , window width ) ) ; final long prior count = count ; count = new count ; return new nvp < long , double > ( prior window [ num ] , calc rate ( prior count , window width ) ) ; }"}
{"source": "- 1 if the value is not valid <s> public static int get mode value ( string mode ) { if ( mode = = null ) return - num ; mode = mode . trim ( ) . to lower case ( ) ; if ( mode . index of ( str ) = = - num ) { if ( str . equals ( mode ) ) { return mode _ insert ; } else if ( str . equals ( mode ) ) { return mode _ update ; } else { return - num ; } } else { list l = string util . string to list ( mode , str ) ; string first = ( string ) l . get ( num ) ; string second = ( string ) l . get ( num ) ; if ( str . equals ( first ) & & str . equals ( second ) ) { return mode _ insert _ update ; } else if ( str . equals ( first ) & & str . equals ( second ) ) { return mode _ update _ insert ; } else { return - num ; } } } <s> public static import mode get mode value ( string mode ) { if ( mode = = null ) return null ; mode = mode . trim ( ) . to lower case ( ) ; if ( mode . index of ( str ) = = - num ) { if ( str . equals ( mode ) ) { return import mode . insert ; } else if ( str . equals ( mode ) ) { return import mode . update ; } else { return null ; } } else { list l = string util . string to list ( mode , str ) ; string first = ( string ) l . get ( num ) ; string second = ( string ) l . get ( num ) ; if ( str . equals ( first ) & & str . equals ( second ) ) { return import mode . insert update ; } else if ( str . equals ( first ) & & str . equals ( second ) ) { return import mode . update insert ; } else { return null ; } } }"}
{"source": "a list of registered font icon sets . <s> public static list < font icon set > get registered icon sets ( ) { return font _ icon _ set _ list ; } <s> public static collection < icon set > get registered icon sets ( ) { return registered _ icon _ sets . values ( ) ; }"}
{"source": "the loop bound limit or - 1 if no annotation was found or the annotation was erroneous <s> public static int calculate wca ( string wca a ) { int ai = wca a . index of ( str ) ; if ( ai ! = - num ) { string c = wca a . substring ( ai + str . length ( ) ) ; pattern pattern = pattern . compile ( str ) ; matcher matcher = pattern . matcher ( c ) ; if ( ! matcher . matches ( ) ) { logger . error ( str + c + str ) ; return - num ; } int val = integer . parse int ( matcher . group ( num ) ) ; return val ; } return - num ; } <s> public static loop bound calculate wca ( string wca a ) throws bad annotation exception { int ai = wca a . index of ( str ) ; if ( ai ! = - num ) { string annot string = wca a . substring ( ai + str . length ( ) ) ; if ( annot string . index of ( str ) < num ) return null ; pattern pattern1 = pattern . compile ( str ) ; pattern pattern2 = pattern . compile ( str ) ; matcher matcher1 = pattern1 . matcher ( annot string ) ; if ( matcher1 . matches ( ) ) { int ub = integer . parse int ( matcher1 . group ( num ) ) ; int lb = ( matcher1 . group ( num ) . equals ( str ) ) ? ub : num ; return new loop bound ( lb , ub ) ; } matcher matcher2 = pattern2 . matcher ( annot string ) ; if ( matcher2 . matches ( ) ) { int lb = integer . parse int ( matcher2 . group ( num ) ) ; int ub = integer . parse int ( matcher2 . group ( num ) ) ; return new loop bound ( lb , ub ) ; } throw new bad annotation exception ( str + annot string ) ; } return null ; }"}
{"source": "the content length of the request , or null if it has not been set <s> public long get request content length ( ) { string content length string = request headers . get first ( headers . content _ length ) ; if ( content length string = = null ) { return null ; } return long . parse long ( content length string ) ; } <s> public long get request content length ( ) { string content length string = request headers . get first ( headers . content _ length ) ; if ( content length string = = null ) { return - num ; } return long . parse long ( content length string ) ; }"}
{"source": "vir network object <s> public vir network get net ( ) throws vir error exception { throw new vir error exception ( str ) ; } <s> public network get net ( ) throws error exception { throw new error exception ( str ) ; }"}
{"source": "the running <s> public atomic boolean get running ( ) { return running ; } <s> @ managed attribute ( description = str ) public boolean get running ( ) { return running . get ( ) ; }"}
{"source": "all warnings of this package <s> public collection < warning > get warnings ( ) { return project . get warnings ( package name ) ; } <s> public set < warning > get warnings ( ) { return collections . unmodifiable set ( project . get warnings ( package name ) ) ; }"}
{"source": "value between 0 and 2000 <s> public int get rotation ( ) { return this . current rotation ; } <s> public int get rotation ( ) { double angle = new integer ( current rotation ) . double value ( ) / new integer ( settings . get handler rotation ( ) ) . double value ( ) ; angle * = num ; return angle . int value ( ) ; }"}
{"source": "the number of bytes uploaded <s> public long get num bytes uploaded ( ) { return bytes uploaded ; } <s> @ deprecated public long get num bytes uploaded ( ) { return total bytes server received ; }"}
{"source": "a list with workbench . db . column identifier objects <s> public list < column identifier > get columns ( table identifier tbl ) { string schema = get schema to use ( tbl . get schema ( ) ) ; if ( this . objects . size ( ) = = num | | ! schemas in cache . contains ( schema = = null ? null _ schema : schema ) ) { this . get tables ( schema ) ; } table identifier to search = tbl . create copy ( ) ; to search . adjust case ( db connection ) ; if ( to search . get schema ( ) = = null ) { to search . set schema ( schema ) ; } list < column identifier > cols = this . objects . get ( to search ) ; if ( retrieve oracle public synonyms & & to search . get schema ( ) ! = null & & cols = = null ) { to search . set schema ( null ) ; to search . set type ( null ) ; cols = this . objects . get ( to search ) ; if ( cols = = null ) { this . get tables ( str ) ; cols = this . objects . get ( to search ) ; } } if ( collection util . is empty ( cols ) ) { table identifier tbl to use = null ; if ( objects . contains key ( to search ) ) { tbl to use = find entry ( to search ) ; } else { tbl to use = this . db connection . get metadata ( ) . find object ( to search ) ; } try { cols = this . db connection . get metadata ( ) . get table columns ( tbl to use ) ; } catch ( throwable e ) { log mgr . log error ( str , str + tbl to use , e ) ; cols = null ; } if ( tbl to use ! = null & & collection util . is non empty ( cols ) ) { this . objects . put ( tbl to use , cols ) ; } } return collections . unmodifiable list ( cols ) ; } <s> public synchronized list < column identifier > get columns ( table identifier tbl ) { string schema = get schema to use ( tbl . get schema ( ) ) ; table identifier to search = tbl . create copy ( ) ; to search . adjust case ( db connection ) ; if ( to search . get schema ( ) = = null ) { to search . set schema ( schema ) ; } list < column identifier > cols = this . objects . get ( to search ) ; if ( cols = = null ) { try { table definition def = db connection . get metadata ( ) . get table definition ( to search ) ; add table ( def ) ; } catch ( sqlexception sql ) { log mgr . log warning ( str , str , sql ) ; return null ; } } if ( retrieve oracle public synonyms & & to search . get schema ( ) ! = null & & cols = = null ) { to search . set schema ( null ) ; to search . set type ( null ) ; cols = this . objects . get ( to search ) ; if ( cols = = null ) { this . get tables ( str ) ; cols = this . objects . get ( to search ) ; } } if ( collection util . is empty ( cols ) ) { table identifier tbl to use = null ; if ( objects . contains key ( to search ) ) { tbl to use = find entry ( to search ) ; } else { tbl to use = this . db connection . get metadata ( ) . find object ( to search ) ; } try { cols = this . db connection . get metadata ( ) . get table columns ( tbl to use ) ; } catch ( throwable e ) { log mgr . log error ( str , str + tbl to use , e ) ; cols = null ; } if ( tbl to use ! = null & & collection util . is non empty ( cols ) ) { this . objects . put ( tbl to use , cols ) ; } } return collections . unmodifiable list ( cols ) ; }"}
{"source": "project files in that directory , sorted alphabetically . <s> private file [ ] get project files ( file directory ) { file [ ] files = directory . list files ( new file filter ( ) { public boolean accept ( file file ) { return ( file . is file ( ) & & file . get name ( ) . ends with ( str ) ) ; } } ) ; switch ( explorer table sort column ) { case num : case num : case num : default : } selected file = - num ; if ( get project ( ) ! = null ) for ( int n = num ; n < files . length ; n + + ) if ( get project ( ) . get file ( ) . equals ( files [ n ] ) ) selected file = n ; return files ; } <s> private file [ ] get project files ( file directory ) { return directory . list files ( new file filter ( ) { public boolean accept ( file file ) { return ( file . is file ( ) & & file . get name ( ) . ends with ( str ) ) ; } } ) ; }"}
{"source": "input stream for reading from the socket . <s> public static input stream get input stream ( socket socket , long timeout ) throws ioexception { return ( socket . get channel ( ) = = null ) ? socket . get input stream ( ) : new socket input stream ( socket , timeout ) ; } <s> public static socket input wrapper get input stream ( socket socket , long timeout ) throws ioexception { input stream stm = ( socket . get channel ( ) = = null ) ? socket . get input stream ( ) : new socket input stream ( socket ) ; socket input wrapper w = new socket input wrapper ( socket , stm ) ; w . set timeout ( timeout ) ; return w ; }"}
{"source": "the list of ids within the history ids list or an empty list . <s> public string [ ] get history ( string history id ) { assert . is not null ( history id ) ; list < string > ids = history . get ( history id ) ; if ( ids = = null ) { ids = new array list < string > ( ) ; } return ids . to array ( new string [ ids . size ( ) ] ) ; } <s> public string [ ] get history ( string history id ) { assert . is not null ( history id ) ; list < string > entries = history . get ( history id ) ; if ( entries = = null ) { entries = new array list < string > ( ) ; } return entries . to array ( new string [ entries . size ( ) ] ) ; }"}
{"source": "all problems indexed by subdocuments names , ie empty if all ok . <s> public final map < string , string > validate sub documents ( ) { final ooxml ooxml = ooxml . get ( get version ( ) ) ; final map < string , string > res = new hash map < string , string > ( ) ; for ( final string s : subdoc names ) { if ( this . get entries ( ) . contains ( s ) ) { final string valid = ooxml . get validator ( this . get document ( s ) ) . is valid ( ) ; if ( valid ! = null ) res . put ( s , valid ) ; } } return res ; } <s> public final map < string , string > validate sub documents ( ) { final ooxml ooxml = this . get format version ( ) . get xml ( ) ; if ( ! ooxml . can validate ( ) ) return null ; final map < string , string > res = new hash map < string , string > ( ) ; for ( final string s : subdoc names ) { if ( this . get entries ( ) . contains ( s ) ) { final string valid = ooxml . get validator ( this . get document ( s ) ) . is valid ( ) ; if ( valid ! = null ) res . put ( s , valid ) ; } } return res ; }"}
{"source": "true iff the best matching content type has an identifier that matches content type id ; false otherwise . <s> private boolean test content type ( final ifile file , string content type id ) { final string expected value = content type id . trim ( ) ; string actual value = null ; try { icontent description content description = file . get content description ( ) ; if ( content description ! = null ) { icontent type content type = content description . get content type ( ) ; actual value = content type . get id ( ) ; } } catch ( core exception e ) { policy . log ( istatus . error , str , e ) ; } return expected value . equals ( actual value ) ; } <s> private boolean test content type ( final ifile file , string content type id , boolean is kind of used ) { final string expected value = content type id . trim ( ) ; icontent type actual content type = null ; try { icontent description content description = file . get content description ( ) ; if ( content description ! = null ) { actual content type = content description . get content type ( ) ; } } catch ( core exception e ) { policy . log ( istatus . error , str , e ) ; } if ( actual content type ! = null ) { if ( is kind of used ) { return actual content type . is kind of ( platform . get content type manager ( ) . get content type ( expected value ) ) ; } return expected value . equals ( actual content type . get id ( ) ) ; } return false ; }"}
{"source": "the extended fluent pipeline <s> public t map ( ) { return this . add ( new property map pipe ( ) ) ; } <s> public gremlin pipeline < s , map < string , object > > map ( ) { return this . add ( new property map pipe ( ) ) ; }"}
{"source": "the stored value or null if it doesn ' t exist in specified form . <s> public jsonobject get extra jsonobject ( string key ) { return m extra data . opt jsonobject ( key ) ; } <s> public jsonobject get extra jsonobject ( string key ) throws jsonexception { return m extra data . get jsonobject ( key ) ; }"}
{"source": "the node , null if no node could be found <s> node find new node ( final virtual host . host entry entry ) { return elect node ( entry . get contexts ( ) , false , null ) ; } <s> context find new node ( final virtual host . host entry entry ) { return elect node ( entry . get contexts ( ) , false , null ) ; }"}
{"source": "the vir connect object <s> public vir connect get connect ( ) { return vir connect ; } <s> public connect get connect ( ) { return vir connect ; }"}
{"source": "the value of the ' right ' css - attribute <s> public float get right value ( ) { return right value = = null ? num : right value . float value ( ) ; } <s> public float get right value ( ) { return right value ; }"}
