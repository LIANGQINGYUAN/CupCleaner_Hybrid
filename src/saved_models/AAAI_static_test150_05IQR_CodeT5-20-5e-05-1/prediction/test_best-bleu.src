{"source": "@param prefered <s> public static int availablePort(int prefered) {\n        int rtn = -1;\n        try {\n            rtn = tryPort(prefered);\n        } catch (IOException e) {\n\n        }\n        return rtn;\n    } <s> public static int availablePort(int preferred) {         int rtn = -1;         try {             rtn = tryPort(preferred);         } catch (IOException ignored) {         }         return rtn;     }"}
{"source": "@param global <s> public static SummaryEntry[] querySummaries(Variations variationPatterns, boolean global) {\n        return getDefault().internalQuerySummaries(variationPatterns, null);\n    } <s> public static SummaryEntry[] querySummaries(Variations variationPatterns, String scenarioPattern) {         return getDefault().internalQuerySummaries(variationPatterns, scenarioPattern);     }"}
{"source": "@param req the  HttpServletResponse <s> protected AtmosphereHandlerWrapper map(HttpServletRequest req) throws ServletException {\n        String path;\n        if (req.getPathInfo() != null) {\n            path = req.getServletPath() + req.getPathInfo();\n        } else {\n            path = req.getServletPath();\n        }\n        if (path == null || path.length() <= 1) {\n            path = \"/all\";\n        }\n\n        AtmosphereHandlerWrapper atmosphereHandlerWrapper = map(path);\n        if (atmosphereHandlerWrapper == null) {\n            atmosphereHandlerWrapper = map(\"/all\");\n        }\n\n        if (atmosphereHandlerWrapper == null) {\n            throw new AtmosphereMappingException(\"No AtmosphereHandler maps request for \" + path);\n        }\n        config.getBroadcasterFactory().add(atmosphereHandlerWrapper.broadcaster,\n                atmosphereHandlerWrapper.broadcaster.getID());\n        return atmosphereHandlerWrapper;\n    } <s> protected AtmosphereHandlerWrapper map(AtmosphereRequest req) throws ServletException {         String path;         if (req.getPathInfo() != null) {             path = req.getServletPath() + req.getPathInfo();         } else {             path = req.getServletPath();         }         if (path == null || path.length() <= 1) {             path = \"/all\";         }          AtmosphereHandlerWrapper atmosphereHandlerWrapper = map(path);         if (atmosphereHandlerWrapper == null) {             atmosphereHandlerWrapper = map(\"/all\");         }          if (atmosphereHandlerWrapper == null) {             throw new AtmosphereMappingException(\"No AtmosphereHandler maps request for \" + path);         }         config.getBroadcasterFactory().add(atmosphereHandlerWrapper.broadcaster,                 atmosphereHandlerWrapper.broadcaster.getID());         return atmosphereHandlerWrapper;     }"}
{"source": "@param context the annotation binding context with access to the service registry and the annotation index <s> public static Set<ConfiguredClassHierarchy<EntityClass>> createEntityHierarchies(AnnotationsBindingContext context) {\n\t\tClassLoaderService classLoaderService = context.getServiceRegistry().getService( ClassLoaderService.class );\n\t\tMap<ClassInfo, List<ClassInfo>> processedClassInfos = new HashMap<ClassInfo, List<ClassInfo>>();\n\n\t\tfor ( ClassInfo info : context.getIndex().getKnownClasses() ) {\n\t\t\tif ( !isEntityClass( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( processedClassInfos.containsKey( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tList<ClassInfo> configuredClassList = new ArrayList<ClassInfo>();\n\t\t\tClassInfo tmpClassInfo = info;\n\t\t\tClass<?> clazz = classLoaderService.classForName( tmpClassInfo.toString() );\n\t\t\twhile ( clazz != null && !clazz.equals( Object.class ) ) {\n\t\t\t\ttmpClassInfo = context.getIndex().getClassByName( DotName.createSimple( clazz.getName() ) );\n\t\t\t\tclazz = clazz.getSuperclass();\n\t\t\t\tif ( tmpClassInfo == null ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( existsHierarchyWithClassInfoAsLeaf( processedClassInfos, tmpClassInfo ) ) {\n\t\t\t\t\tList<ClassInfo> classInfoList = processedClassInfos.get( tmpClassInfo );\n\t\t\t\t\tfor ( ClassInfo tmpInfo : configuredClassList ) {\n\t\t\t\t\t\tclassInfoList.add( tmpInfo );\n\t\t\t\t\t\tprocessedClassInfos.put( tmpInfo, classInfoList );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfiguredClassList.add( 0, tmpClassInfo );\n\t\t\t\t\tprocessedClassInfos.put( tmpClassInfo, configuredClassList );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSet<ConfiguredClassHierarchy<EntityClass>> hierarchies = new HashSet<ConfiguredClassHierarchy<EntityClass>>();\n\t\tList<List<ClassInfo>> processedList = new ArrayList< <s> public static Set<ConfiguredClassHierarchy<EntityClass>> createEntityHierarchies(AnnotationsBindingContext bindingContext) { \t\tMap<ClassInfo, List<ClassInfo>> processedClassInfos = new HashMap<ClassInfo, List<ClassInfo>>();  \t\tfor ( ClassInfo info : bindingContext.getIndex().getKnownClasses() ) { \t\t\tif ( !isEntityClass( info ) ) { \t\t\t\tcontinue; \t\t\t}  \t\t\tif ( processedClassInfos.containsKey( info ) ) { \t\t\t\tcontinue; \t\t\t}  \t\t\tList<ClassInfo> configuredClassList = new ArrayList<ClassInfo>(); \t\t\tClassInfo tmpClassInfo = info; \t\t\tClass<?> clazz = bindingContext.locateClassByName( tmpClassInfo.toString() ); \t\t\twhile ( clazz != null && !clazz.equals( Object.class ) ) { \t\t\t\ttmpClassInfo = bindingContext.getIndex().getClassByName( DotName.createSimple( clazz.getName() ) ); \t\t\t\tclazz = clazz.getSuperclass(); \t\t\t\tif ( tmpClassInfo == null ) { \t\t\t\t\tcontinue; \t\t\t\t}  \t\t\t\tif ( existsHierarchyWithClassInfoAsLeaf( processedClassInfos, tmpClassInfo ) ) { \t\t\t\t\tList<ClassInfo> classInfoList = processedClassInfos.get( tmpClassInfo ); \t\t\t\t\tfor ( ClassInfo tmpInfo : configuredClassList ) { \t\t\t\t\t\tclassInfoList.add( tmpInfo ); \t\t\t\t\t\tprocessedClassInfos.put( tmpInfo, classInfoList ); \t\t\t\t\t} \t\t\t\t\tbreak; \t\t\t\t} \t\t\t\telse { \t\t\t\t\tconfiguredClassList.add( 0, tmpClassInfo ); \t\t\t\t\tprocessedClassInfos.put( tmpClassInfo, configuredClassList ); \t\t\t\t} \t\t\t} \t\t}  \t\tSet<ConfiguredClassHierarchy<EntityClass>> hierarchies = new HashSet<ConfiguredClassHierarchy<EntityClass>>(); \t\tList<List<ClassInfo>> processedList = new ArrayList<List<ClassInfo>>(); \t\tfor ( List<ClassInfo> classInfoList : processedClass"}
{"source": "@param body client model (required) <s> public Client testClientModel(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testClientModel\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      } <s> public Client testClientModel(Client client) throws ApiException {     Object localVarPostBody = client;          // verify the required parameter 'client' is set     if (client == null) {       throw new ApiException(400, \"Missing the required parameter 'client' when calling testClientModel\");     }          // create path and map variables     String localVarPath = \"/fake\";      // query params     List<Pair> localVarQueryParams = new ArrayList<Pair>();     List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();     Map<String, String> localVarHeaderParams = new HashMap<String, String>();     Map<String, Object> localVarFormParams = new HashMap<String, Object>();                 final String[] localVarAccepts = {       \"application/json\"     };     final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);      final String[] localVarContentTypes = {       \"application/json\"     };     final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);      String[] localVarAuthNames = new String[] {  };      GenericType<Client> localVarReturnType = new GenericType<Client>() {};     return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);       }"}
{"source": "@param file file to upload (required) <s> public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws ApiException {\n    Object localVarPostBody = new Object();\n    \n    // verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // verify the required parameter 'file' is set\n    if (file == null) {\n      throw new ApiException(400, \"Missing the required parameter 'file' when calling uploadFileWithRequiredFile\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake/{petId}/uploadImageWithRequiredFile\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    if (additionalMetadata != null)\n      localVarFormParams.put(\"additionalMetadata\", additionalMetadata);\nif (file != null)\n      localVarFormParams.put(\"file\", file);\n\n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"multipart/form-data\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      } <s> public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException {     Object localVarPostBody = new Object();          // verify the required parameter 'petId' is set     if (petId == null) {       throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");     }          // verify the required parameter 'requiredFile' is set     if (requiredFile == null) {       throw new ApiException(400, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\");     }          // create path and map variables     String localVarPath = \"/fake/{petId}/uploadImageWithRequiredFile\".replaceAll(\"\\\\{format\\\\}\",\"json\")       .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));      // query params     List<Pair> localVarQueryParams = new ArrayList<Pair>();     Map<String, String> localVarHeaderParams = new HashMap<String, String>();     Map<String, Object> localVarFormParams = new HashMap<String, Object>();            if (additionalMetadata != null)       localVarFormParams.put(\"additionalMetadata\", additionalMetadata); if (requiredFile != null)       localVarFormParams.put(\"requiredFile\", requiredFile);      final String[] localVarAccepts = {       \"application/json\"     };     final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);      final String[] localVarContentTypes = {       \"multipart/form-data\"     };     final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);      String[] localVarAuthNames = new String[] { \"petstore_auth\" };      GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};     return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);"}
{"source": "@param clazz <s> public Configuration setCacheConcurrencyStrategy(String clazz, String concurrencyStrategy)\n\t\t\tthrows MappingException {\n\t\tsetCacheConcurrencyStrategy( clazz, concurrencyStrategy, clazz );\n\t\treturn this;\n\t} <s> public Configuration setCacheConcurrencyStrategy(String entityName, String concurrencyStrategy) { \t\tsetCacheConcurrencyStrategy( entityName, concurrencyStrategy, entityName ); \t\treturn this; \t}"}
{"source": "@param req the  HttpServletRequest <s> public Action cancelled(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n\n        synchronized (req) {\n            AtmosphereResourceImpl r = null;\n            try {\n                if (trackActiveRequest) {\n                    long l = (Long) req.getAttribute(MAX_INACTIVE);\n                    if (l == -1) {\n                        // The closedDetector closed the connection.\n                        return timedoutAction;\n                    }\n                    req.setAttribute(MAX_INACTIVE, (long) -1);\n                }\n\n                logger.debug(\"Cancelling the connection for request {}\", req);\n\n                r = (AtmosphereResourceImpl) req.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n                if (r != null) {\n                    r.getAtmosphereResourceEvent().setCancelled(true);\n                    invokeAtmosphereHandler(r);\n\n                    try {\n                        r.getResponse().sendError(503);\n                        r.getResponse().getOutputStream().close();\n                    } catch (Throwable t) {\n                        try {\n                            r.getResponse().getWriter().close();\n                        } catch (Throwable t2) {\n                        }\n                    }\n                }\n            } catch (Throwable ex) {\n                // Something wrong happenned, ignore the exception\n                logger.debug(\"failed to cancel resource: \" + r, ex);\n            } finally {\n                try {\n                    if (r != null) {\n                        r.notifyListeners();\n                        r.setIsInScope(false);\n                        r.cancel();\n                    }\n                } catch (Throwable t) {\n                    logger.trace(\"cancel\", t);\n                } finally {\n                    if (r != null) {\n                        destroyResource(r);\n                    }\n                }\n            }\n        }\n\n        return cancelledAction;\n    } <s> public Action cancelled(AtmosphereRequest req, AtmosphereResponse res)             throws IOException, ServletException {          synchronized (req) {             AtmosphereResourceImpl r = null;             try {                 if (trackActiveRequest) {                     long l = (Long) req.getAttribute(MAX_INACTIVE);                     if (l == -1) {                         // The closedDetector closed the connection.                         return timedoutAction;                     }                     req.setAttribute(MAX_INACTIVE, (long) -1);                 }                  logger.debug(\"Cancelling the connection for request {}\", req);                  r = (AtmosphereResourceImpl) req.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);                 if (r != null) {                     r.getAtmosphereResourceEvent().setCancelled(true);                     invokeAtmosphereHandler(r);                      try {                         r.getResponse().sendError(503);                         r.getResponse().getOutputStream().close();                     } catch (Throwable t) {                         try {                             r.getResponse().getWriter().close();                         } catch (Throwable t2) {                         }                     }                 }             } catch (Throwable ex) {                 // Something wrong happenned, ignore the exception                 logger.debug(\"failed to cancel resource: \" + r, ex);             } finally {                 try {                     if (r != null) {                         r.notifyListeners();                         r.setIsInScope(false);                         r.cancel();                     }                 } catch (Throwable t) {                     logger.trace(\"cancel\", t);                 } finally {                     if (r != null) {                         destroyResource(r);                     }                 }             }         }          return cancelledAction;     }"}
{"source": "@param operator operator <s> public static BooleanOperation predicate(Operator operator, Expression<?>... args) {\n        return new BooleanOperation(operator, args);\n    } <s> public static BooleanOperation predicate(Operator operation, Expression<?>... args) {         return new BooleanOperation(operation, args);     }"}
{"source": "@param file file to upload (required) <s> public ApiResponse<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File file, String additionalMetadata) throws ApiException {\n        com.squareup.okhttp.Call call = uploadFileWithRequiredFileValidateBeforeCall(petId, file, additionalMetadata, null, null);\n        Type localVarReturnType = new TypeToken<ModelApiResponse>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    } <s> public ApiResponse<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File requiredFile, String additionalMetadata) throws ApiException {         com.squareup.okhttp.Call call = uploadFileWithRequiredFileValidateBeforeCall(petId, requiredFile, additionalMetadata, null, null);         Type localVarReturnType = new TypeToken<ModelApiResponse>(){}.getType();         return apiClient.execute(call, localVarReturnType);     }"}
{"source": "@param strings Expected expressions <s> private static Consumer<List> mongoChecker(final String... strings) {\n    return actual -> {\n      Object[] actualArray =\n          actual == null || actual.isEmpty()\n              ? null\n              : ((List) actual.get(0)).toArray();\n      CalciteAssert.assertArrayEqual(\"expected MongoDB query not found\",\n          strings, actualArray);\n    };\n  } <s> private static Consumer<List> mongoChecker(final String... expected) {     return actual -> {       if (expected == null) {         Assert.assertThat(\"null mongo Query\", actual, CoreMatchers.nullValue());         return;       }        if (expected.length == 0) {         CalciteAssert.assertArrayEqual(\"empty Mongo query\", expected,             actual.toArray(new Object[0]));         return;       }        final BsonDocument expectedBson = BsonDocument.parse(String.join(\",\", expected));       final BsonDocument actualBson = BsonDocument.parse(((List<?>) actual.get(0))           .stream()           .map(Objects::toString)           .collect(Collectors.joining(\"\\n\")));        // compare Bson (not string) representation       if (!expectedBson.equals(actualBson)) {         final JsonWriterSettings settings = JsonWriterSettings.builder().indent(true).build();         // used to pretty print Assertion error         Assert.assertEquals(\"expected and actual Mongo queries do not match\",             expectedBson.toJson(settings),             actualBson.toJson(settings));         Assert.fail(\"Should have failed previously because (expected != actual) is already known\");       }     };   }"}
{"source": "@param body client model (required) <s> public ApiResponse<Client> testClassnameWithHttpInfo(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testClassname\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/fake_classname_test\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"api_key_query\" };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      } <s> public ApiResponse<Client> testClassnameWithHttpInfo(Client client) throws ApiException {     Object localVarPostBody = client;          // verify the required parameter 'client' is set     if (client == null) {       throw new ApiException(400, \"Missing the required parameter 'client' when calling testClassname\");     }          // create path and map variables     String localVarPath = \"/fake_classname_test\";      // query params     List<Pair> localVarQueryParams = new ArrayList<Pair>();     Map<String, String> localVarHeaderParams = new HashMap<String, String>();     Map<String, Object> localVarFormParams = new HashMap<String, Object>();                 final String[] localVarAccepts = {       \"application/json\"     };     final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);      final String[] localVarContentTypes = {       \"application/json\"     };     final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);      String[] localVarAuthNames = new String[] { \"api_key_query\" };      GenericType<Client> localVarReturnType = new GenericType<Client>() {};     return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);       }"}
{"source": "@param body order placed for purchasing the pet <s> public Order placeOrder(Order body, Map<String, Object> params) throws IOException {\n        HttpResponse response = placeOrderForHttpResponse(body, params);\n        TypeReference typeRef = new TypeReference<Order>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    } <s> public Order placeOrder(Order order, Map<String, Object> params) throws IOException {         HttpResponse response = placeOrderForHttpResponse(order, params);         TypeReference typeRef = new TypeReference<Order>() {};         return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);     }"}
{"source": "@param property Property to get example string for <s> protected String getExample(Property property) {\n        if (property.getExample() != null) {\n            return property.getExample().toString();\n        } else if (property instanceof DateTimeProperty) {\n            return \"2000-01-23T04:56:07.000Z\";\n        } else if (property instanceof DateProperty) {\n            return \"2000-01-23\";\n        } else if (property instanceof BooleanProperty) {\n            return \"true\";\n        } else if (property instanceof LongProperty) {\n            return \"123456789\";\n        } else if (property instanceof DoubleProperty) { // derived from DecimalProperty so make sure this is first\n            return \"3.149\";\n        }  else if (property instanceof DecimalProperty) {\n            return \"1.3579\";\n        } else if (property instanceof PasswordProperty) {\n            return \"********\";\n        } else if (property instanceof UUIDProperty) {\n            return \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\";\n        // do these last in case the specific types above are derived from these classes\n        } else if (property instanceof StringProperty) {\n            return \"aeiou\";\n        } else if (property instanceof BaseIntegerProperty) {\n            return \"123\";\n        } else if (property instanceof AbstractNumericProperty) {\n            return \"1.23\";\n        }\n        LOGGER.warn(\"default example value not implemented for \" + property);\n        return \"\";\n    } <s> protected String getExample(Schema schema) {         if (schema.getExample() != null) {             return schema.getExample().toString();         } else if (ModelUtils.isDateTimeSchema(schema)) {             return \"2000-01-23T04:56:07.000Z\";         } else if (ModelUtils.isDateSchema(schema)) {             return \"2000-01-23\";         } else if (ModelUtils.isBooleanSchema(schema)) {             return \"true\";         } else if (ModelUtils.isNumberSchema(schema)) {             if (ModelUtils.isFloatSchema(schema)) { // float                 return \"1.3579\";             } else { // double                 return \"3.149\";             }         } else if (ModelUtils.isPasswordSchema(schema)) {             return \"********\";         } else if (ModelUtils.isUUIDSchema(schema)) {             return \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\";             // do these last in case the specific types above are derived from these classes         } else if (ModelUtils.isStringSchema(schema)) {             return \"aeiou\";         } else if (ModelUtils.isIntegerSchema(schema)) {             if (ModelUtils.isLongSchema(schema)) { // long                 return \"123456789\";             } else { //integer                 return \"123\";             }         } else {             LOGGER.debug(\"default example value not implemented for {}. Default to UNDEFINED_EXAMPLE_VALUE\", schema);             return \"UNDEFINED_EXAMPLE_VALUE\";         }     }"}
{"source": "@param channel <s> private ByteBuffer read(SocketChannel channel, int length) throws IOException {\n\t\t\tByteBuffer buffer = ByteBuffer.allocate(length);\n\t\t\t\n\t\t\tint bytesRead = 0;\n\t\t\tdo {\n\t\t\t\tbytesRead += channel.read(buffer);\n\t\t\t} while (length != bytesRead);\n\t\t\t\n\t\t\tbuffer.flip();\n\t\t\t\n\t\t\tint freeSpace = currentFrame.capacity() - currentFrame.position();\n\t\t\tif (freeSpace < bytesRead) {\n\t\t\t\tcurrentFrame = reallocate(currentFrame, currentFrame.position() + bytesRead);\n\t\t\t}\n\n\t\t\t// add bytes to current frame and reset to be able to read again\n\t\t\tcurrentFrame.put(buffer);\n\t\t\tbuffer.rewind();\n\t\t\t\n\t\t\treturn buffer;\n\t\t} <s> private byte[] read(InputStream in, int length) throws IOException { \t\t\tbyte[] buffer = new byte[length]; \t\t\t \t\t\tint bytesRead = 0; \t\t\tdo { \t\t\t\tbytesRead += in.read(buffer); \t\t\t} while (length != bytesRead); \t\t\t \t\t\tint freeSpace = currentFrame.capacity() - currentFrame.position(); \t\t\tif (freeSpace < bytesRead) { \t\t\t\tcurrentFrame = reallocate(currentFrame, currentFrame.position() + bytesRead); \t\t\t}  \t\t\t// add bytes to current frame and reset to be able to read again \t\t\tcurrentFrame.put(buffer); \t\t\t \t\t\treturn buffer; \t\t}"}
{"source": "@param aliasedLockOptions a map of lock options indexed by aliased table names. <s> public String applyLocksToSql(String sql, Map aliasedLockOptions, Map keyColumnNames) {\n\t\treturn sql + new ForUpdateFragment( this, aliasedLockOptions, keyColumnNames ).toFragmentString();\n\t} <s> public String applyLocksToSql(String sql, LockOptions aliasedLockOptions, Map keyColumnNames) { \t\treturn sql + new ForUpdateFragment( this, aliasedLockOptions, keyColumnNames ).toFragmentString(); \t}"}
{"source": "@param te is the typeEntry from the Parameters object, which represents the parameter <s> public static QName getXSIType(TypeEntry te) {\n        QName xmlType = null;\n\n        // If the TypeEntry describes an Element, get\n        // the referenced Type.\n        if (te != null &&\n            te instanceof Element &&\n            te.getRefType() != null) {\n            te = te.getRefType();\n        } \n        // If the TypeEntry is a CollectionType, use\n        // the TypeEntry representing the component Type\n        // So for example a parameter that takes a \n        // collection type for\n        // <element name=\"A\" type=\"xsd:string\" maxOccurs=\"unbounded\"/>\n        // will be \n        // new ParameterDesc(<QName of A>, IN,\n        //                   <QName of xsd:string>,\n        //                   String[])\n        if (te != null &&\n            te instanceof CollectionType &&\n            te.getRefType() != null) {\n            te = te.getRefType();\n        }\n        if (te != null) {\n            xmlType = te.getQName();\n        }\n        return xmlType;\n    } <s> public static QName getXSIType(Parameter param) {         if (param.getMIMEType() != null) {             return getMIMETypeQName(param.getMIMEType());         }          QName xmlType = null;         TypeEntry te = param.getType();          // If the TypeEntry describes an Element, get         // the referenced Type.         if (te != null &&             te instanceof Element &&             te.getRefType() != null) {             te = te.getRefType();         }          // If the TypeEntry is a CollectionType, use         // the TypeEntry representing the component Type         // So for example a parameter that takes a          // collection type for         // <element name=\"A\" type=\"xsd:string\" maxOccurs=\"unbounded\"/>         // will be          // new ParameterDesc(<QName of A>, IN,         //                   <QName of xsd:string>,         //                   String[])         if (te != null &&             te instanceof CollectionType &&             te.getRefType() != null) {             te = te.getRefType();         }         if (te != null) {             xmlType = te.getQName();         }         return xmlType;     }"}
{"source": "@param user (User) Updated user object (required) <s> public UpdateUserOper body(User user) {\n            reqSpec.setBody(user);\n            return this;\n        } <s> public UpdateUserOper body(User body) {             reqSpec.setBody(body);             return this;         }"}
{"source": "@param length the new length <s> public Duration withMillis(long length) {\n        if (length == getMillis()) {\n            return this;\n        }\n        return new Duration(length);\n    } <s> public Duration withMillis(long duration) {         if (duration == getMillis()) {             return this;         }         return new Duration(duration);     }"}
{"source": "@param body Input boolean as post body (optional) <s> public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // create path and map variables\n    String localVarPath = \"/fake/outer/boolean\";\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      } <s> public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws ApiException {     Object localVarPostBody = booleanPostBody;          // create path and map variables     String localVarPath = \"/fake/outer/boolean\";      // query params     List<Pair> localVarQueryParams = new ArrayList<Pair>();     List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();     Map<String, String> localVarHeaderParams = new HashMap<String, String>();     Map<String, Object> localVarFormParams = new HashMap<String, Object>();                 final String[] localVarAccepts = {       \"*/*\"     };     final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);      final String[] localVarContentTypes = {            };     final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);      String[] localVarAuthNames = new String[] {  };      GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};     return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);       }"}
{"source": "@param dataBufferRef Next set of bytes received by the caller <s> public boolean parseMoreData(final CloseableReference<PooledByteBuffer> dataBufferRef) {\n    if (mParserState == NOT_A_JPEG) {\n      return false;\n    }\n\n    final PooledByteBuffer dataBuffer = dataBufferRef.get();\n    final int dataBufferSize = dataBuffer.size();\n\n    // Is there any new data to parse?\n    // mBytesParsed might be greater than size of dataBuffer - that happens when\n    // we skip more data than is available to read inside doParseMoreData method\n    if (dataBufferSize <= mBytesParsed) {\n      return false;\n    }\n\n    final InputStream bufferedDataStream = new PooledByteArrayBufferedInputStream(\n        new PooledByteBufferInputStream(dataBuffer),\n        mByteArrayPool.get(BUFFER_SIZE),\n        mByteArrayPool);\n    try {\n      StreamUtil.skip(bufferedDataStream, mBytesParsed);\n      return doParseMoreData(bufferedDataStream);\n    } catch (IOException ioe) {\n      // Does not happen - streams returned by PooledByteBuffers do not throw IOExceptions\n      Throwables.propagate(ioe);\n      return false;\n    } finally {\n      Closeables.closeQuietly(bufferedDataStream);\n    }\n  } <s> public boolean parseMoreData(final EncodedImage encodedImage) {     if (mParserState == NOT_A_JPEG) {       return false;     }      final int dataBufferSize = encodedImage.getSize();      // Is there any new data to parse?     // mBytesParsed might be greater than size of dataBuffer - that happens when     // we skip more data than is available to read inside doParseMoreData method     if (dataBufferSize <= mBytesParsed) {       return false;     }      final InputStream bufferedDataStream = new PooledByteArrayBufferedInputStream(         encodedImage.getInputStream(),         mByteArrayPool.get(BUFFER_SIZE),         mByteArrayPool);     try {       StreamUtil.skip(bufferedDataStream, mBytesParsed);       return doParseMoreData(bufferedDataStream);     } catch (IOException ioe) {       // Does not happen - streams returned by PooledByteBuffers do not throw IOExceptions       Throwables.propagate(ioe);       return false;     } finally {       Closeables.closeQuietly(bufferedDataStream);     }   }"}
{"source": "@param field field should operate in UTC or be time zone agnostic <s> public DateTimeFormatterBuilder appendShortText(final DateTimeField field) {\n        return append0(new TextField(iChrono, field, iLocale, true));\n    } <s> public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {         if (fieldType == null) {             throw new IllegalArgumentException(\"Field type must not be null\");         }         DateTimeField field = fieldType.getField(iChronoUTC);         return append0(new TextField(iChrono, field, iLocale, true));     }"}
{"source": "@param body List of user object <s> public void createUsersWithArrayInput (List<User> body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = body;\n    // verify the required parameter 'body' is set\n    if (body == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'body' when calling createUsersWithArrayInput\",\n        new ApiException(400, \"Missing the required parameter 'body' when calling createUsersWithArrayInput\"));\n    }\n\n    // create path and map variables\n    String path = \"/user/createWithArray\";\n\n    // query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    // header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    // form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";\n\n    if (contentType.startsWith(\"multipart/form-data\")) {\n      // file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      // normal form params\n    }\n\n    String[] authNames = new String[] {  };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        } <s> public void createUsersWithArrayInput (List<User> user) throws TimeoutException, ExecutionException, InterruptedException, ApiException {     Object postBody = user;     // verify the required parameter 'user' is set     if (user == null) {       VolleyError error = new VolleyError(\"Missing the required parameter 'user' when calling createUsersWithArrayInput\",         new ApiException(400, \"Missing the required parameter 'user' when calling createUsersWithArrayInput\"));     }      // create path and map variables     String path = \"/user/createWithArray\";      // query params     List<Pair> queryParams = new ArrayList<Pair>();     // header params     Map<String, String> headerParams = new HashMap<String, String>();     // form params     Map<String, String> formParams = new HashMap<String, String>();     String[] contentTypes = {     };     String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application/json\";      if (contentType.startsWith(\"multipart/form-data\")) {       // file uploading       MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();       HttpEntity httpEntity = localVarBuilder.build();       postBody = httpEntity;     } else {       // normal form params     }      String[] authNames = new String[] {  };      try {       String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);       if (localVarResponse != null) {          return ;       } else {          return ;       }     } catch (ApiException ex) {        throw ex;     } catch (InterruptedException ex) {        throw ex;     } catch (ExecutionException ex) {       if (ex.getCause() instanceof VolleyError) {         VolleyError volleyError = (VolleyError)ex.getCause();         if (volleyError.networkResponse != null) {           throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());         }"}
{"source": "@param v the long to examine. <s> public static int numberOfLeadingZeros(long v) {\n        // After Hacker's Delight, Figure 5-6\n        if (v < 0) {\n            return 0;\n        }\n        if (v == 0) {\n            return 64;\n        }\n        // On a 64-bit VM, the two previous tests should probably be replaced by\n        // if (v <= 0) return ((int) (~v >> 57)) & 64;\n\n        int n = 1;\n        int i = (int) (v >>> 32);\n        if (i == 0) {\n            n +=  32;\n            i = (int) v;\n        }\n        if (i >>> 16 == 0) {\n            n +=  16;\n            i <<= 16;\n        }\n        if (i >>> 24 == 0) {\n            n +=  8;\n            i <<= 8;\n        }\n        if (i >>> 28 == 0) {\n            n +=  4;\n            i <<= 4;\n        }\n        if (i >>> 30 == 0) {\n            n +=  2;\n            i <<= 2;\n        }\n        return n - (i >>> 31);\n    } <s> public static int numberOfLeadingZeros(long lng) {         lng |= lng >> 1;         lng |= lng >> 2;         lng |= lng >> 4;         lng |= lng >> 8;         lng |= lng >> 16;         lng |= lng >> 32;         return bitCount(~lng);     }"}
{"source": "@param clause clause <s> public SQLInsertClause insertOnDuplicateKeyUpdate(RelationalPath<?> entity, Expression<?> clause) {\n        SQLInsertClause insert = insert(entity);\n        insert.addFlag(Position.END, ExpressionUtils.template(String.class, \" on duplicate key update {0}\", clause));\n        return insert;\n    } <s> public SQLInsertClause insertOnDuplicateKeyUpdate(RelationalPath<?> entity, Expression<?>... clauses) {         SQLInsertClause insert = insert(entity);         StringBuilder flag = new StringBuilder(\" on duplicate key update \");         for (int i = 0; i < clauses.length; i++) {             flag.append(i > 0 ? \", \" : \"\").append(\"{\" + i + \"}\");         }         insert.addFlag(Position.END, ExpressionUtils.template(String.class, flag.toString(), clauses));         return insert;     }"}
{"source": "@param p Swagger Property object <s> public String getTypeDeclaration(Property p) {\n        if (p instanceof ArrayProperty) {\n            ArrayProperty ap = (ArrayProperty) p;\n            Property inner = ap.getItems();\n            return getTypeDeclaration(inner) + \"[]\";\n        } else if (p instanceof MapProperty) {\n            MapProperty mp = (MapProperty) p;\n            Property inner = mp.getAdditionalProperties();\n            // TODO not sure if the following map/hash declaration is correct\n            return \"{String, \" + getTypeDeclaration(inner) + \"}\";\n        } else if (!languageSpecificPrimitives.contains(getSwaggerType(p))) {\n            return packageName + \".Model.\" + super.getTypeDeclaration(p);\n        }\n        return super.getTypeDeclaration(p);\n    } <s> public String getTypeDeclaration(Schema p) {         if (ModelUtils.isArraySchema(p)) {             ArraySchema ap = (ArraySchema) p;             Schema inner = ap.getItems();             return getTypeDeclaration(inner) + \"[]\";         } else if (ModelUtils.isMapSchema(p)) {             Schema inner = (Schema) p.getAdditionalProperties();             // TODO not sure if the following map/hash declaration is correct             return \"{String, \" + getTypeDeclaration(inner) + \"}\";         } else if (!languageSpecificPrimitives.contains(getSchemaType(p))) {             return packageName + \".Model.\" + super.getTypeDeclaration(p);         }         return super.getTypeDeclaration(p);     }"}
{"source": "@param minimumSimilarity <s> public static BooleanExpression fuzzyLike(Path<String> path, String value, float minimumSimilarity) {\n        Term term = new Term(path.getMetadata().getName(), value);\n        return new QueryElement(new FuzzyQuery(term, minimumSimilarity));\n    } <s> public static BooleanExpression fuzzyLike(Path<String> path, String value, int maxEdits) {         Term term = new Term(path.getMetadata().getName(), value);         return new QueryElement(new FuzzyQuery(term, maxEdits));     }"}
{"source": "@param base the current base directory, may be null. <s> File getBaseDir(File base, File file) {\n        if (base == null) {\n            return file.getParentFile().getAbsoluteFile();\n        } else {\n            Iterator bases = getParents(base).iterator();\n            Iterator fileParents = getParents(file.getAbsoluteFile()).iterator();\n            File result = null;\n            while (bases.hasNext() && fileParents.hasNext()) {\n                File next = (File) bases.next();\n                if (next.equals(fileParents.next())) {\n                    result = next;\n                } else {\n                    break;\n                }\n            }\n            return result;\n        }\n    } <s> File getBaseDir(final File file1, final File file2) {         if (file1 == null || file2 == null) {             return null;         }         final Iterator bases = getParents(file1).iterator();         final Iterator fileParents = getParents(file2.getAbsoluteFile()).iterator();         File result = null;         while (bases.hasNext() && fileParents.hasNext()) {             File next = (File) bases.next();             if (next.equals(fileParents.next())) {                 result = next;             } else {                 break;             }         }         return result;     }"}
{"source": "@param instant the instant to compare to <s> public int compareTo(ReadablePartial instant) {\n        if (instant == null) {\n            throw new IllegalArgumentException(\"The instant must not be null\");\n        }\n        int thisValue = get();\n        int otherValue = instant.get(getField());\n        if (thisValue < otherValue) {\n            return -1;\n        } else if (thisValue > otherValue) {\n            return 1;\n        } else {\n            return 0;\n        }\n    } <s> public int compareTo(ReadablePartial partial) {         if (partial == null) {             throw new IllegalArgumentException(\"The instant must not be null\");         }         int thisValue = get();         int otherValue = partial.get(getFieldType());         if (thisValue < otherValue) {             return -1;         } else if (thisValue > otherValue) {             return 1;         } else {             return 0;         }     }"}
{"source": "@param panelToolbar2 the toolbar <s> protected int addToolBarElements(JToolBar panelToolbar2, Location loc, int gridX) {\n\t\t// Override to add elements into the toolbar\n\t\treturn gridX;\n\t} <s> protected int addToolBarElements(JToolBar toolBar, Location location, int gridX) { \t\treturn gridX; \t}"}
{"source": "@param file the file for which the new base directory should be returned. <s> File getBaseDir(File base, File file) {\n        if (base == null) {\n            return file.getParentFile().getAbsoluteFile();\n        } else {\n            Iterator bases = getParents(base).iterator();\n            Iterator fileParents = getParents(file.getAbsoluteFile()).iterator();\n            File result = null;\n            while (bases.hasNext() && fileParents.hasNext()) {\n                File next = (File) bases.next();\n                if (next.equals(fileParents.next())) {\n                    result = next;\n                } else {\n                    break;\n                }\n            }\n            return result;\n        }\n    } <s> File getBaseDir(final File file1, final File file2) {         if (file1 == null || file2 == null) {             return null;         }         final Iterator bases = getParents(file1).iterator();         final Iterator fileParents = getParents(file2.getAbsoluteFile()).iterator();         File result = null;         while (bases.hasNext() && fileParents.hasNext()) {             File next = (File) bases.next();             if (next.equals(fileParents.next())) {                 result = next;             } else {                 break;             }         }         return result;     }"}
{"source": "@param search the string to be searched. The parameter will be interpreted as a regular expression. <s> public boolean searchText(String search, int matches) {\n\t\tboolean found = searcher.searchText(search, matches, true);\n\t\treturn found;\n\n\t} <s> public boolean searchText(String regex, int matches) { \t\tboolean found = searcher.searchText(regex, matches, true); \t\treturn found;  \t}"}
{"source": "@param allocator The target allocator to create an association with. <s> public DrillBuf retain(BufferAllocator allocator) {\n\n    if (isEmpty) {\n      return this;\n    }\n\n    if (BaseAllocator.DEBUG) {\n      historicalLog.recordEvent(\"retain(%s)\", allocator.getName());\n    }\n    BufferLedger otherLedger = this.ledger.getLedgerForAllocator(allocator);\n    return otherLedger.newDrillBuf(offset, length, null, true);\n  } <s> public DrillBuf retain(BufferAllocator target) {      if (isEmpty) {       return this;     }      if (BaseAllocator.DEBUG) {       historicalLog.recordEvent(\"retain(%s)\", target.getName());     }     final BufferLedger otherLedger = this.ledger.getLedgerForAllocator(target);     return otherLedger.newDrillBuf(offset, length, null);   }"}
{"source": "@param visible  true if only texts visible on the screen should be searched <s> public boolean searchText(String text, int minimumNumberOfMatches, boolean scroll, boolean visible) {\n\t\treturn searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll, visible);\n\t} <s> public boolean searchText(String text, int minimumNumberOfMatches, boolean scroll, boolean onlyVisible) { \t\treturn searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll, onlyVisible); \t}"}
{"source": "@param config An instance of  BroadcasterConfig <s> public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, BroadcasterConfig config)\n            throws InstantiationException, IllegalAccessException {\n\n        factory = new DefaultBroadcasterFactory(clazz);\n        return factory;\n    } <s> public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, AtmosphereServlet.AtmosphereConfig c)             throws InstantiationException, IllegalAccessException {          factory = new DefaultBroadcasterFactory(clazz);         config = c;         return factory;     }"}
{"source": "@param lng the long to examine. <s> public static int numberOfLeadingZeros(long lng) {\n        lng |= lng >> 1;\n        lng |= lng >> 2;\n        lng |= lng >> 4;\n        lng |= lng >> 8;\n        lng |= lng >> 16;\n        lng |= lng >> 32;\n        return bitCount(~lng);\n    } <s> public static int numberOfLeadingZeros(long v) {         // After Hacker's Delight, Figure 5-6         if (v < 0) {             return 0;         }         if (v == 0) {             return 64;         }         // On a 64-bit VM, the two previous tests should probably be replaced by         // if (v <= 0) return ((int) (~v >> 57)) & 64;          int n = 1;         int i = (int) (v >>> 32);         if (i == 0) {             n +=  32;             i = (int) v;         }         if (i >> 16 == 0) {             n +=  16;             i <<= 16;         }         if (i >> 24 == 0) {             n +=  8;             i <<= 8;         }         if (i >> 28 == 0) {             n +=  4;             i <<= 4;         }         if (i >> 30 == 0) {             n +=  2;             i <<= 2;         }         return n - (i >>> 31);     }"}
{"source": "@param dialect The dialect in effect <s> protected String determineSegmentColumnName(Properties params, Dialect dialect) {\n\t\tfinal ObjectNameNormalizer normalizer = (ObjectNameNormalizer) params.get( IDENTIFIER_NORMALIZER );\n\t\tfinal String name = ConfigurationHelper.getString( SEGMENT_COLUMN_PARAM, params, DEF_SEGMENT_COLUMN );\n\t\treturn normalizer.toDatabaseIdentifierText( name );\n\t} <s> protected String determineSegmentColumnName(Properties params, JdbcEnvironment jdbcEnvironment) { \t\tfinal String name = ConfigurationHelper.getString( SEGMENT_COLUMN_PARAM, params, DEF_SEGMENT_COLUMN ); \t\treturn jdbcEnvironment.getIdentifierHelper().toIdentifier( name ).render( jdbcEnvironment.getDialect() ); \t}"}
{"source": "@param ldapContext the dir context <s> public static LdapContext createPathContext(\n    \t\tLdapContext ldapContext, \n        String[] pathTokens) \n    throws NamingException\n    {\n        for (int i = 1; i < (pathTokens.length); i++)\n        {\n            String subContext = CN + \"=\" + pathTokens[i];\n            ldapContext = (LdapContext) createSubContext( \n            \t\tldapContext, \n            \t\tsubContext, null );\n        }\n        return ldapContext;\n    } <s> public static LdapContext createPathContext(         LdapContext authorityContext,          String[] pathTokens)      throws NamingException     {         for (int i = 1; i < (pathTokens.length); i++)         {             String subContext = CN + \"=\" + pathTokens[i];             authorityContext = (LdapContext) createSubContext(              \t\tauthorityContext,              \t\tsubContext, null );         }         return authorityContext;     }"}
{"source": "@param is The input stream to read from. This should contain a single protocol buffer and nothing else. <s> public Annotation readUndelimited(InputStream is) throws IOException {\n    return fromProto(CoreNLPProtos.Document.parseDelimitedFrom(is));\n  } <s> public Annotation readUndelimited(File in) throws IOException {     FileInputStream delimited = new FileInputStream(in);     FileInputStream undelimited = new FileInputStream(in);     CoreNLPProtos.Document doc;     try {       doc = CoreNLPProtos.Document.parseFrom(delimited);     } catch (Exception e) {       doc = CoreNLPProtos.Document.parseDelimitedFrom(undelimited);     } finally {       delimited.close();       undelimited.close();     }     return fromProto(doc);   }"}
{"source": "@param action the action to be performed on eureka server. Try the fallback servers in case of problems communicating to the primary one. <s> private ClientResponse makeRemoteCall(Action action, int serviceUrlIndex)\n            throws Throwable {\n        String urlPath = null;\n        Stopwatch tracer = null;\n        String serviceUrl = eurekaServiceUrls.get().get(serviceUrlIndex);\n        ClientResponse response = null;\n        logger.debug(\"Discovery Client talking to the server {}\", serviceUrl);\n        try {\n            // If the application is unknown do not register/renew/cancel but\n            // refresh\n            if ((UNKNOWN.equals(instanceInfo.getAppName())\n                    && (!Action.Refresh.equals(action)) && (!Action.Refresh_Delta\n                    .equals(action)))) {\n                return null;\n            }\n            WebResource r = discoveryApacheClient.resource(serviceUrl);\n            String remoteRegionsToFetchStr;\n            switch (action) {\n            case Renew:\n                tracer = RENEW_TIMER.start();\n                urlPath = \"apps/\" + appPathIdentifier;\n                response = r\n                        .path(urlPath)\n                        .queryParam(\"status\",\n                                instanceInfo.getStatus().toString())\n                        .queryParam(\"lastDirtyTimestamp\",\n                                instanceInfo.getLastDirtyTimestamp().toString())\n                        .put(ClientResponse.class);\n                break;\n            case Refresh:\n                tracer = REFRESH_TIMER.start();\n                final String vipAddress = clientConfig.getRegistryRefreshSingleVipAddress();\n                urlPath = vipAddress == null ? \"apps/\" : \"vips/\" + vipAddress;\n                remoteRegionsToFetchStr = remoteRegionsToFetch.get();\n                if (!Strings.isNullOrEmpty(remoteRegionsToFetchStr)) {\n                    urlPath += \"?regions=\" + remoteRegionsToFetchStr;\n                }\n                response = getUrl(serviceUrl + urlPath);\n                break;\n            case Refresh_Delta:\n                tracer = REFRESH_DELTA_TIMER.start();\n                urlPath = \" <s> private ClientResponse makeRemoteCall(Action action, String serviceUrl) throws Throwable {         String urlPath = null;         Stopwatch tracer = null;         ClientResponse response = null;         logger.debug(\"Discovery Client talking to the server {}\", serviceUrl);         try {             // If the application is unknown do not register/renew/cancel but             // refresh             if ((UNKNOWN.equals(instanceInfo.getAppName())                     && (!Action.Refresh.equals(action)) && (!Action.Refresh_Delta                     .equals(action)))) {                 return null;             }             WebResource r = discoveryApacheClient.resource(serviceUrl);             String remoteRegionsToFetchStr;             switch (action) {                 case Renew:                     tracer = RENEW_TIMER.start();                     urlPath = \"apps/\" + appPathIdentifier;                     response = r                             .path(urlPath)                             .queryParam(\"status\",                                     instanceInfo.getStatus().toString())                             .queryParam(\"lastDirtyTimestamp\",                                     instanceInfo.getLastDirtyTimestamp().toString())                             .put(ClientResponse.class);                     break;                 case Refresh:                     tracer = REFRESH_TIMER.start();                     final String vipAddress = clientConfig.getRegistryRefreshSingleVipAddress();                     urlPath = vipAddress == null ? \"apps/\" : \"vips/\" + vipAddress;                     remoteRegionsToFetchStr = remoteRegionsToFetch.get();                     if (!Strings.isNullOrEmpty(remoteRegionsToFetchStr)) {                         urlPath += \"?regions=\" + remoteRegionsToFetchStr;                     }                     response = getUrl(serviceUrl + urlPath);                     break;                 case Refresh_Delta:                     tracer = REFRESH_DELTA_TIMER.start();                     urlPath = \"apps/delta\";                     remoteRegionsToFetchStr = remoteRegionsToFetch.get();"}
{"source": "@param search the string to be searched. The parameter will be interpreted as a regular expression. <s> public boolean searchText(String search) {\n\t\tboolean found = searcher.searchText(search, 0, true);\n\t\treturn found;\n\t} <s> public boolean searchText(String regex) { \t\tboolean found = searcher.searchText(regex, 0, true); \t\treturn found; \t}"}
{"source": "@param verCfg Audit configuration. <s> protected EntityInfo getEntityInfo(AuditConfiguration verCfg, String entityName) {\n\t\tEntityConfiguration entCfg = verCfg.getEntCfg().get( entityName );\n\t\tboolean isRelationAudited = true;\n\t\tif ( entCfg == null ) {\n\t\t\t// a relation marked as RelationTargetAuditMode.NOT_AUDITED\n\t\t\tentCfg = verCfg.getEntCfg().getNotVersionEntityConfiguration( entityName );\n\t\t\tisRelationAudited = false;\n\t\t}\n\t\tfinal Class entityClass = ReflectionTools.loadClass( entCfg.getEntityClassName(), verCfg.getClassLoaderService() );\n\t\treturn new EntityInfo( entityClass, entityName, isRelationAudited );\n\t} <s> protected EntityInfo getEntityInfo(EnversService enversService, String entityName) { \t\tEntityConfiguration entCfg = enversService.getEntitiesConfigurations().get( entityName ); \t\tboolean isRelationAudited = true; \t\tif ( entCfg == null ) { \t\t\t// a relation marked as RelationTargetAuditMode.NOT_AUDITED \t\t\tentCfg = enversService.getEntitiesConfigurations().getNotVersionEntityConfiguration( entityName ); \t\t\tisRelationAudited = false; \t\t} \t\tfinal Class entityClass = ReflectionTools.loadClass( entCfg.getEntityClassName(), enversService.getClassLoaderService() ); \t\treturn new EntityInfo( entityClass, entityName, isRelationAudited ); \t}"}
{"source": "@param body client model (required) <s> public Client testClientModel(Client body) throws ApiException {\n        ApiResponse<Client> resp = testClientModelWithHttpInfo(body);\n        return resp.getData();\n    } <s> public Client testClientModel(Client client) throws ApiException {         ApiResponse<Client> resp = testClientModelWithHttpInfo(client);         return resp.getData();     }"}
{"source": "@param p Swagger property object <s> public String toInstantiationType(Property p) {\n        if (p instanceof MapProperty) {\n            MapProperty ap = (MapProperty) p;\n            Property additionalProperties2 = ap.getAdditionalProperties();\n            String type = additionalProperties2.getType();\n            if (null == type) {\n                LOGGER.error(\"No Type defined for Additional Property \" + additionalProperties2 + \"\\n\" //\n                        + \"\\tIn Property: \" + p);\n            }\n            String inner = getSwaggerType(additionalProperties2);\n            return instantiationTypes.get(\"map\") + \"<String, \" + inner + \">\";\n        } else if (p instanceof ArrayProperty) {\n            ArrayProperty ap = (ArrayProperty) p;\n            String inner = getSwaggerType(ap.getItems());\n            return instantiationTypes.get(\"array\") + \"<\" + inner + \">\";\n        } else {\n            return null;\n        }\n    } <s> public String toInstantiationType(Schema schema) {         if (ModelUtils.isMapSchema(schema)) {             Schema additionalProperties = (Schema) schema.getAdditionalProperties();             String type = additionalProperties.getType();             if (null == type) {                 LOGGER.error(\"No Type defined for Additional Property \" + additionalProperties + \"\\n\" //                         + \"\\tIn Property: \" + schema);             }             String inner = getSchemaType(additionalProperties);             return instantiationTypes.get(\"map\") + \"<String, \" + inner + \">\";         } else if (ModelUtils.isArraySchema(schema)) {             ArraySchema arraySchema = (ArraySchema) schema;             String inner = getSchemaType(arraySchema.getItems());             return instantiationTypes.get(\"array\") + \"<\" + inner + \">\";         } else {             return null;         }     }"}
{"source": "@param docdate The document date <s> public static String normalizeDateString(String s, Date docdate) {\n    // TODO [pengqi]: still need to handle relative dates (\"\u00e5\u008e\u00bb\u00e5\u00b9\u00b4\") and temporal references (\"\u00e5\u00bd\u0093\u00e6\u0097\u00b6\")\n    // TODO [pengqi]: need to handle irregular years (\"81\u00e5\u00b9\u00b4\")\n    // TODO [pengqi]: need to handle basic localization (\"\u00e5\u009c\u00a8\u00e4\u00b8\u0083\u00e6\u009c\u0088\u00e4\u00ba\u008c\u00e6\u0097\u00a5\u00e5\u0088\u00b0[\u00e5\u0085\u00ab\u00e6\u0097\u00a5]\u00e9\u0097\u00b4\")\n    Pattern p = Pattern.compile(BASIC_YYYYMMDD_PATTERN);\n    Matcher m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n      String year = m.group(1);\n      for (int i = 0; i < year.length(); i++) {\n        String t = \"\" + year.charAt(i);\n        if (CHINESE_LITERAL_DECIMAL_PATTERN.matcher(t).matches()) {\n          if (wordsToValues.containsKey(t))\n            res.append((int)wordsToValues.getCount(t));\n          else\n            // something unexpected happened\n            return null;\n        } else\n          res.append(t);\n      }\n\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2)));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(3)));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(BASIC_MMDD_PATTERN);\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 2) {\n      StringBuilder res = new StringBuilder();\n      String year = new SimpleDateFormat(\"yyyy\").format(docdate);\n\n      res.append(year);\n      res. <s> public static String normalizeDateString(String s, Date ctxdate) {     // TODO [pengqi]: need to handle basic localization (\"\u00e5\u009c\u00a8\u00e4\u00b8\u0083\u00e6\u009c\u0088\u00e4\u00ba\u008c\u00e6\u0097\u00a5\u00e5\u0088\u00b0[\u00e5\u0085\u00ab\u00e6\u0097\u00a5]\u00e9\u0097\u00b4\")     // TODO [pengqi]: need to handle literal numeral dates (usually used in events, e.g. \"\u00e4\u00b8\u0089\u00e4\u00b8\u0080\u00e4\u00ba\u0094\" for 03-15)     // TODO [pengqi]: might need to add a pattern for centuries (\"\u00e4\u00b8\u008a\u00e4\u00b8\u0096\u00e7\u00ba\u00aa90\u00e5\u00b9\u00b4\u00e4\u00bb\u00a3\")?     String ctxyear = new SimpleDateFormat(\"yyyy\").format(ctxdate);     String ctxmonth = new SimpleDateFormat(\"MM\").format(ctxdate);     String ctxday = new SimpleDateFormat(\"dd\").format(ctxdate);      Pattern p = Pattern.compile(\"^\" + BASIC_YYYYMMDD_PATTERN + \"$\");     Matcher m = p.matcher(s);      if (m.find() && m.groupCount() == 3) {       StringBuilder res = new StringBuilder();        res.append(normalizeYear(m.group(1), ctxyear));       res.append(\"-\");       res.append(normalizeMonthOrDay(m.group(2), ctxmonth));       res.append(\"-\");       res.append(normalizeMonthOrDay(m.group(3), ctxday));        return res.toString();     }      p = Pattern.compile(\"^\" + BASIC_MMDD_PATTERN + \"$\");     m = p.matcher(s);      if (m.find() && m.groupCount() == 2) {       StringBuilder res = new StringBuilder();        res.append(ctxyear);       res.append(\"-\");       res.append(normalizeMonthOrDay(m.group"}
{"source": "@param body Input composite as post body <s> public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws IOException {\n        HttpResponse response = fakeOuterCompositeSerializeForHttpResponse(body);\n        TypeReference typeRef = new TypeReference<OuterComposite>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    } <s> public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws IOException {         HttpResponse response = fakeOuterCompositeSerializeForHttpResponse(outerComposite);         TypeReference typeRef = new TypeReference<OuterComposite>() {};         return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);     }"}
{"source": "@param message the message to broadcast. <s> public BroadcastAction filter(Object originalMessage, Object message) {\n        // Avoid re-broadcasting\n        if (!receivedMessages.remove(message)) {\n            try {\n                jchannel.send(new Message(null, null, new JGroupsBroadcaster.BroadcastMessage(bc.getID(), message)));\n            } catch (ChannelException e) {\n                logger.warn(\"failed to send message\", e);\n            }\n        }\n        return new BroadcastAction(message);\n    } <s> public BroadcastAction filter(Object originalMessage, Object o) {         if (o instanceof String){             String message = (String)o;             // Avoid re-broadcasting             if (!receivedMessages.remove(message)) {                 try {                     jchannel.send(new Message(null, null, message));                 } catch (ChannelException e) {                     logger.warn(\"failed to send message\", e);                 }             }             return new BroadcastAction(message);         } else {             return new BroadcastAction(o);         }     }"}
{"source": "@param body client model (required) <s> public Client testSpecialTags(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    // verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testSpecialTags\");\n    }\n    \n    // create path and map variables\n    String localVarPath = \"/another-fake/dummy\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    // query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      } <s> public Client testSpecialTags(Client client) throws ApiException {     Object localVarPostBody = client;          // verify the required parameter 'client' is set     if (client == null) {       throw new ApiException(400, \"Missing the required parameter 'client' when calling testSpecialTags\");     }          // create path and map variables     String localVarPath = \"/another-fake/dummy\".replaceAll(\"\\\\{format\\\\}\",\"json\");      // query params     List<Pair> localVarQueryParams = new ArrayList<Pair>();     Map<String, String> localVarHeaderParams = new HashMap<String, String>();     Map<String, Object> localVarFormParams = new HashMap<String, Object>();                 final String[] localVarAccepts = {       \"application/json\"     };     final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);      final String[] localVarContentTypes = {       \"application/json\"     };     final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);      String[] localVarAuthNames = new String[] {  };      GenericType<Client> localVarReturnType = new GenericType<Client>() {};     return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);       }"}
{"source": "@param child an on-tree cuboid <s> public long findBestMatchCuboid(long child) {\n        long parent = getOnTreeParent(child);\n        while (parent > 0) {\n            if (cubeDesc.getAllCuboids().contains(parent)) {\n                break;\n            }\n            parent = getOnTreeParent(parent);\n        }\n\n        if (parent <= 0) {\n            throw new IllegalStateException(\"Can't find valid parent for Cuboid \" + child);\n        }\n        return parent;\n    } <s> public long findBestMatchCuboid(long cuboid) {         return findBestMatchCuboid1(cuboid);     }"}
{"source": "@param name the alias of the from item <s> RexNode lookupExp(String name) {\n      if (nameToNodeMap != null) {\n        RexNode node = nameToNodeMap.get(name);\n        if (node == null) {\n          throw Util.newInternal(\"Unknown identifier '\" + name\n              + \"' encountered while expanding expression\" + node);\n        }\n        return node;\n      }\n      int[] offsets = {-1};\n      final SqlValidatorScope[] ancestorScopes = {null};\n      SqlValidatorNamespace foundNs =\n          scope.resolve(name, ancestorScopes, offsets);\n      if (foundNs == null) {\n        return null;\n      }\n\n      // Found in current query's from list.  Find which from item.\n      // We assume that the order of the from clause items has been\n      // preserved.\n      SqlValidatorScope ancestorScope = ancestorScopes[0];\n      boolean isParent = ancestorScope != scope;\n      if ((inputs != null) && !isParent) {\n        int offset = offsets[0];\n        final LookupContext rels =\n            new LookupContext(this, inputs, systemFieldList.size());\n        return lookup(offset, rels);\n      } else {\n        // We're referencing a relational expression which has not been\n        // converted yet. This occurs when from items are correlated,\n        // e.g. \"select from emp as emp join emp.getDepts() as dept\".\n        // Create a temporary expression.\n        assert isParent;\n        DeferredLookup lookup = new DeferredLookup(this, name);\n        String correlName = createCorrel();\n        mapCorrelToDeferred.put(correlName, lookup);\n        final RelDataType rowType = foundNs.getRowType();\n        return rexBuilder.makeCorrel(rowType, correlName);\n      }\n    } <s> RexNode lookupExp(SqlQualified qualified) {       if (nameToNodeMap != null && qualified.prefixLength == 1) {         RexNode node = nameToNodeMap.get(qualified.identifier.names.get(0));         if (node == null) {           throw Util.newInternal(\"Unknown identifier '\" + qualified.identifier               + \"' encountered while expanding expression\");         }         return node;       }       int[] offsets = {-1};       final SqlValidatorScope[] ancestorScopes = {null};       SqlValidatorNamespace foundNs =           scope.resolve(qualified.prefix(), ancestorScopes, offsets);       if (foundNs == null) {         return null;       }        // Found in current query's from list.  Find which from item.       // We assume that the order of the from clause items has been       // preserved.       SqlValidatorScope ancestorScope = ancestorScopes[0];       boolean isParent = ancestorScope != scope;       if ((inputs != null) && !isParent) {         int offset = offsets[0];         final LookupContext rels =             new LookupContext(this, inputs, systemFieldList.size());         return lookup(offset, rels);       } else {         // We're referencing a relational expression which has not been         // converted yet. This occurs when from items are correlated,         // e.g. \"select from emp as emp join emp.getDepts() as dept\".         // Create a temporary expression.         assert isParent;         DeferredLookup lookup =             new DeferredLookup(this, qualified.identifier.names.get(0));         String correlName = createCorrel();         mapCorrelToDeferred.put(correlName, lookup);         final RelDataType rowType = foundNs.getRowType();         return rexBuilder.makeCorrel(rowType, correlName);       }     }"}
{"source": "@return One of the following application running states: {@link IServer#STATE_STARTED}, {@link IServer#STATE_STARTING}, {@link IServer#STATE_STOPPED}, {@link IServer#STATE_STOPPING}, {@link IServer#STATE_UNKNOWN} <s> public int track(IProgressMonitor monitor) throws CoreException {\n    long currentTime = System.currentTimeMillis();\n    long totalTime = currentTime + timeout;\n    CloudFoundryApplicationModule appModule = cloudServer.getBehaviour().updateModuleWithAllCloudInfo(appName, monitor);\n    printlnToConsole(NLS.bind(Messages.ApplicationInstanceStartingTracker_STARTING_TRACKING, appName), appModule);\n    int state = appModule.getState();\n    while (state != IServer.STATE_STARTED && state != IServer.STATE_STOPPED && currentTime < totalTime) {\n        appModule = cloudServer.getBehaviour().updateModuleWithAllCloudInfo(appName, monitor);\n        if (appModule == null || appModule.getApplication() == null) {\n            printlnToConsole(NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_NOT_EXISTS, appName), appModule);\n            return IServer.STATE_UNKNOWN;\n        }\n        if (monitor != null && monitor.isCanceled()) {\n            printlnToConsole(NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_CHECK_CANCELED, appName), appModule);\n            return IServer.STATE_UNKNOWN;\n        }\n        state = appModule.getState();\n        try {\n            Thread.sleep(WAIT_TIME);\n        } catch (InterruptedException e) {\n        }\n        currentTime = System.currentTimeMillis();\n    }\n    String runningStateMessage = state == IServer.STATE_STARTED ? NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_IS_RUNNING, appName) : NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_IS_NOT_RUNNING, appName);\n    printlnToConsole(runningStateMessage, appModule);\n    return <s> public int track(IProgressMonitor monitor) throws CoreException, OperationCanceledException {     long currentTime = System.currentTimeMillis();     long totalTime = currentTime + timeout;     CloudFoundryServerBehaviour behaviour = cloudServer.getBehaviour();     String appName = appModule.getDeployedApplicationName();     printlnToConsole(NLS.bind(Messages.ApplicationInstanceStartingTracker_STARTING_TRACKING, appName), appModule);     int state = IServer.STATE_UNKNOWN;     while (state != IServer.STATE_STARTED && state != IServer.STATE_STOPPED && currentTime < totalTime) {         if (monitor != null && monitor.isCanceled()) {             String error = NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_CHECK_CANCELED, appName);             printlnToConsole(error, appModule);             throw new OperationCanceledException(error);         }         CloudApplication cloudApp = behaviour.getCloudApplication(appName, monitor);         ApplicationStats applicationStats = behaviour.getApplicationStats(appName, monitor);         if (cloudApp == null) {             String error = NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_NOT_EXISTS, appName);             printlnToConsole(error, appModule);             throw CloudErrorUtil.toCoreException(error);         } else {             state = CloudFoundryApplicationModule.getCloudState(cloudApp, applicationStats);             try {                 Thread.sleep(WAIT_TIME);             } catch (InterruptedException e) {             }             currentTime = System.currentTimeMillis();         }     }     String runningStateMessage = state == IServer.STATE_STARTED ? NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_IS_RUNNING,"}
{"source": "@return The ruleSet <s> public RuleSet getRuleSet() {\n    return this.ruleSet;\n} <s> public Package getRuleSet() {     return this.pkg; }"}
{"source": "@return javax.swing.JTextArea <s> private JTextArea getTxtSkipURL() {\n        if (txtSkipURL == null) {\n            txtSkipURL = new JTextArea();\n            txtSkipURL.setFont(new java.awt.Font(\"Default\", java.awt.Font.PLAIN, 11));\n    \t    if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) {\n    \t    \ttxtSkipURL.setSize(new java.awt.Dimension(290,52));\n    \t    }\n        }\n        return txtSkipURL;\n    } <s> private ZapTextArea getTxtSkipURL() {         if (txtSkipURL == null) {             txtSkipURL = new ZapTextArea();             txtSkipURL.setFont(new java.awt.Font(\"Default\", java.awt.Font.PLAIN, 11));     \t    if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) {     \t    \ttxtSkipURL.setSize(new java.awt.Dimension(290,52));     \t    }         }         return txtSkipURL;     }"}
{"source": "@return red value in given position <s> public short getRed(final int i) {\n    return data[get1DIndex(i)];\n} <s> public short getRed() {     return data[getFirst1DIndex()]; }"}
{"source": "@return read operation {@link RdfBranch} <s> private RdfBranch branch(boolean includeinferred) throws SailException {\n    boolean active = isActive();\n    IsolationLevel level = getIsolationLevel();\n    boolean isolated = !IsolationLevels.NONE.isCompatibleWith(level);\n    if (includeinferred && active && isolated) {\n        return new DelegatingRdfBranch(includeInferredBranch, false);\n    } else if (active && isolated) {\n        return new DelegatingRdfBranch(explicitOnlyBranch, false);\n    } else if (includeinferred && active) {\n        return new UnionRdfBranch(new RdfNotBranchedSource(store.getInferredRdfSource(level)), new RdfNotBranchedSource(store.getExplicitRdfSource(level)));\n    } else if (active) {\n        return new RdfNotBranchedSource(store.getExplicitRdfSource(level));\n    } else if (includeinferred) {\n        return new UnionRdfBranch(store.getInferredRdfSource(level).fork(), store.getExplicitRdfSource(level).fork());\n    } else {\n        return store.getExplicitRdfSource(level).fork();\n    }\n} <s> private SailBranch branch(boolean includeinferred) throws SailException {     boolean active = isActive();     IsolationLevel level = getIsolationLevel();     boolean isolated = !IsolationLevels.NONE.isCompatibleWith(level);     if (includeinferred && active && isolated) {         return new DelegatingSailBranch(includeInferredBranch, false);     } else if (active && isolated) {         return new DelegatingSailBranch(explicitOnlyBranch, false);     } else if (includeinferred && active) {         return new UnionSailBranch(new SailNotBranchedSource(store.getInferredSailSource(level)), new SailNotBranchedSource(store.getExplicitSailSource(level)));     } else if (active) {         return new SailNotBranchedSource(store.getExplicitSailSource(level));     } else if (includeinferred) {         return new UnionSailBranch(store.getInferredSailSource(level).fork(), store.getExplicitSailSource(level).fork());     } else {         return store.getExplicitSailSource(level).fork();     } }"}
{"source": "@return item in given position <s> @SuppressWarnings(STR)\npublic double getReal(final int i) {\n    return (double) getFirstValue(i);\n} <s> @SuppressWarnings(STR) public double getReal() {     return (double) getFirstValue(); }"}
{"source": "@return JSON array of the aggreagtor values <s> private JSONArray marshalAggregatorValues(long superstep) {\n    JSONArray aggregatorArray = new JSONArray();\n    if ((superstep == INPUT_SUPERSTEP) || (aggregatorInUse.size() == NUM)) {\n        return aggregatorArray;\n    }\n    for (String name : aggregatorInUse) {\n        try {\n            Aggregator<Writable> aggregator = getAggregatorMap().get(name);\n            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n            DataOutput output = new DataOutputStream(outputStream);\n            aggregator.getAggregatedValue().write(output);\n            JSONObject aggregatorObj = new JSONObject();\n            aggregatorObj.put(AGGREGATOR_NAME_KEY, name);\n            aggregatorObj.put(AGGREGATOR_CLASS_NAME_KEY, aggregator.getClass().getName());\n            aggregatorObj.put(AGGREGATOR_VALUE_KEY, Base64.encodeBytes(outputStream.toByteArray()));\n            aggregatorArray.put(aggregatorObj);\n            if (LOG.isInfoEnabled()) {\n                LOG.info(STR + STR + aggregatorObj + STR + aggregator.getAggregatedValue() + STR);\n            }\n        } catch (JSONException e) {\n            throw new IllegalStateException(STR + STR + name, e);\n        } catch (IOException e) {\n            throw new IllegalStateException(STR + STR + name, e);\n        }\n    }\n    if (LOG.isInfoEnabled()) {\n        LOG.info(STR + STR + aggregatorArray);\n    }\n    aggregatorInUse.clear();\n    return aggregatorArray;\n} <s> private byte[] marshalAggregatorValues(long superstep) {     if (superstep == INPUT_SUPERSTEP) {         return new byte[NUM];     }     ByteArrayOutputStream outputStream = new ByteArrayOutputStream();     DataOutputStream output = new DataOutputStream(outputStream);     for (Entry<String, AggregatorWrapper<Writable>> entry : getAggregatorMap().entrySet()) {         if (entry.getValue().isChanged()) {             try {                 output.writeUTF(entry.getKey());                 entry.getValue().getCurrentAggregatedValue().write(output);             } catch (IOException e) {                 throw new IllegalStateException(STR + STR + entry.getKey(), e);             }         }     }     if (LOG.isInfoEnabled()) {         LOG.info(STR);     }     return outputStream.toByteArray(); }"}
{"source": "@return the {@link org.atmosphere.cpr.MetaBroadcaster} <s> public static MetaBroadcaster metaBroadcaster() {\n    return metaBroadcaster;\n} <s> public static DefaultMetaBroadcaster metaBroadcaster() {     return metaBroadcaster; }"}
{"source": "@return If reached, return true; else, return false. <s> public static boolean exceedsMaxCount() {\n    return mTestCount >= MAX_TEST_COUNT;\n} <s> public static boolean exceedsMaxCount() {     final long maxTestCount = HostConfig.getMaxTestCount();     return (maxTestCount > NUM) && (mTestCount >= maxTestCount); }"}
{"source": "@return -1 if the value is not valid <s> public static int getModeValue(String mode) {\n    if (mode == null)\n        return -NUM;\n    mode = mode.trim().toLowerCase();\n    if (mode.indexOf(STR) == -NUM) {\n        if (STR.equals(mode)) {\n            return MODE_INSERT;\n        } else if (STR.equals(mode)) {\n            return MODE_UPDATE;\n        } else {\n            return -NUM;\n        }\n    } else {\n        List l = StringUtil.stringToList(mode, STR);\n        String first = (String) l.get(NUM);\n        String second = (String) l.get(NUM);\n        if (STR.equals(first) && STR.equals(second)) {\n            return MODE_INSERT_UPDATE;\n        } else if (STR.equals(first) && STR.equals(second)) {\n            return MODE_UPDATE_INSERT;\n        } else {\n            return -NUM;\n        }\n    }\n} <s> public static ImportMode getModeValue(String mode) {     if (mode == null)         return null;     mode = mode.trim().toLowerCase();     if (mode.indexOf(STR) == -NUM) {         if (STR.equals(mode)) {             return ImportMode.insert;         } else if (STR.equals(mode)) {             return ImportMode.update;         } else {             return null;         }     } else {         List l = StringUtil.stringToList(mode, STR);         String first = (String) l.get(NUM);         String second = (String) l.get(NUM);         if (STR.equals(first) && STR.equals(second)) {             return ImportMode.insertUpdate;         } else if (STR.equals(first) && STR.equals(second)) {             return ImportMode.updateInsert;         } else {             return null;         }     } }"}
{"source": "@return Built {@link Ct.TimestampedEntry}. <s> public static Ct.TimestampedEntry parseTimestampedEntry(InputStream in) {\n    Ct.TimestampedEntry.Builder timestampedEntry = Ct.TimestampedEntry.newBuilder();\n    long timestamp = readNumber(in, CTConstants.TIMESTAMP_LENGTH);\n    timestampedEntry.setTimestamp(timestamp);\n    int entryType = (int) readNumber(in, CTConstants.LOG_ENTRY_TYPE_LENGTH);\n    timestampedEntry.setEntryType(Ct.LogEntryType.valueOf(entryType));\n    Ct.SignedEntry.Builder signedEntryBuilder = Ct.SignedEntry.newBuilder();\n    if (entryType == Ct.LogEntryType.X509_ENTRY_VALUE) {\n        int length = (int) readNumber(in, NUM);\n        ByteString x509 = ByteString.copyFrom(readFixedLength(in, length));\n        signedEntryBuilder.setX509(x509);\n    } else if (entryType == Ct.LogEntryType.PRECERT_ENTRY_VALUE) {\n        Ct.PreCert.Builder preCertBuilder = Ct.PreCert.newBuilder();\n        byte[] arr = readFixedLength(in, NUM);\n        preCertBuilder.setIssuerKeyHash(ByteString.copyFrom(arr));\n        arr = readFixedLength(in, NUM);\n        int length = (int) readNumber(in, NUM);\n        preCertBuilder.setTbsCertificate(ByteString.copyFrom(readFixedLength(in, length)));\n        preCertBuilder.build();\n        signedEntryBuilder.setPrecert(preCertBuilder);\n    } else {\n        throw new SerializationException(String.format(STR, entryType));\n    }\n    signedEntryBuilder.build();\n    timestampedEntry.setSignedEntry(signedEntryBuilder);\n    return timestampedEntry.build();\n} <s> public static TimestampedEntry parseTimestampedEntry(InputStream in) {     TimestampedEntry timestampedEntry = new TimestampedEntry();     timestampedEntry.timestamp = readNumber(in, CTConstants.TIMESTAMP_LENGTH);     int entryType = (int) readNumber(in, CTConstants.LOG_ENTRY_TYPE_LENGTH);     timestampedEntry.entryType = Ct.LogEntryType.valueOf(entryType);     Ct.SignedEntry.Builder signedEntryBuilder = Ct.SignedEntry.newBuilder();     if (entryType == Ct.LogEntryType.X509_ENTRY_VALUE) {         int length = (int) readNumber(in, NUM);         ByteString x509 = ByteString.copyFrom(readFixedLength(in, length));         signedEntryBuilder.setX509(x509);     } else if (entryType == Ct.LogEntryType.PRECERT_ENTRY_VALUE) {         Ct.PreCert.Builder preCertBuilder = Ct.PreCert.newBuilder();         byte[] arr = readFixedLength(in, NUM);         preCertBuilder.setIssuerKeyHash(ByteString.copyFrom(arr));         arr = readFixedLength(in, NUM);         int length = (int) readNumber(in, NUM);         preCertBuilder.setTbsCertificate(ByteString.copyFrom(readFixedLength(in, length)));         preCertBuilder.build();         signedEntryBuilder.setPrecert(preCertBuilder);     } else {         throw new SerializationException(String.format(STR, entryType));     }     timestampedEntry.signedEntry = signedEntryBuilder.build();     return timestampedEntry; }"}
{"source": "@return a  BigDecimal value which contains the number of nanoseconds, never  null <s> public static double durationNanos(int years, int months, int days, int hours, int minutes, double seconds) {\n        return durationNanos(years, months, days, hours, minutes, seconds, 0);\n    } <s> public static long durationNanos(int years, int months, int days, int hours, int minutes, long seconds) {         return durationNanos(years, months, days, hours, minutes, seconds, 0);     }"}
{"source": "@return The {@link android.telecomm.Connection.VideoProvider}. <s> public android.telecomm.Connection.VideoProvider getVideoProvider() {\n    return mVideoProvider;\n} <s> public android.telecom.Connection.VideoProvider getVideoProvider() {     return mVideoProvider; }"}
{"source": "@return a VirErrorLevel <s> public VirErrorLevel getLevel() {\n    return level;\n} <s> public ErrorLevel getLevel() {     return level; }"}
{"source": "@return project files in that directory, sorted alphabetically. <s> private File[] getProjectFiles(File directory) {\n    File[] files = directory.listFiles(new FileFilter() {\n\n        public boolean accept(File file) {\n            return (file.isFile() && file.getName().endsWith(STR));\n        }\n    });\n    switch(explorerTableSortColumn) {\n        case NUM:\n        case NUM:\n        case NUM:\n        default:\n    }\n    selectedFile = -NUM;\n    if (getProject() != null)\n        for (int n = NUM; n < files.length; n++) if (getProject().getFile().equals(files[n]))\n            selectedFile = n;\n    return files;\n} <s> private File[] getProjectFiles(File directory) {     return directory.listFiles(new FileFilter() {          public boolean accept(File file) {             return (file.isFile() && file.getName().endsWith(STR));         }     }); }"}
{"source": "@return the extended FluentPipeline <s> public T E() {\n    return this.add(new EdgesPipe());\n} <s> public GremlinPipeline<S, Edge> E() {     return this.add(new EdgesPipe()); }"}
{"source": "@return the matching option, or null if no match is found and the non-null default is invalid <s> public static DdlParsingMode parse(String value, String defaultValue) {\n            DdlParsingMode mode = parse(value);\n            if (mode == null && defaultValue != null) {\n                mode = parse(defaultValue);\n            }\n            return mode;\n        } <s> public static EventProcessingFailureHandlingMode parse(String value) {             if (value == null) {                 return null;             }              value = value.trim();              for (EventProcessingFailureHandlingMode option : EventProcessingFailureHandlingMode.values()) {                 if (option.getValue().equalsIgnoreCase(value)) {                     return option;                 }             }              return null;         }"}
{"source": "@return true if a message was removed, false otherwise. <s> public boolean removeActiveMessage() {\n    return removeMessage(currentPage);\n} <s> public int removeActiveMessage() {     return removeMessage(currentPage); }"}
{"source": "@return LoginDetails instance corresponding to the given LoginDetails class. Null if no such id found. <s> @JsonIgnore\n@SuppressWarnings(STR)\n@Nullable\npublic <T extends LoginDetails> LoginDetails getLoginDetails(Class<T> loginDetailsClass) {\n    return Maps.uniqueIndex(this.loginDetails, new Function<LoginDetails, Class<LoginDetails>>() {\n\n        @Override\n        public Class<LoginDetails> apply(@Nullable LoginDetails loginDetails) {\n            if (loginDetails != null) {\n                return (Class<LoginDetails>) loginDetails.getClass();\n            }\n            return null;\n        }\n    }).get(loginDetailsClass);\n} <s> @JsonIgnore @SuppressWarnings(STR) @Nullable public <T extends Credentials> Credentials getLoginDetails(Class<T> loginDetailsClass) {     return Maps.uniqueIndex(this.credentials, new Function<Credentials, Class<Credentials>>() {          @Override         public Class<Credentials> apply(@Nullable Credentials credentials) {             if (credentials != null) {                 return (Class<Credentials>) credentials.getClass();             }             return null;         }     }).get(loginDetailsClass); }"}
{"source": "@return the positions offset for the header or, 3 positions, for after the body (the third position is just to indicate that it's the body, the value is meaningless) <s> public static int[] getViewToHeaderBodyPosition(JTextArea view, String header, int start, int end) {\n        validateView(view);\n        validateHeader(header);\n        validateStartEnd(start, end, view.getDocument().getLength());\n\n        int excessChars = 0;\n        int pos = 0;\n        while ((pos = header.indexOf(\"\\r\\n\", pos)) != -1) {\n            pos += 2;\n            ++excessChars;\n        }\n\n        if (start + excessChars < header.length()) {\n            int[] position = getViewToHeaderPositionImpl(view, start, end);\n            if (position[1] > header.length()) {\n                position[1] = header.length();\n            }\n            return position;\n        }\n\n        int finalStartPos = start + excessChars - header.length();\n        int finalEndPos = end + excessChars - header.length();\n        return new int[] { finalStartPos, finalEndPos, 0 };\n    } <s> public static int[] getViewToHeaderBodyPosition(JTextArea view, String header, int start, int end) {         validateView(view);         validateHeader(header);         validateStartEnd(start, end);          if (!isValidStartEndForLength(start, end, view.getDocument().getLength())) {             return INVALID_POSITION;         }          int excessChars = 0;         int pos = 0;         while ((pos = header.indexOf(\"\\r\\n\", pos)) != -1) {             pos += 2;             ++excessChars;         }          if (start + excessChars < header.length()) {             int[] position = getViewToHeaderPositionImpl(view, start, end);             if (position[1] > header.length()) {                 position[1] = header.length();             }             return position;         }          int finalStartPos = start + excessChars - header.length();         int finalEndPos = end + excessChars - header.length();         return new int[] { finalStartPos, finalEndPos, 0 };     }"}
{"source": "@return double The yaw Euler angle. <s> public double getRotY() {\n    return mOrientation.getRotationY();\n} <s> public double getRotY() {     return Math.toDegrees(mOrientation.getRotationY()); }"}
{"source": "@return the next power of two that is larger than the specified int value. <s> public static int nextPowerOfTwo(int value) {\n    if (!isPowerOfTwo(value)) {\n        value--;\n        value |= value >> NUM;\n        value |= value >> NUM;\n        value |= value >> NUM;\n        value |= value >> NUM;\n        value |= value >> NUM;\n        value++;\n    }\n    return value;\n} <s> public static int nextPowerOfTwo(final int value) {     return NUM << (NUM - Integer.numberOfLeadingZeros(value - NUM)); }"}
{"source": "@return the response, or an Exception if something bad happened <s> private <T> T processResponse(final ClientResponse clientResponse, final Type responseType) {\n    final String response = readResponseFromClientResponse(clientResponse);\n    if (clientResponse.getStatus() >= NUM) {\n        throw new HandshakeAPIException(response);\n    }\n    try {\n        return parseJson(response, responseType);\n    } catch (final IOException e) {\n        throw new RuntimeException(e);\n    }\n} <s> private <T> T processResponse(final ClientResponse clientResponse, final Type responseType) {     final String response = readResponseFromClientResponse(clientResponse);     if (clientResponse.getStatus() == NUM) {         return null;     } else if (clientResponse.getStatus() >= NUM) {         throw new HandshakeAPIException(response);     }     try {         return parseJson(response, responseType);     } catch (final IOException e) {         throw new RuntimeException(e);     } }"}
{"source": "@return The generated proxy. <s> public static Blob generateProxy(InputStream stream, long length) {\n\t\treturn (Blob) Proxy.newProxyInstance( getProxyClassLoader(), PROXY_INTERFACES, new BlobProxy( stream, length ) );\n\t} <s> public static Blob generateProxy(InputStream stream, long length) { \t\treturn new BlobProxy( stream, length ); \t}"}
{"source": "@return true if the input can be combined into a parent MultiJoinRel <s> private boolean canCombine(RelNode input, boolean nullGenerating) {\n    return input instanceof MultiJoinRel\n        && !((MultiJoinRel) input).isFullOuterJoin()\n        && !((MultiJoinRel) input).containsOuter()\n        && !nullGenerating;\n  } <s> private boolean canCombine(RelNode input, boolean nullGenerating) {     return input instanceof MultiJoin         && !((MultiJoin) input).isFullOuterJoin()         && !((MultiJoin) input).containsOuter()         && !nullGenerating;   }"}
{"source": "@return new {@link HSSFWorkbook} generated by inserting beans into corresponding excel template <s> public HSSFWorkbook transformXLS(InputStream is, Map beanParams) throws ParsePropertyException {\n    HSSFWorkbook hssfWorkbook = null;\n    try {\n        POIFSFileSystem fs = new POIFSFileSystem(is);\n        hssfWorkbook = new HSSFWorkbook(fs);\n        transformWorkbook(hssfWorkbook, beanParams);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    return hssfWorkbook;\n} <s> public org.apache.poi.ss.usermodel.Workbook transformXLS(InputStream is, Map beanParams) throws ParsePropertyException, InvalidFormatException {     org.apache.poi.ss.usermodel.Workbook hssfWorkbook = null;     try {         hssfWorkbook = WorkbookFactory.create(is);         transformWorkbook(hssfWorkbook, beanParams);     } catch (IOException e) {         e.printStackTrace();     }     return hssfWorkbook; }"}
{"source": "@return The x location of the center of this circle <s> public float getX() {\n    return center[NUM];\n} <s> public float getX() {     if (left == null) {         calculateLeft();     }     return left.floatValue(); }"}
{"source": "@return The stored value or null if it doesn't exist in specified form. <s> public boolean getExtraBoolean(String key) {\n    return mExtraData.optBoolean(key);\n} <s> public boolean getExtraBoolean(String key) throws JSONException {     return mExtraData.getBoolean(key); }"}
{"source": "@return the list of KDCs <s> public String getKDCList(String realm) {\n    if (realm == null) {\n        realm = getDefaultRealm();\n    }\n    String kdcs = getDefault(STR, realm);\n    if (kdcs == null) {\n        return null;\n    }\n    return kdcs;\n} <s> public String getKDCList(String realm) throws KrbException {     if (realm == null) {         realm = getDefaultRealm();     }     Exception cause = null;     String kdcs = getDefault(STR, realm);     if (kdcs == null) {         kdcs = java.security.AccessController.doPrivileged(new java.security.PrivilegedAction<String>() {              @Override             public String run() {                 String osname = System.getProperty(STR);                 if (osname.startsWith(STR)) {                     String logonServer = System.getenv(STR);                     if (logonServer != null && logonServer.startsWith(STR)) {                         logonServer = logonServer.substring(NUM);                     }                     return logonServer;                 }                 return null;             }         });     }     if (kdcs == null) {         KrbException ke = new KrbException(STR);         if (cause != null) {             ke.initCause(cause);         }         throw ke;     }     return kdcs; }"}
{"source": "@return caption for that handle <s> public String getCaption(String handle) {\n    return getMetadataForHandle(handle).caption_;\n} <s> public String getCaption(String handle) {     TerminalMetadata data = getMetadataForHandle(handle);     if (data == null) {         return null;     }     return data.caption_; }"}
{"source": "@return a string representation of this map <s> @Override\npublic String toString() {\n    Node<K, V>[] t;\n    int f = (t = table) == null ? NUM : t.length;\n    Traverser<K, V> it = new Traverser<K, V>(t, f, NUM, f);\n    StringBuilder sb = new StringBuilder();\n    sb.append(STR);\n    Node<K, V> p;\n    if ((p = it.advance()) != null) {\n        for (; ; ) {\n            K k = p.key;\n            V v = p.val;\n            sb.append(k == this ? STR : k);\n            sb.append(STR);\n            sb.append(v == this ? STR : v);\n            if ((p = it.advance()) == null) {\n                break;\n            }\n            sb.append(STR).append(STR);\n        }\n    }\n    return sb.append(STR).toString();\n} <s> @Override public final String toString() {     StringBuilder sb = new StringBuilder();     sb.append(STR);     Iterator<E> it = iterator();     if (it.hasNext()) {         for (; ; ) {             Object e = it.next();             sb.append(e == this ? STR : e);             if (!it.hasNext()) {                 break;             }             sb.append(STR).append(STR);         }     }     return sb.append(STR).toString(); }"}
{"source": "@return javax.swing.JTextArea <s> private JTextArea getTxtDescription() {\n\t\tif (txtDescription == null) {\n\t\t\ttxtDescription = new JTextArea();\n\t\t\ttxtDescription.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.LOWERED));\n\t\t\ttxtDescription.setLineWrap(true);\n\t\t\ttxtDescription.setFont(new java.awt.Font(\"Dialog\", java.awt.Font.PLAIN, 11));\n\t\t}\n\t\treturn txtDescription;\n\t} <s> private ZapTextArea getTxtDescription() { \t\tif (txtDescription == null) { \t\t\ttxtDescription = new ZapTextArea(); \t\t\ttxtDescription.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.LOWERED)); \t\t\ttxtDescription.setLineWrap(true); \t\t\ttxtDescription.setFont(new java.awt.Font(\"Dialog\", java.awt.Font.PLAIN, 11)); \t\t} \t\treturn txtDescription; \t}"}
{"source": "@return the converted value, or null if the conversion could not be made <s> protected Object convertTimestampToEpochMillisAsDate(Column column, Field fieldDefn, Object data) {\n        if ( data == null ) return null;\n        try {\n            return new java.util.Date(Timestamp.toEpochMillis(data));\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    } <s> protected Object convertTimestampToEpochMillisAsDate(Column column, Field fieldDefn, Object data) {         if (data == null) {             data = fieldDefn.schema().defaultValue();         }         if (data == null) {             if (column.isOptional()) return null;             return new java.util.Date(0L); // return epoch         }         try {             return new java.util.Date(Timestamp.toEpochMillis(data));         } catch (IllegalArgumentException e) {             return handleUnknownData(column, fieldDefn, data);         }     }"}
{"source": "@return {@link ScaleAnimationBuilder} instance. Call {@link com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.ScaleAnimationBuilder#start()} to start the anim. <s> public ScaleAnimationBuilder animateScale(float scale) {\n    if (!isImageReady()) {\n        return null;\n    }\n    return new ScaleAnimationBuilder(scale);\n} <s> public AnimationBuilder animateScale(float scale) {     if (!isImageReady()) {         return null;     }     return new AnimationBuilder(scale); }"}
{"source": "@return data stored for the specified parent <s> public Object getCache(Object parent) {\n    if (cacheMap == null) return null;\n    return cacheMap.get(parent);\n  } <s> public PMetadata getCache(PGraphics renderer) {     if (cacheMap == null) return null;     return cacheMap.get(renderer);   }"}
{"source": "@return An annotator as specified by the given name and properties. <s> private synchronized static Supplier<Annotator> getOrCreate(String name, Properties props, Supplier<Annotator> annotator) {\n    StanfordCoreNLP.AnnotatorSignature key = new StanfordCoreNLP.AnnotatorSignature(name, PropertiesUtils.getSignature(name, props));\n    customAnnotators.register(name, props, StanfordCoreNLP.GLOBAL_ANNOTATOR_CACHE.computeIfAbsent(key, (sig) -> Lazy.cache(annotator)));\n    return () -> customAnnotators.get(name);\n  } <s> private synchronized static Supplier<Annotator> getOrCreate(AnnotatorFactory factory) {     return () -> {       Annotator rtn = customAnnotators.get(factory.signature());       if (rtn == null) {         // Create the annotator         rtn = factory.create();         // Register the annotator         customAnnotators.put(factory.signature(), factory.create());         // Clean up memory if needed         while (customAnnotators.size() > 10) {           customAnnotators.keySet().iterator().remove();         }       }       return rtn;     };   }"}
{"source": "@return A configuration configured via the stream <s> protected Configuration doConfigure(InputStream stream, String resourceName) throws HibernateException {\n\n\t\torg.dom4j.Document doc;\n\t\ttry {\n\t\t\tList errors = new ArrayList();\n\t\t\tdoc = xmlHelper.createSAXReader( resourceName, errors, entityResolver )\n\t\t\t\t\t.read( new InputSource( stream ) );\n\t\t\tif ( errors.size() != 0 ) {\n\t\t\t\tthrow new MappingException(\n\t\t\t\t\t\t\"invalid configuration\",\n\t\t\t\t\t\t(Throwable) errors.get( 0 )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tcatch (DocumentException e) {\n\t\t\tthrow new HibernateException(\n\t\t\t\t\t\"Could not parse configuration: \" + resourceName,\n\t\t\t\t\te\n\t\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tstream.close();\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\tlog.warn( \"could not close input stream for: \" + resourceName, ioe );\n\t\t\t}\n\t\t}\n\n\t\treturn doConfigure( doc );\n\n\t} <s> protected Configuration doConfigure(InputStream stream, String resourceName) throws HibernateException { \t\ttry { \t\t\tList errors = new ArrayList(); \t\t\tDocument document = xmlHelper.createSAXReader( resourceName, errors, entityResolver ) \t\t\t\t\t.read( new InputSource( stream ) ); \t\t\tif ( errors.size() != 0 ) { \t\t\t\tthrow new MappingException( \"invalid configuration\", (Throwable) errors.get( 0 ) ); \t\t\t} \t\t\tdoConfigure( document ); \t\t} \t\tcatch (DocumentException e) { \t\t\tthrow new HibernateException( \"Could not parse configuration: \" + resourceName, e ); \t\t} \t\tfinally { \t\t\ttry { \t\t\t\tstream.close(); \t\t\t} \t\t\tcatch (IOException ioe) { \t\t\t\tlog.warn( \"could not close input stream for: \" + resourceName, ioe ); \t\t\t} \t\t} \t\treturn this; \t}"}
{"source": "@return the validated collection (never {@code null} for method chaining) <s> public static <T extends Collection<?>> T validIndex(final T collection, final int index) {\n    return validIndex(collection, index, DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE, Integer.valueOf(index));\n} <s> public static <T extends CharSequence> T validIndex(final T chars, final int index) {     return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index)); }"}
{"source": "@return Returns the charset. <s> public String getCharset() {\n    return charset;\n} <s> public String getCharset() {     if (charset != null) {         return charset.name();     }     return DEFAULT_CHARSET; }"}
{"source": "@return the adapter to test <s> private ComponentAdapter prepRES_lifecycleManagerHonorsInstantiationSequence(MutablePicoContainer picoContainer) {\n    picoContainer.component(RecordingLifecycle.One.class);\n    PoolingComponentAdapter poolingComponentAdapter = new PoolingComponentAdapter(new ConstructorInjectionComponentAdapter(RecordingLifecycle.Recorder.class, RecordingLifecycle.Two.class));\n    return picoContainer.adapter(poolingComponentAdapter).lastCA();\n} <s> private ComponentAdapter prepRES_lifecycleManagerHonorsInstantiationSequence(MutablePicoContainer picoContainer) {     picoContainer.addComponent(RecordingLifecycle.One.class);     PoolingComponentAdapter poolingComponentAdapter = new PoolingComponentAdapter(new ConstructorInjectionComponentAdapter(RecordingLifecycle.Recorder.class, RecordingLifecycle.Two.class));     return picoContainer.addAdapter(poolingComponentAdapter).lastCA(); }"}
{"source": "@return true if the gzip compression should be used if the client accespts it. Default this option is tuned off. <s> protected boolean useGzipWhenAccepted() {\n        return false;\n    } <s> protected boolean useGzipWhenAccepted(Response r) {         return r.getMimeType() != null && r.getMimeType().toLowerCase().contains(\"text/\");     }"}
{"source": "@return threshold, default 20 <s> protected int getInSubqueryThreshold() {\n    return 20;\n  } <s> protected int getInSubqueryThreshold() {     return IN_SUBQUERY_THRESHOLD;   }"}
{"source": "@return an array of integers mapping to the update count per SQL command. <s> protected int[] executeBatchInternal() throws SQLException {\n    for (int i = 0; i < connection.maxRetriesPerExecute; i++) {\n      try {\n        Meta.ExecuteBatchResult result = connection.prepareAndUpdateBatch(this, batchedSql);\n        return result.updateCounts;\n      } catch (NoSuchStatementException e) {\n        resetStatement();\n      }\n    }\n\n    throw new RuntimeException(\"Failed to successfully execute batch update after \"\n        +  connection.maxRetriesPerExecute + \" attempts\");\n  } <s> protected long[] executeBatchInternal() throws SQLException {     for (int i = 0; i < connection.maxRetriesPerExecute; i++) {       try {         return connection.prepareAndUpdateBatch(this, batchedSql).updateCounts;       } catch (NoSuchStatementException e) {         resetStatement();       }     }      throw new RuntimeException(\"Failed to successfully execute batch update after \"         +  connection.maxRetriesPerExecute + \" attempts\");   }"}
{"source": "@return the size of tiles in pixels <s> public int getTileSize() {\n    return tileSize;\n} <s> @Deprecated public int getTileSize() {     return Math.max(tileHeight, tileWidth); }"}
{"source": "@return the extended FluentPipeline <s> public T bothV() {\n    return this.add(new BothVerticesPipe());\n} <s> public GremlinPipeline<S, Vertex> bothV() {     return this.add(new BothVerticesPipe()); }"}
{"source": "@return a SecurityContext representing the authenticated account. <s> public SecurityContext login(AuthenticationToken token) throws AuthenticationException {\n    Account account;\n    try {\n        account = authenticate(token);\n        rememberMeSuccessfulLogin(token, account);\n    } catch (AuthenticationException ae) {\n        rememberMeFailedLogin(token, ae);\n        throw ae;\n    }\n    SecurityContext secCtx = createSecurityContext(token, account);\n    assertCreation(secCtx);\n    bind(secCtx);\n    return secCtx;\n} <s> public Subject login(AuthenticationToken token) throws AuthenticationException {     Account account;     try {         account = authenticate(token);         rememberMeSuccessfulLogin(token, account);     } catch (AuthenticationException ae) {         rememberMeFailedLogin(token, ae);         throw ae;     }     Subject secCtx = createSubject(token, account);     assertCreation(secCtx);     bind(secCtx);     return secCtx; }"}
{"source": "@return List of all selected objects. <s> public Collection<OsmPrimitive> getSelected() {\n    return new ArrayList<OsmPrimitive>(selectedPrimitives);\n} <s> public Collection<OsmPrimitive> getSelected() {     return Collections.unmodifiableSet(selectedPrimitives); }"}
{"source": "@return a {@link Criterion} that evaluates the raw selection and selection args <s> public static Criterion fromRawSelection(final String selection, final String[] selectionArgs) {\n    if (TextUtils.isEmpty(selection)) {\n        return Criterion.all;\n    }\n    return new Criterion(null) {\n\n        @Override\n        protected void populate(SqlBuilder builder, boolean forSqlValidation) {\n            builder.sql.append(selection);\n            if (selectionArgs != null && selectionArgs.length > NUM) {\n                if (builder.args == null) {\n                    throw new UnsupportedOperationException(STR + STR);\n                }\n                Collections.addAll(builder.args, selectionArgs);\n            }\n        }\n    };\n} <s> public static Criterion fromRawSelection(final String selection, final String[] selectionArgs) {     if (TextUtils.isEmpty(selection)) {         return null;     }     return new Criterion(null) {          @Override         protected void populate(SqlBuilder builder, boolean forSqlValidation) {             builder.sql.append(selection);             if (selectionArgs != null && selectionArgs.length > NUM) {                 if (builder.args == null) {                     throw new UnsupportedOperationException(STR + STR);                 }                 Collections.addAll(builder.args, selectionArgs);             }         }     }; }"}
{"source": "@return an  ExecutionResult <s> protected CompletableFuture<ExecutionResult> completeValueForList(ExecutionContext executionContext, ExecutionStrategyParameters parameters, Iterable<Object> iterableValues) {\n\n        ExecutionTypeInfo typeInfo = parameters.getTypeInfo();\n        GraphQLList fieldType = typeInfo.castType(GraphQLList.class);\n        GraphQLFieldDefinition fieldDef = parameters.getTypeInfo().getFieldDefinition();\n\n        InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, fieldTypeInfo(parameters, fieldDef), iterableValues);\n        Instrumentation instrumentation = executionContext.getInstrumentation();\n\n        InstrumentationContext<ExecutionResult> completeListCtx = instrumentation.beginFieldListComplete(\n                instrumentationParams\n        );\n\n        CompletableFuture<List<ExecutionResult>> resultsFuture = Async.each(iterableValues, (item, index) -> {\n\n            ExecutionPath indexedPath = parameters.getPath().segment(index);\n\n            ExecutionTypeInfo wrappedTypeInfo = ExecutionTypeInfo.newTypeInfo()\n                    .parentInfo(typeInfo)\n                    .type(fieldType.getWrappedType())\n                    .path(indexedPath)\n                    .fieldDefinition(fieldDef)\n                    .build();\n\n            NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, wrappedTypeInfo);\n\n            ExecutionStrategyParameters newParameters = parameters.transform(builder ->\n                    builder.typeInfo(wrappedTypeInfo)\n                            .nonNullFieldValidator(nonNullableFieldValidator)\n                            .path(indexedPath)\n                            .source(item)\n            );\n\n            return completeValue(executionContext, newParameters);\n        });\n\n        CompletableFuture<ExecutionResult> overallResult = new CompletableFuture<>();\n        completeListCtx.onDispatched(overallResult);\n\n        resultsFuture.whenComplete((results, exception) -> {\n            if (exception != null) {\n                ExecutionResult executionResult = handleNonNullException(executionContext, overallResult, exception);\n                completeListCtx.onCompleted(executionResult, exception);\n                return;\n            }\n            List<Object> completedResults = new ArrayList<>();\n            for (ExecutionResult completedValue : results) {\n                completedResults.add(completedValue.getData());\n            }\n            ExecutionResultImpl executionResult = new <s> protected FieldValueInfo completeValueForList(ExecutionContext executionContext, ExecutionStrategyParameters parameters, Iterable<Object> iterableValues) {          Collection<Object> values = FpKit.toCollection(iterableValues);         ExecutionTypeInfo typeInfo = parameters.getTypeInfo();         GraphQLList fieldType = typeInfo.castType(GraphQLList.class);         GraphQLFieldDefinition fieldDef = parameters.getTypeInfo().getFieldDefinition();          InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, fieldTypeInfo(parameters, fieldDef), values);         Instrumentation instrumentation = executionContext.getInstrumentation();          InstrumentationContext<ExecutionResult> completeListCtx = instrumentation.beginFieldListComplete(                 instrumentationParams         );          List<FieldValueInfo> fieldValueInfos = new ArrayList<>();         int index = 0;         for (Object item : values) {             ExecutionPath indexedPath = parameters.getPath().segment(index);              ExecutionTypeInfo wrappedTypeInfo = ExecutionTypeInfo.newTypeInfo()                     .parentInfo(typeInfo)                     .type(fieldType.getWrappedType())                     .path(indexedPath)                     .fieldDefinition(fieldDef)                     .build();              NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, wrappedTypeInfo);              int finalIndex = index;             ExecutionStrategyParameters newParameters = parameters.transform(builder ->                     builder.typeInfo(wrappedTypeInfo)                             .nonNullFieldValidator(nonNullableFieldValidator)                             .listSize(values.size())                             .currentListIndex(finalIndex)                             .path(indexedPath)                             .source(item)             );             fieldValueInfos.add(completeValue(executionContext, newParameters));             index++;         }          CompletableFuture<List<ExecutionResult>> resultsFuture = Async.each(fieldValueInfos, (item, i) -> item.getFieldValue());          CompletableFuture<ExecutionResult> overallResult = new CompletableFuture<>();         completeListCtx.onDispatched(overallResult);          resultsFuture.whenComplete((results, exception) -> {             if (exception != null) {                 Execution"}
{"source": "@return the current time in ms <s> private long now() {\n    return mMonotonicClock == null ? SystemClock.uptimeMillis() : mMonotonicClock.now();\n} <s> private long now() {     return SystemClock.uptimeMillis(); }"}
{"source": "Provides a list containing four set, each containing projects to be displayed on the project view for projects using the parameterized trigger plugin under 'Subprojects'. <s> public List<Set<?>> getProjectInfo(AbstractProject context) {\n\n        Comparator customComparator = new Comparator<AbstractProject>() {\n            public int compare(AbstractProject abstractProject1, AbstractProject abstractProject2) {\n                return abstractProject1.getFullName().compareTo(abstractProject2.getFullName());\n            }\n        };\n\n        Set<AbstractProject> dynamicProject = new TreeSet<AbstractProject>(customComparator);\n        Set<AbstractProject> staticProject = new TreeSet<AbstractProject>(customComparator);\n        Set<AbstractProject> triggeredProject = new TreeSet<AbstractProject>(customComparator);\n        Set<String> unresolvedProject = new TreeSet<String>();\n\n        iterateBuilds(context, projects, dynamicProject, staticProject, triggeredProject, unresolvedProject);\n\n        // We don't want to show a project twice\n        triggeredProject.removeAll(dynamicProject);\n        triggeredProject.removeAll(staticProject);\n\n        return Arrays.asList(staticProject, dynamicProject, triggeredProject, unresolvedProject);\n    } <s> public SubProjectData getProjectInfo(AbstractProject context) {          SubProjectData subProjectData = new SubProjectData();          iterateBuilds(context, projects, subProjectData);          // We don't want to show a project twice         subProjectData.getTriggered().removeAll(subProjectData.getDynamic());         subProjectData.getTriggered().removeAll(subProjectData.getFixed());          return subProjectData;     }"}
{"source": "Returns true if, the lockClient is keeping the lock for the lockPath <s> private boolean isKeepLock(String lockClient, String lockPath) {\n        try {\n            if (zkClient.checkExists().forPath(lockPath) != null) {\n                byte[] data = zkClient.getData().forPath(lockPath);\n                String lockServerName = new String(data, Charset.forName(\"UTF-8\"));\n                return lockServerName.equalsIgnoreCase(lockClient);\n            }\n        } catch (Exception e) {\n            logger.error(\"fail to get the lockClient for the path: \" + lockPath, e);\n        }\n        return false;\n    } <s> private boolean isKeepLock(String serverName, String lockPath) {         try {             if (zkClient.checkExists().forPath(lockPath) != null) {                 byte[] data = zkClient.getData().forPath(lockPath);                 String lockServerName = new String(data, Charset.forName(\"UTF-8\"));                 return lockServerName.equalsIgnoreCase(serverName);             }         } catch (Exception e) {             logger.error(\"fail to get the serverName for the path: \" + lockPath, e);         }         return false;     }"}
{"source": "Checks if a flag is set. <s> public boolean isFlagSet(int flag) {\n        return (flags & flag) != 0;\n    } <s> public boolean isFlagSet(int flagsToCheck) {         return (flags & flagsToCheck) != 0;     }"}
{"source": "This method initializes jTextArea <s> private JTextArea getTxtSkipURL() {\n        if (txtSkipURL == null) {\n            txtSkipURL = new JTextArea();\n            txtSkipURL.setFont(new java.awt.Font(\"Default\", java.awt.Font.PLAIN, 11));\n    \t    if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) {\n    \t    \ttxtSkipURL.setSize(new java.awt.Dimension(290,52));\n    \t    }\n        }\n        return txtSkipURL;\n    } <s> private ZapTextArea getTxtSkipURL() {         if (txtSkipURL == null) {             txtSkipURL = new ZapTextArea();             txtSkipURL.setFont(new java.awt.Font(\"Default\", java.awt.Font.PLAIN, 11));     \t    if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) {     \t    \ttxtSkipURL.setSize(new java.awt.Dimension(290,52));     \t    }         }         return txtSkipURL;     }"}
{"source": "Returns the common base directory between a current base directory and a given file. <s> File getBaseDir(File base, File file) {\n        if (base == null) {\n            return file.getParentFile().getAbsoluteFile();\n        } else {\n            Iterator bases = getParents(base).iterator();\n            Iterator fileParents = getParents(file.getAbsoluteFile()).iterator();\n            File result = null;\n            while (bases.hasNext() && fileParents.hasNext()) {\n                File next = (File) bases.next();\n                if (next.equals(fileParents.next())) {\n                    result = next;\n                } else {\n                    break;\n                }\n            }\n            return result;\n        }\n    } <s> File getBaseDir(final File file1, final File file2) {         if (file1 == null || file2 == null) {             return null;         }         final Iterator bases = getParents(file1).iterator();         final Iterator fileParents = getParents(file2.getAbsoluteFile()).iterator();         File result = null;         while (bases.hasNext() && fileParents.hasNext()) {             File next = (File) bases.next();             if (next.equals(fileParents.next())) {                 result = next;             } else {                 break;             }         }         return result;     }"}
{"source": "Return the list of Cassandra instances ordered by position on ring, indicated by token. <s> @GET\n  public List<CassandraInstance> findAll() {\n    return service.findAll();\n  } <s> @GET   public Set<CassandraInstance> findAll() {     return service.findAll();   }"}
{"source": "Removes the content source from this channel, if it exists. <s> public ChannelContentSource removeContentSource(ContentSource contentSource) {\n        if ((this.channelContentSources == null) || (contentSource == null)) {\n            return null;\n        }\n\n        ChannelContentSource doomed = null;\n\n        for (ChannelContentSource ccs : this.channelContentSources) {\n            if (contentSource.equals(ccs.getChannelContentSourcePK().getContentSource())) {\n                doomed = ccs;\n                break;\n            }\n        }\n\n        if (doomed != null) {\n            this.channelContentSources.remove(doomed);\n        }\n\n        return doomed;\n    } <s> public RepoContentSource removeContentSource(ContentSource contentSource) {         if ((this.repoContentSources == null) || (contentSource == null)) {             return null;         }          RepoContentSource doomed = null;          for (RepoContentSource ccs : this.repoContentSources) {             if (contentSource.equals(ccs.getRepoContentSourcePK().getContentSource())) {                 doomed = ccs;                 break;             }         }          if (doomed != null) {             this.repoContentSources.remove(doomed);         }          return doomed;     }"}
{"source": "First authenticates the AuthenticationToken argument, and if successful, constructs a SecurityContext instance representing the authenticated account's identity. <s> public SecurityContext login(AuthenticationToken token) throws AuthenticationException {\r\n        Account account;\r\n        try {\r\n            account = authenticate(token);\r\n            rememberMeSuccessfulLogin(token, account);\r\n        } catch (AuthenticationException ae) {\r\n            rememberMeFailedLogin(token, ae);\r\n            throw ae; //propagate\r\n        }\r\n        SecurityContext secCtx = createSecurityContext(token, account);\r\n        assertCreation(secCtx);\r\n        bind(secCtx);\r\n        return secCtx;\r\n    } <s> public Subject login(AuthenticationToken token) throws AuthenticationException {\r         Account account;\r         try {\r             account = authenticate(token);\r             rememberMeSuccessfulLogin(token, account);\r         } catch (AuthenticationException ae) {\r             rememberMeFailedLogin(token, ae);\r             throw ae; //propagate\r         }\r         Subject secCtx = createSubject(token, account);\r         assertCreation(secCtx);\r         bind(secCtx);\r         return secCtx;\r     }"}
{"source": "Looks up a specific revision based on some SCM-specific set of permissible syntaxes. <s> @CheckForNull\n    public final SCMRevision fetch(@NonNull String revision, @CheckForNull TaskListener listener)\n            throws IOException, InterruptedException {\n        return retrieve(revision, defaultListener(listener));\n    } <s> @CheckForNull     public final SCMRevision fetch(@NonNull String thingName, @CheckForNull TaskListener listener)             throws IOException, InterruptedException {         return retrieve(thingName, defaultListener(listener));     }"}
{"source": "Invoke the proprietary  CometSupport <s> public Action doCometSupport(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException {\n        req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory);\n        req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments);\n        req.setAttribute(BROADCASTER_CLASS, broadcasterClassName);\n        req.setAttribute(ATMOSPHERE_CONFIG, config);\n\n        Action a = null;\n        try {\n            if ((config.getInitParameter(ALLOW_QUERYSTRING_AS_REQUEST) != null\n                    || (isIECandidate(req) || req.getParameter(HeaderConfig.JSONP_CALLBACK_NAME) != null))\n                    && req.getAttribute(WebSocket.WEBSOCKET_SUSPEND) == null) {\n\n                Map<String, String> headers = configureQueryStringAsRequest(req);\n                String body = headers.remove(ATMOSPHERE_POST_BODY);\n                if (body != null && body.isEmpty()) {\n                    body = null;\n                }\n\n                req.headers(headers)\n                   .method(body != null && req.getMethod().equalsIgnoreCase(\"GET\") ? \"POST\" : req.getMethod());\n\n                if (body != null) {\n                   req.body(body);\n                }\n\n                a = cometSupport.service(req, res);\n            } else {\n                return cometSupport.service(req, res);\n            }\n        } catch (IllegalStateException ex) {\n            if (ex.getMessage() != null && (ex.getMessage().startsWith(\"Tomcat failed\") || ex.getMessage().startsWith(\"JBoss failed\") )) {\n                if (!isFilter) {\n                    logger.warn(\"Failed using comet support: {}, error: {} Is the Nio or Apr Connector enabled?\", cometSupport.getClass().getName(),\n                            ex.getMessage());\n                    logger.warn(\"Using BlockingIOCometSupport.\");\n                }\n                logger.trace(ex.getMessage(), ex);\n\n                cometSupport = new BlockingIOCometSupport(config); <s> public Action doCometSupport(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException {         req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory);         req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments);         req.setAttribute(BROADCASTER_CLASS, broadcasterClassName);         req.setAttribute(ATMOSPHERE_CONFIG, config);          Action a = null;         try {             if ((config.getInitParameter(ALLOW_QUERYSTRING_AS_REQUEST) != null                     || (isIECandidate(req) || req.getParameter(HeaderConfig.JSONP_CALLBACK_NAME) != null))                     && req.getAttribute(WebSocket.WEBSOCKET_SUSPEND) == null) {                  Map<String, String> headers = configureQueryStringAsRequest(req);                 String body = headers.remove(ATMOSPHERE_POST_BODY);                 if (body != null && body.isEmpty()) {                     body = null;                 }                  req.headers(headers)                    .method(body != null && req.getMethod().equalsIgnoreCase(\"GET\") ? \"POST\" : req.getMethod());                  if (body != null) {                    req.body(body);                 }                  a = asyncSupport.service(req, res);             } else {                 return asyncSupport.service(req, res);             }         } catch (IllegalStateException ex) {             if (ex.getMessage() != null && (ex.getMessage().startsWith(\"Tomcat failed\") || ex.getMessage().startsWith(\"JBoss failed\") )) {                 if (!isFilter) {                     logger.warn(\"Failed using comet support: {}, error: {} Is the Nio or Apr Connector enabled?\", asyncSupport.getClass().getName(),                             ex.getMessage());                     logger.warn(\"Using BlockingIOCometSupport.\");                 }                 logger.trace(ex.getMessage(), ex);                  asyncSupport = new BlockingIOCometSupport(config);                 doCometSupport"}
{"source": "Return the  org.atmosphere.cpr.MetaBroadcaster <s> public static MetaBroadcaster metaBroadcaster() {\n        return metaBroadcaster;\n    } <s> public static DefaultMetaBroadcaster metaBroadcaster() {         return metaBroadcaster;     }"}
{"source": "Returns a one dimensional array from an sql query. <s> public <T> List<T> querySimpleList(Class<T> c, String sqlCmd, Connection conn)\n    {   // Execute the  Statement\n        if (checkOpen()==false)\n            return null;\n        // Debug\n        ResultSet rs = null;\n        try\n        {\t// Check Open\n            if (checkOpen()==false)\n                return null;\n            // Debug\n            long start = System.currentTimeMillis();\n            if (log.isInfoEnabled())\n                log.info(\"executing: \" + sqlCmd);\n            // Get the next Value\n            rs = driver.executeQuery(sqlCmd, null, false, conn);\n            if (rs == null)\n            { // Error\n                error(driver);\n                return null;\n            }\n            // Check Result\n            List<T> result = new ArrayList<T>();\n            while (rs.next())\n            {\n                T item = ObjectUtils.convert(c, rs.getObject(1));\n                result.add(item);\n            }\n            // No Value\n            if (log.isInfoEnabled())\n                log.info(\"querySimpleList retured \"+String.valueOf(result.size())+\" items. Query completed in \" + String.valueOf(System.currentTimeMillis() - start) + \" ms\");\n            clearError();\n            return result;\n        } catch (ClassCastException e) \n        {   \n            log.error(\"querySingleValue cast exception: \", e);\n            error(Errors.Exception, e);\n            return null;\n        } catch (SQLException e) \n        {\n            log.error(\"querySimpleList exception: \", e);\n            error(DBErrors.QueryFailed, e);\n            return null;\n        } finally\n        { // Cleanup\n            closeResultSet(rs);\n        }\n    } <s> public <T> int querySimpleList(Class<T> c, String sqlCmd, Connection conn, Collection<T> result)     {   // Check status         if (checkOpen()==false)             return -1;         // Start query         ResultSet rs = null;         try         {   // Log performance             long start = System.currentTimeMillis();             if (log.isInfoEnabled())                 log.info(\"executing: \" + sqlCmd);             // Get the next Value             rs = driver.executeQuery(sqlCmd, null, false, conn);             if (rs == null)             { // Error                 error(driver);                 return -1;             }             // Check Result             int count=0;             while (rs.next())             {                 T item = ObjectUtils.convert(c, rs.getObject(1));                 result.add(item);                 count++;             }             // No Value             if (log.isInfoEnabled())                 log.info(\"querySimpleList retured \"+String.valueOf(count)+\" items. Query completed in \" + String.valueOf(System.currentTimeMillis() - start) + \" ms\");             clearError();             return count;         } catch (ClassCastException e)          {                log.error(\"querySingleValue cast exception: \", e);             error(Errors.Exception, e);             return -1;         } catch (SQLException e)          {             log.error(\"querySimpleList exception: \", e);             error(DBErrors.QueryFailed, e);             return -1;         } finally         { // Cleanup             closeResultSet(rs);         }     }"}
{"source": "Removes a converter from the set of converters, by index. <s> public InstantConverter removeInstantConverter(int index) throws SecurityException {\n        checkAlterInstantConverters();\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(index, removed);\n        return removed[0];\n    } <s> public InstantConverter removeInstantConverter(InstantConverter converter)             throws SecurityException {                  checkAlterInstantConverters();         if (converter == null) {             return null;         }         InstantConverter[] removed = new InstantConverter[1];         iInstantConverters = iInstantConverters.remove(converter, removed);         return removed[0];     }"}
{"source": "Get the x location of the center of this circle <s> public float getX() {\r\n        return center[0];\r\n    } <s> public float getX() {\r         if(left == null) {\r             calculateLeft();\r         }\r \r         return left.floatValue();\r     }"}
{"source": "Return  InputSplitWrappers for given  HiveReadEntry. <s> public List<InputSplitWrapper> getInputSplits(final HiveReadEntry hiveReadEntry) {\n    final Stopwatch timeGetSplits = Stopwatch.createStarted();\n    try {\n      if (!isPartitionedTable) {\n        return getTableInputSplits();\n      }\n\n      final List<InputSplitWrapper> splits = Lists.newArrayList();\n      for (HivePartition p : hiveReadEntry.getPartitions()) {\n        splits.addAll(getPartitionInputSplits(p));\n      }\n      return splits;\n    } catch (final Exception e) {\n      logger.error(\"Failed to get InputSplits\", e);\n      throw new DrillRuntimeException(\"Failed to get InputSplits\", e);\n    } finally {\n      logger.debug(\"Took {} \u00c2\u00b5s to get InputSplits from {}.{}\", timeGetSplits.elapsed(TimeUnit.NANOSECONDS) / 1000,\n          hiveReadEntry.getTable().getDbName(), hiveReadEntry.getTable().getTableName());\n    }\n  } <s> public List<LogicalInputSplit> getInputSplits(final HiveReadEntry hiveReadEntry) {     final Stopwatch timeGetSplits = Stopwatch.createStarted();     try {       if (!isPartitionedTable) {         return getTableInputSplits();       }        final List<LogicalInputSplit> splits = Lists.newArrayList();       for (HivePartition p : hiveReadEntry.getPartitions()) {         splits.addAll(getPartitionInputSplits(p));       }       return splits;     } catch (final Exception e) {       logger.error(\"Failed to get InputSplits\", e);       throw new DrillRuntimeException(\"Failed to get InputSplits\", e);     } finally {       logger.debug(\"Took {} \u00c2\u00b5s to get InputSplits from {}.{}\", timeGetSplits.elapsed(TimeUnit.NANOSECONDS) / 1000,           hiveReadEntry.getTable().getDbName(), hiveReadEntry.getTable().getTableName());     }   }"}
{"source": "Convenient replacement of  #startProfilingCPU(long) with  ProfilingModes#CPU_TRACING for the mode. <s> public static YourKitContext startProfile(GiraphConfiguration conf) {\n    Controller controller = null;\n    try {\n      controller = new Controller();\n      controller.enableStackTelemetry();\n      controller.startCPUProfiling(ProfilingModes.CPU_SAMPLING,\n          Controller.DEFAULT_FILTERS);\n      LOG.debug(\"Started YourKit profiling CPU\");\n      // CHECKSTYLE: stop IllegalCatch\n    } catch (Exception e) {\n      // CHECKSTYLE: resume IllegalCatch\n      LOG.debug(\"Failed to start YourKit CPU profiling\", e);\n    }\n    return new YourKitContext(controller);\n  } <s> public static YourKitContext startProfile(boolean enableStackTelemetry,                                             boolean enableCPUProfilling,                                             boolean enableAllocationRecording) {     Controller controller;     try {       controller = new Controller();       // CHECKSTYLE: stop IllegalCatch     } catch (Exception e) {       // CHECKSTYLE: resume IllegalCatch       LOG.info(\"Failed to set up YourKit controller\", e);       return null;     }      try {       if (enableStackTelemetry) {         controller.enableStackTelemetry();         LOG.info(\"Enabled Yourkit stack telemetry\");       }       // CHECKSTYLE: stop IllegalCatch     } catch (Exception e) {       // CHECKSTYLE: resume IllegalCatch       LOG.info(\"Failed to enable YourKit stack telemetry\", e);     }      try {       if (enableCPUProfilling) {         controller.startCPUProfiling(ProfilingModes.CPU_SAMPLING,           Controller.DEFAULT_FILTERS, Controller.DEFAULT_WALLTIME_SPEC);         LOG.info(\"Started YourKit CPU profiling\");       }       // CHECKSTYLE: stop IllegalCatch     } catch (Exception e) {       // CHECKSTYLE: resume IllegalCatch       LOG.info(\"Failed to start YourKit CPU profiling\", e);     }      try {       if (enableAllocationRecording) {         controller.startAllocationRecording(true, ALLOCATION_RECORDING_INTERVAL,             false, -1, true, false);         LOG.info(\"Started YourKit allocation recording\");       }       // CHECKSTYLE: stop IllegalCatch     } catch (Exception e) {       // CHECKSTYLE: resume IllegalCatch       LOG.info(\"Failed to start YourKit allocation recording\", e);     }      return new YourKitContext(controller);   }"}
{"source": "Get the  edu.stanford.nlp.international.Language object corresponding to the given language string. <s> private Language getLanguage(String languageStr) {\n    for (Language l : Language.values()) {\n      if (l.name().equalsIgnoreCase(languageStr))\n        return l;\n    }\n    return null;\n  } <s> private Languages.Language getLanguage(String languageStr) {     for (Languages.Language l : Languages.Language.values()) {       if (l.name().equalsIgnoreCase(languageStr))         return l;     }     return null;   }"}
{"source": "Gets the EmfRefactoring supported by the controller. <s> @Override\n\tpublic EmfRefactoring getParent() {\n\t\treturn this.parent;\n\t} <s> @Override \tpublic Refactoring getParent() { \t\treturn this.parent; \t}"}
{"source": "Parses a serialized Graph from an InputStream. <s> public Graph parse(InputStream serializedGraph,\n            String formatIdentifier) throws UnsupportedFormatException {\n        return parse(serializedGraph, formatIdentifier, null);\n    } <s> public ImmutableGraph parse(InputStream serializedGraph,             String formatIdentifier) throws UnsupportedFormatException {         return parse(serializedGraph, formatIdentifier, null);     }"}
{"source": "Get the current number of bucket hosts and update the redundancy statistics for the region <s> private int updateRedundancy() {\n    int numBucketHosts = getNumInitializedBuckets();\n    if (!isClosed()) {\n      redundancyTracker.updateStatistics(numBucketHosts);\n    }\n    return numBucketHosts;\n  } <s> private int updateRedundancy() {     int desiredRedundancy = this.pRegion.getRedundantCopies();     int numBucketHosts = getNumInitializedBuckets();     if (isClosed()) {       return numBucketHosts;     }     int actualRedundancy = numBucketHosts - 1;     this.redundancy = actualRedundancy;     if (this.redundancySatisfied && numBucketHosts > 0 && actualRedundancy < desiredRedundancy) {       incLowRedundancyBucketCount(1);       this.redundancySatisfied = false;     } else if (!this.redundancySatisfied && numBucketHosts > 0         && actualRedundancy >= desiredRedundancy) {       incLowRedundancyBucketCount(-1);       this.redundancySatisfied = true;       this.redundancyEverSatisfied = true;     }     return numBucketHosts;   }"}
{"source": "Retrieves the parsed Test Suite. <s> public TestSuite getSuite()\n\t{\n\t\treturn this.testSuite;\n\t} <s> public List<TestSuite> getSuite() \t{ \t\treturn this.testSuites; \t}"}
{"source": "Checks if this persistent resource's underlying entity is sharable. <s> private boolean isShareable() {\n        return getRequestScope().getDictionary().isSharable(obj.getClass());\n    } <s> private boolean isShareable() {         return getRequestScope().getDictionary().isShareable(obj.getClass());     }"}
{"source": "Return a list of all selected objects. <s> public Collection<OsmPrimitive> getSelected() {\n        // It would be nice to have this be a copy-on-write list\n        // or an Collections.unmodifiableList().  It would be\n        // much faster for large selections.  May users just\n        // call this, and only check the .size().\n        return new ArrayList<OsmPrimitive>(selectedPrimitives);\n    } <s> public Collection<OsmPrimitive> getSelected() {         return Collections.unmodifiableSet(selectedPrimitives);     }"}
{"source": "Construct the text for the main label of a graphic. <s> public String createText(MilStd2525TacticalGraphic graphic)\n    {\n        String functionId = graphic.getFunctionId();\n        if (CircularFireSupportArea.FUNCTION_ID_TARGET.equals(functionId))\n            return graphic.getText();\n        else\n            return createDateRangeText(graphic, functionId);\n    } <s> public String[] createText(MilStd2525TacticalGraphic graphic)     {         String[] result;          String functionId = graphic.getFunctionId();         if (CircularFireSupportArea.FUNCTION_ID_TARGET.equals(functionId))         {             result = new String[] { graphic.getText() };         }         else         {             boolean useSeparateTimeLabel = this.isShowSeparateTimeLabel(functionId);             String mainText = this.createMainText(graphic, functionId, !useSeparateTimeLabel);              if (useSeparateTimeLabel)             {                 String timeText = this.createTimeRangeText(graphic);                 result = new String[] { mainText, timeText };             }             else             {                 result = new String[] { mainText };             }         }         return result;     }"}
{"source": "Creates a  TokenStream that aggregates the outputs of a given set of  TokenStreams. <s> public static final TokenStream of(TokenStream... streams) {\n    return new TokenStreamAggregator(streams);\n  } <s> public static final TwitterTokenStream of(TwitterTokenStream... streams) {     return new TokenStreamAggregator(streams);   }"}
{"source": "Obtains a ISTextExpert instance for processing structured text with the specified type handler and the specified environment. <s> static public ISTextExpert getExpert(String type, STextEnvironment environment) {\n\t\tISTextExpert expert;\n\t\tif (environment == null)\n\t\t\tenvironment = STextEnvironment.DEFAULT;\n\t\tsynchronized (sharedExperts) {\n\t\t\tMap experts = (Map) sharedExperts.get(type);\n\t\t\tif (experts == null) {\n\t\t\t\texperts = new HashMap(); // environment -> expert\n\t\t\t\tsharedExperts.put(type, experts);\n\t\t\t}\n\t\t\texpert = (ISTextExpert) experts.get(environment);\n\t\t\tif (expert == null) {\n\t\t\t\tSTextTypeHandler handler = STextTypeHandlerFactory.getHandler(type);\n\t\t\t\tif (handler == null)\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); //$NON-NLS-1$\n\t\t\t\texpert = new STextImpl(handler, environment, false);\n\t\t\t\texperts.put(type, expert);\n\t\t\t}\n\t\t}\n\t\treturn expert;\n\t} <s> static public IStructuredTextExpert getExpert(String type, StructuredTextEnvironment environment) { \t\tIStructuredTextExpert expert; \t\tif (environment == null) \t\t\tenvironment = StructuredTextEnvironment.DEFAULT; \t\tsynchronized (sharedExperts) { \t\t\tMap experts = (Map) sharedExperts.get(type); \t\t\tif (experts == null) { \t\t\t\texperts = new HashMap(); // environment -> expert \t\t\t\tsharedExperts.put(type, experts); \t\t\t} \t\t\texpert = (IStructuredTextExpert) experts.get(environment); \t\t\tif (expert == null) { \t\t\t\tStructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type); \t\t\t\tif (handler == null) \t\t\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); //$NON-NLS-1$ \t\t\t\texpert = new StructuredTextImpl(handler, environment, false); \t\t\t\texperts.put(type, expert); \t\t\t} \t\t} \t\treturn expert; \t}"}
{"source": "Get the y location of the center of this circle <s> public float getY() {\r\n        return center[1];\r\n    } <s> public float getY() {\r         if(top == null) {\r             calculateTop();\r         }\r \r         return top.floatValue();\r     }"}
{"source": "Read the announcement generated file. <s> protected FileReader readAnnouncement( File file )\n        throws MojoExecutionException\n    {\n        FileReader fileReader;\n        try\n        {\n            fileReader = new FileReader( file );\n        }\n        catch ( FileNotFoundException fnfe )\n        {\n            throw new MojoExecutionException( \"File not found. \" + file );\n        }\n        return fileReader;\n    } <s> protected String readAnnouncement( File file )         throws MojoExecutionException     {         InputStreamReader reader = null;         FileInputStream inputStream = null;         try         {             inputStream = new FileInputStream( file );              if ( StringUtils.isEmpty( templateEncoding ) )             {                 templateEncoding = ReaderFactory.FILE_ENCODING;                 getLog().warn( \"File encoding has not been set, using platform encoding '\" + templateEncoding                                    + \"', i.e. build is platform dependent!\" );             }              reader = new InputStreamReader( inputStream, templateEncoding );             return IOUtil.toString( reader );         }         catch ( FileNotFoundException fnfe )         {             throw new MojoExecutionException( \"File not found. \" + file );         }         catch ( UnsupportedEncodingException uee )         {             throw new MojoExecutionException( \"Unsupported encoding: '\" + templateEncoding + \"'\" );         }         catch ( IOException ioe )         {             throw new MojoExecutionException( \"Failed to read the announcement file.\", ioe );         }         finally         {             IOUtil.close( inputStream );             IOUtil.close( reader );         }     }"}
{"source": "Create  GitHubRepositoryName from URL <s> public static GitHubRepositoryName create(final String url) {\n        LOGGER.log(Level.FINE, \"Constructing from URL {0}\", url);\n        for (Pattern p : URL_PATTERNS) {\n            Matcher m = p.matcher(url.trim());\n            if (m.matches()) {\n                LOGGER.log(Level.FINE, \"URL matches {0}\", m);\n                GitHubRepositoryName ret = new GitHubRepositoryName(m.group(1), m.group(2),\n                        m.group(3));\n                LOGGER.log(Level.FINE, \"Object is {0}\", ret);\n                return ret;\n            }\n        }\n        LOGGER.log(Level.WARNING, \"Could not match URL {0}\", url);\n        return null;\n    } <s> public static GitlabRepositoryName create(final String url) {         LOGGER.log(Level.FINE, \"Constructing from URL {0}\", url);         for (Pattern p : URL_PATTERNS) {             Matcher m = p.matcher(url.trim());             if (m.matches()) {                 LOGGER.log(Level.FINE, \"URL matches {0}\", m);                 GitlabRepositoryName ret = new GitlabRepositoryName(m.group(1), m.group(2),                         m.group(3));                 LOGGER.log(Level.FINE, \"Object is {0}\", ret);                 return ret;             }         }         LOGGER.log(Level.WARNING, \"Could not match URL {0}\", url);         return null;     }"}
{"source": "Searches for a button with the given search string and returns true if the searched button is found a given number of times <s> private boolean searchForButton(String search, int matches) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<Button> buttonList = viewFetcher.getCurrentViews(Button.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(Button button : buttonList){\n\t\t\tmatcher = p.matcher(button.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches = 0;\n\t\t\t\treturn true;\n\t\t\t} \t\n\t\t}\n\n\t\tif (scroller.scroll(Scroller.Direction.DOWN))\n\t\t{\n\t\t\treturn searchForButton(search, matches);\n\t\t} else {\n\t\t\tif (countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + search);\n\t\t\tcountMatches = 0;\n\t\t\treturn false;\n\t\t}\n\n\t} <s> private boolean searchForButton(String regex, int matches) { \t\tsleeper.sleep(); \t\tinst.waitForIdleSync(); \t\tPattern p = Pattern.compile(regex); \t\tMatcher matcher; \t\tArrayList<Button> buttonList = viewFetcher.getCurrentViews(Button.class); \t\tif(matches == 0) \t\t\tmatches = 1; \t\tfor(Button button : buttonList){ \t\t\tmatcher = p.matcher(button.getText().toString()); \t\t\tif(matcher.find()){\t \t\t\t\tcountMatches++; \t\t\t} \t\t\tif (countMatches == matches) { \t\t\t\tcountMatches = 0; \t\t\t\treturn true; \t\t\t} \t \t\t}  \t\tif (scroller.scroll(Scroller.Direction.DOWN)) \t\t{ \t\t\treturn searchForButton(regex, matches); \t\t} else { \t\t\tif (countMatches > 0) \t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + regex); \t\t\tcountMatches = 0; \t\t\treturn false; \t\t}  \t}"}
{"source": "Returns an instance of  org.mule.module.google.calendar.model.CalendarList listing the calendars of the user that owns the OAuth access token. <s> @Processor\n    @Inject\n    @OAuthProtected\n\t@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)\n    public List<CalendarList> getCalendarList(\n    \t\tMuleMessage message,\n    \t\t@Optional @Default(\"100\") int maxResults,\n    \t\t@Optional String pageToken,\n    \t\t@Optional @Default(\"false\") boolean showHidden) throws IOException {\n\n    \tcom.google.api.services.calendar.Calendar.CalendarList.List calendars = this.client.calendarList().list();\n    \tcom.google.api.services.calendar.model.CalendarList list = calendars.setMaxResults(maxResults)\n    \t\t.setPageToken(pageToken)\n    \t\t.setShowHidden(showHidden)\n    \t\t.execute();\n    \t\n    \tthis.saveNextPageToken(list, message);\n    \treturn CalendarList.valueOf(list.getItems(), CalendarList.class);\n    } <s> @Processor     @OAuthProtected \t@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)     @Paged     public PagingDelegate<CalendarList> getCalendarList(     \t\tfinal @Optional @Default(\"false\") boolean showHidden,     \t\tfinal PagingConfiguration pagingConfiguration) throws IOException {     \t     \treturn new TokenBasedPagingDelegate<CalendarList>() {     \t\t     \t\t@Override     \t\tpublic List<CalendarList> doGetPage() throws IOException { \t\t\t\tcom.google.api.services.calendar.Calendar.CalendarList.List calendars = client.calendarList().list(); \t\t\t\tcom.google.api.services.calendar.model.CalendarList list = calendars.setMaxResults(pagingConfiguration.getFetchSize()) \t\t\t\t\t\t.setPageToken(this.getPageToken()) \t\t\t\t\t\t.setShowHidden(showHidden) \t\t\t\t\t\t.execute(); \t\t\t\t \t\t\t\tsetPageToken(list.getNextPageToken()); \t\t\t\treturn CalendarList.valueOf(list.getItems(), CalendarList.class);     \t\t} \t\t};     }"}
{"source": "Parses the output of ping and populates a instance of  PingInfo <s> protected PingInfo parse(int exitValue, List<String> outLines,List<String> errLines) {\n\t\tPingInfo info = new PingInfo();\n\t\tPattern roundTripTimePat = Pattern.compile(RTT_REG_EX);\n\t\tPattern transmitReceivePat = Pattern.compile(TRANSMITTED_RECEIVED_REG_EX);\n\t\tPattern noRouteToHostPat = Pattern.compile(NO_ROUTE_TO_HOST_REG_EX);\n\t\tPattern unknownHostPat = Pattern.compile(UNKNOWN_HOST_REG_EX);\n\n\t\tinfo.setHost(getHost());\n\n\t\t// Parse the output based on exit value of ping\n\t\tswitch (exitValue) {\n\n\t\t// Clean exit\n\t\tcase 0:\n\t\t\t// Extract the RTT times\n\t\t\tfor (String line : outLines) {\n\t\t\t\tMatcher matcher = roundTripTimePat.matcher(line);\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\tinfo.setRTTMin(Double.parseDouble(matcher.group(1)));\n\t\t\t\t\tinfo.setRTTAvg(Double.parseDouble(matcher.group(2)));\n\t\t\t\t\tinfo.setRTTMax(Double.parseDouble(matcher.group(3)));\n\t\t\t\t\tinfo.setRTTMDev(Double.parseDouble(matcher.group(4)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Extract the transmit and received counts\n\t\t\tfor (String line : outLines) {\n\t\t\t\tMatcher matcher = transmitReceivePat.matcher(line);\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\tinfo.setTransmitted(Integer.parseInt(matcher.group(1)));\n\t\t\t\t\tinfo.setReceived(Integer.parseInt(matcher.group(2)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// If no ICMP packages are returned then consider the test failed\n\t\t\tif (info.getReceived() == 0) {\n\t\t\t\tinfo.setStatus(ServiceStatus.FAIL);\n\t\t\t}\n\t\t\telse { <s> protected PingResult parse(int exitValue, List<String> outLines,List<String> errLines) { \t\tPingResult info = new PingResult(); \t\tPattern roundTripTimePat = Pattern.compile(RTT_REG_EX); \t\tPattern transmitReceivePat = Pattern.compile(TRANSMITTED_RECEIVED_REG_EX); \t\tPattern noRouteToHostPat = Pattern.compile(NO_ROUTE_TO_HOST_REG_EX); \t\tPattern unknownHostPat = Pattern.compile(UNKNOWN_HOST_REG_EX);  \t\tinfo.setHost(getHost());  \t\t// Parse the output based on exit value of ping \t\tswitch (exitValue) {  \t\t// Clean exit \t\tcase 0: \t\t\t// Extract the RTT times \t\t\tfor (String line : outLines) { \t\t\t\tMatcher matcher = roundTripTimePat.matcher(line); \t\t\t\tif (matcher.find()) { \t\t\t\t\tinfo.setRTTMin(Double.parseDouble(matcher.group(1))); \t\t\t\t\tinfo.setRTTAvg(Double.parseDouble(matcher.group(2))); \t\t\t\t\tinfo.setRTTMax(Double.parseDouble(matcher.group(3))); \t\t\t\t\tinfo.setRTTMDev(Double.parseDouble(matcher.group(4))); \t\t\t\t} \t\t\t} \t\t\t// Extract the transmit and received counts \t\t\tfor (String line : outLines) { \t\t\t\tMatcher matcher = transmitReceivePat.matcher(line); \t\t\t\tif (matcher.find()) { \t\t\t\t\tinfo.setTransmitted(Integer.parseInt(matcher.group(1))); \t\t\t\t\tinfo.setReceived(Integer.parseInt(matcher.group(2))); \t\t\t\t} \t\t\t} \t\t\t \t\t\t// If no ICMP packages are returned then consider the test failed \t\t\tif (info.getReceived() == 0) { \t\t\t\tinfo.setStatus(ServiceStatus.FAIL); \t\t\t} \t\t\telse {"}
{"source": "Removes the package version from this channel, if it exists. <s> public ChannelPackageVersion removePackageVersion(PackageVersion packageVersion) {\n        if ((this.channelPackageVersions == null) || (packageVersion == null)) {\n            return null;\n        }\n\n        ChannelPackageVersion doomed = null;\n\n        for (ChannelPackageVersion cpv : this.channelPackageVersions) {\n            if (packageVersion.equals(cpv.getChannelPackageVersionPK().getPackageVersion())) {\n                doomed = cpv;\n                break;\n            }\n        }\n\n        if (doomed != null) {\n            this.channelPackageVersions.remove(doomed);\n        }\n\n        return doomed;\n    } <s> public RepoPackageVersion removePackageVersion(PackageVersion packageVersion) {         if ((this.repoPackageVersions == null) || (packageVersion == null)) {             return null;         }          RepoPackageVersion doomed = null;          for (RepoPackageVersion cpv : this.repoPackageVersions) {             if (packageVersion.equals(cpv.getRepoPackageVersionPK().getPackageVersion())) {                 doomed = cpv;                 break;             }         }          if (doomed != null) {             this.repoPackageVersions.remove(doomed);         }          return doomed;     }"}
{"source": "Compares this object with the specified object for equality based on start and end millis. <s> public boolean equals(Object readableInterval) {\n        if (this == readableInterval) {\n            return true;\n        }\n        if (readableInterval instanceof ReadableInterval == false) {\n            return false;\n        }\n        ReadableInterval other = (ReadableInterval) readableInterval;\n        return (getStartMillis() == other.getStartMillis() &&\n                getEndMillis() == other.getEndMillis());\n    } <s> public boolean equals(Object readableInterval) {         if (this == readableInterval) {             return true;         }         if (readableInterval instanceof ReadableInterval == false) {             return false;         }         ReadableInterval other = (ReadableInterval) readableInterval;         return (getStartMillis() == other.getStartMillis() &&                 getEndMillis() == other.getEndMillis() &&                 getChronology() == other.getChronology());     }"}
{"source": "Returns the stored portlet preferences array. <s> public InternalPortletPreference[] getStoredPreferences(\n\t\t\tPortletWindow portletWindow,\n\t\t\tPortletRequest request)\n\tthrows PortletContainerException {\n        String key = getFormattedKey(portletWindow, request);\n        InternalPortletPreference[] preferences = storage.get(key);\n        if (preferences == null) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No portlet preferences found for: \" + key);\n            }\n            return new InternalPortletPreference[0];\n        } else {\n        \tif (LOG.isDebugEnabled()) {\n        \t\tLOG.debug(\"Got \" + preferences.length + \" stored preferences.\");\n        \t}\n        \treturn clonePreferences(preferences);\n        }\n    } <s> public Map<String,InternalPortletPreference> getStoredPreferences( \t\t\tPortletWindow portletWindow, \t\t\tPortletRequest request) \tthrows PortletContainerException {         String key = getFormattedKey(portletWindow, request);         Map<String,InternalPortletPreference> preferences = storage.get(key);         if (preferences == null) {             if (LOG.isDebugEnabled()) {                 LOG.debug(\"No portlet preferences found for: \" + key);             }             return Collections.emptyMap();         } else {         \tif (LOG.isDebugEnabled()) {         \t\tLOG.debug(\"Got \" + preferences.size() + \" stored preferences.\");         \t}         \treturn clonePreferences(preferences);         }     }"}
{"source": "Returns the common base directory between a current base directory and a given file. <s> File getBaseDir(File base, File file) {\n        if (base == null) {\n            return file.getParentFile().getAbsoluteFile();\n        } else {\n            Iterator bases = getParents(base).iterator();\n            Iterator fileParents = getParents(file.getAbsoluteFile()).iterator();\n            File result = null;\n            while (bases.hasNext() && fileParents.hasNext()) {\n                File next = (File) bases.next();\n                if (next.equals(fileParents.next())) {\n                    result = next;\n                } else {\n                    break;\n                }\n            }\n            return result;\n        }\n    } <s> File getBaseDir(final File file1, final File file2) {         if (file1 == null || file2 == null) {             return null;         }         final Iterator file1Parents = getParents(file1).iterator();         final Iterator file2Parents = getParents(file2.getAbsoluteFile()).iterator();         File result = null;         while (file1Parents.hasNext() && file2Parents.hasNext()) {             File next = (File) file1Parents.next();             if (next.equals(file2Parents.next())) {                 result = next;             } else {                 break;             }         }         return result;     }"}
{"source": "Returns the  ConnectionJDBC object referenced by the  #statement instance variable. <s> private ConnectionJDBC getConnection() throws SQLException {\n        return (ConnectionJDBC) statement.getConnection();\n    } <s> private JtdsConnection getConnection() throws SQLException {         return (JtdsConnection) statement.getConnection();     }"}
{"source": "Searches an array of methods for a match against the given operation <s> public static Method findMethod(Operation<?> operation, Method[] methods) {\n        for (Method method : methods) {\n            if (match(operation, method)) {\n                return method;\n            }\n        }\n        return null;\n    } <s> public static <T> Method findMethod(Class<?> implClass, Operation<T> operation) throws NoSuchMethodException {         String name = operation.getName();         Class<?>[] paramTypes = getPhysicalTypes(operation);         return implClass.getMethod(name, paramTypes);     }"}
{"source": "Marshall JSON metadata into a new Widget instance <s> public static Widget getWidget(String metadata, String shindig) throws Exception{\n\t\tJSONObject gadget = null;\n\t\tWidget widget = null;\n\t\tJSONObject response = new JSONObject(metadata);\n\t\tJSONArray gadgets = response.getJSONArray(\"gadgets\");\n\t\tif (gadgets.length() > 0){\n\t\t\tgadget = gadgets.getJSONObject(0);\n\t\t\tif (gadget.has(\"errors\")) throw new Exception(\"Invalid gadget - Shindig error\");\n\t\t\t\n\t\t\twidget = new Widget();\n\t\t\t// Defaults\n\t\t\tString title = \"Untitled Gadget\";\n\t\t\tint height = 200;\n\t\t\tint width = 320;\n\t\t\tString author = \"Unknown Author\";\n\t\t\tString description = \"Google Gadget\";\n\t\t\tString icon = DEFAULT_ICON;\n\n\t\t\tif (!gadget.has(\"url\")) throw new Exception(\"Invalid gadget - URL missing\");\n\t\t\tif (gadget.getString(\"url\") == null || gadget.getString(\"url\").equals(\"\")) throw new Exception(\"Invalid gadget - Invalid URL\");\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unused\")\n\t\t\t\tURL url = new URL(gadget.getString(\"url\"));\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new Exception(\"Invalid gadget - invalid URL\");\n\t\t\t}\n\n\t\t\t// Use the URL as the GUID\n\t\t\twidget.setGuid(gadget.getString(\"url\"));\n\n\t\t\t// We should be able to use the \"iframeUrl\" property here, but\n\t\t\t// it isn't very reliable at generating a usable value, so we construct\n\t\t\t// a very basic URL instead\n\t\t\tStartFile sf = new StartFile();\n\t\t\tsf.setWidget(widget);\n\t\t\t// FIXME we need to use real locales in these URLs\n\t\t\tsf.setUrl(shindig+\"/gadgets/ifr?url=\"+gadget.get <s> public static W3CWidget getWidget(String metadata, String shindig) throws Exception{ \t\tJSONObject gadget = null; \t\tJSONObject response = new JSONObject(metadata); \t\tJSONArray gadgets = response.getJSONArray(\"gadgets\"); \t\tif (gadgets.length()==0) return null; \t\tgadget = gadgets.getJSONObject(0); \t\treturn new GadgetAdapter(gadget, shindig); \t}"}
{"source": "Requests a GraphItem of the specified item class corresponding to a given Entity, optionally creating the GraphItem if it doesn't already exist. <s> public synchronized GraphItem getItem(String itemClass, Entity entity, boolean create) {\n\t\tItemEntry entry = (ItemEntry)m_entryMap.get(itemClass);\n\t\tif ( entry != null ) {\n\t\t\tGraphItem item = (GraphItem)entry.itemMap.get(entity);\n\t\t\tif ( !create ) {\n\t\t\t\treturn item;\n\t\t\t} else if ( item == null ) {\n\t\t\t\titem = m_ifactory.getItem(itemClass);\n\t\t\t\titem.init(this, itemClass, entity);\n\t\t\t\taddItem(entry, entity, item);\n\t\t\t}\n            if ( item instanceof NodeItem )\n                ((NodeItem)item).removeAllNeighbors();\n            item.setDirty(0);\n            item.setVisible(true);\n\t\t\treturn item;\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"The input string must be a\"\n\t\t\t\t\t\t+ \" recognized item class!\");\n\t\t}\t\t\n\t} // <s> public synchronized VisualItem getItem(String itemClass, Entity entity, boolean create) { \t\tItemEntry entry = (ItemEntry)m_entryMap.get(itemClass); \t\tif ( entry != null ) { \t\t\tVisualItem item = (VisualItem)entry.itemMap.get(entity); \t\t\tif ( !create ) { \t\t\t\treturn item; \t\t\t} else if ( item == null ) { \t\t\t\titem = m_ifactory.getItem(itemClass); \t\t\t\titem.init(this, itemClass, entity); \t\t\t\taddItem(entry, entity, item); \t\t\t}             if ( item instanceof NodeItem )                 ((NodeItem)item).removeAllNeighbors();             item.setDirty(0);             item.setVisible(true); \t\t\treturn item; \t\t} else { \t\t\tthrow new IllegalArgumentException(\"The input string must be a\" \t\t\t\t\t\t+ \" recognized item class!\"); \t\t}\t\t \t} //"}
{"source": "Performs the actual authentication of the user by connecting to the LDAP server, querying it for user information, and returning an  ActiveDirectoryInfo instance containing the results. <s> protected ActiveDirectoryInfo performAuthentication(String username, char[] password) {\n\n        if( searchBase == null ) {\n            throw new IllegalStateException( \"A search base must be specified.\" );\n        }\n        if( url == null ) {\n            throw new IllegalStateException( \"An LDAP URL must be specified of the form ldap://<hostname>:<port>\" );\n        }\n\n\n        if( principalSuffix != null ) {\n            username = username + principalSuffix;\n        }\n\n        Hashtable<String, String> env = new Hashtable<String, String>(6);\n\n        env.put(Context.SECURITY_AUTHENTICATION, authentication);\n        env.put(Context.SECURITY_PRINCIPAL, username);\n        env.put(Context.SECURITY_CREDENTIALS, new String( password ));\n        env.put(Context.INITIAL_CONTEXT_FACTORY, contextFactory);\n        env.put(Context.PROVIDER_URL, url);\n        env.put(Context.REFERRAL, refferal);\n\n        if (log.isDebugEnabled()) {\n            log.debug( \"Initializing LDAP context using environment properties [\" + env + \"]\" );\n        }\n\n        LdapContext ctx = null;\n        try {\n            ctx = new InitialLdapContext(env, null);\n\n            return getActiveDirectoryInfo(username, ctx);\n\n\n        } catch (javax.naming.AuthenticationException e) {\n            throw new IncorrectCredentialException( \"User could not be authenticated with LDAP server.\", e );\n\n        } catch (NamingException e) {\n            throw new AuthenticationException( \"LDAP naming error while attempting to authenticate user.\", e );\n\n        } finally {\n            // Always close the LDAP context\n            try {\n                if (ctx != null) {\n                    ctx.close();\n                }\n            } catch <s> protected LdapDirectoryInfo performAuthentication(String username, char[] password) {          if( searchBase == null ) {             throw new IllegalStateException( \"A search base must be specified.\" );         }         if( url == null ) {             throw new IllegalStateException( \"An LDAP URL must be specified of the form ldap://<hostname>:<port>\" );         }           if( principalSuffix != null ) {             username = username + principalSuffix;         }          Hashtable<String, String> env = new Hashtable<String, String>(6);          env.put(Context.SECURITY_AUTHENTICATION, authentication);         env.put(Context.SECURITY_PRINCIPAL, username);         env.put(Context.SECURITY_CREDENTIALS, new String( password ));         env.put(Context.INITIAL_CONTEXT_FACTORY, contextFactory);         env.put(Context.PROVIDER_URL, url);         env.put(Context.REFERRAL, refferal);          if (log.isDebugEnabled()) {             log.debug( \"Initializing LDAP context using environment properties [\" + env + \"]\" );         }          LdapContext ctx = null;         try {             ctx = new InitialLdapContext(env, null);              return getLdapDirectoryInfo(username, ctx);           } catch (javax.naming.AuthenticationException e) {             throw new IncorrectCredentialException( \"User could not be authenticated with LDAP server.\", e );          } catch (NamingException e) {             throw new AuthenticationException( \"LDAP naming error while attempting to authenticate user.\", e );          } finally {             // Always close the LDAP context             try {                 if (ctx != null) {                     ctx.close();                 }             }"}
{"source": "Return a DERObject containing the encoded certificate. <s> private DERObject toASN1Object(\n        X509Certificate cert)\n        throws CertificateEncodingException\n    {\n        try\n        {\n            return new ASN1InputStream(cert.getEncoded()).readObject();\n        }\n        catch (Exception e)\n        {\n            throw new CertificateEncodingException(\"Exception while encoding certificate: \" + e.toString());\n        }\n    } <s> private ASN1Object toASN1Object(         X509Certificate cert)         throws CertificateEncodingException     {         try         {             return new ASN1InputStream(cert.getEncoded()).readObject();         }         catch (Exception e)         {             throw new CertificateEncodingException(\"Exception while encoding certificate: \" + e.toString());         }     }"}
{"source": "Create a new request queue, using NoHttp default request executor  HttpRestConnection and default response parser  HttpRestParser. <s> public static RequestQueue newRequestQueue(ImplRestConnection implRestConnection, int threadPoolSize) {\n        return newRequestQueue(HttpRestParser.getInstance(implRestConnection), threadPoolSize);\n    } <s> public static RequestQueue newRequestQueue(IRestProtocol implRestConnection, int threadPoolSize) {         return newRequestQueue(RestParser.getInstance(implRestConnection), threadPoolSize);     }"}
{"source": "Applies  predicate to each item <s> public <P extends Visitor<? super X>> P visit(P predicate)\n    {\n        for (X x : this) {\n            predicate.visit(x);\n        }\n\n        return predicate;\n    } <s> public <V extends Visitor<? super X>> V visit(V visitor)     {         for (X x : this) {             visitor.visit(x);         }          return visitor;     }"}
{"source": "Returns the  ConnectionService.VideoCallProvider for the connection. <s> public ConnectionService.VideoCallProvider getVideoCallProvider() {\n        return mVideoCallProvider;\n    } <s> public VideoCallProvider getVideoCallProvider() {         return mVideoCallProvider;     }"}
{"source": "Returns the message id header value of a SIP request <s> public static String getMessageId(SipRequest request) {\r\n\t\t// Read ID from Message-Id header\r\n\t\tExtensionHeader messageIdHeader = (ExtensionHeader)request.getHeader(ImdnUtils.HEADER_IMDN_MSG_ID);\r\n\t\tif (messageIdHeader != null) {\r\n\t\t\treturn messageIdHeader.getValue();\r\n\t\t} \r\n\t\t\r\n\t\t// Read ID from multipart content\r\n\t\ttry {\r\n\t\t    String content = request.getContent();\r\n\t\t\tint index = content.indexOf(ImdnUtils.HEADER_IMDN_MSG_ID);\r\n\t\t\tif (index != -1) {\r\n\t\t\t\tindex = index+ImdnUtils.HEADER_IMDN_MSG_ID.length()+1;\r\n\t\t\t\tString part = content.substring(index);\r\n\t\t\t\tString msgId = part.substring(0, part.indexOf(SipUtils.CRLF));\r\n\t\t\t\treturn msgId.trim();\r\n\t\t\t}\r\n\t\t} catch(Exception e) {\r\n\t\t}\r\n\t\t\r\n\t\t// No message id\r\n\t\treturn null;\r\n\t} <s> public static String getMessageId(SipRequest request) {\r \t\tString result = null;\r \t\ttry {\r \t\t\t// Read ID from multipart content\r \t\t    String content = request.getContent();\r \t\t\tint index = content.indexOf(ImdnUtils.HEADER_IMDN_MSG_ID);\r \t\t\tif (index != -1) {\r \t\t\t\tindex = index+ImdnUtils.HEADER_IMDN_MSG_ID.length()+1;\r \t\t\t\tString part = content.substring(index);\r \t\t\t\tString msgId = part.substring(0, part.indexOf(CRLF));\r \t\t\t\tresult = msgId.trim();\r \t\t\t}\r \t\t} catch(Exception e) {\r \t\t}\r \t\treturn result;\r \t}"}
{"source": "Return a  FilteredEnvironment for the calling user. <s> public static FxEnvironment getFilteredEnvironment() {\n        return new FilteredEnvironment(getEnvironment());\n    } <s> public static FxEnvironment getFilteredEnvironment() {         return new FxFilteredEnvironment(getEnvironment());     }"}
{"source": "Index of terminal to show after closing indicated terminal index <s> private int terminalToShowWhenClosing(int terminalClosing)\n   {\n      if (terminalClosing > 0)\n         return terminalClosing - 1;\n      else if (terminalClosing + 1 < getTerminalCount())\n         return terminalClosing + 1;\n      else\n         return -1;\n   } <s> private String terminalToShowWhenClosing(String handle)    {       int terminalClosing = terminals_.indexOfTerminal(handle);       if (terminalClosing > 0)          return terminals_.terminalHandleAtIndex(terminalClosing - 1);       else if (terminalClosing + 1 < terminals_.terminalCount())          return terminals_.terminalHandleAtIndex(terminalClosing + 1);       else          return null;    }"}
{"source": "Gets a Map of distances for a specific run and year. <s> public Map getDistancesMap(Group run, String year) {\n\t\tIWContext iwc = IWContext.getInstance();\n\t\tMap disMap = new LinkedHashMap();\n\t\tCollection distances = null;\n\t\tCollection type = new ArrayList();\n\t\ttype.add(IWMarathonConstants.GROUP_TYPE_RUN_DISTANCE);\n\t\tIterator yearsIter = getYears(run).iterator();\n\t\twhile (yearsIter.hasNext()) {\n\t\t\tGroup y = (Group) yearsIter.next();\n\t\t\tif (y.getName().equals(year)) {\n\t\t\t\ttry {\n\t\t\t\t\tdistances = getGroupBiz(iwc).getChildGroupsRecursiveResultFiltered(y, type, true);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tdistances = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdistances = null;\n\t\t\t}\n\t\t}\n\t\tif (distances != null) {\n\t\t\tIterator disIter = distances.iterator();\n\t\t\twhile (disIter.hasNext()) {\n\t\t\t\tGroup dis = (Group) disIter.next();\n\t\t\t\tdisMap.put(dis.getPrimaryKey().toString(), dis.getName());\n\t\t\t}\n\t\t}\n\t\treturn disMap;\n\t} <s> public Collection getDistancesMap(Group run, String year) { \t\tIWContext iwc = IWContext.getInstance(); \t\tMap disMap = new LinkedHashMap(); \t\tCollection distances = null; \t\tCollection type = new ArrayList(); \t\ttype.add(IWMarathonConstants.GROUP_TYPE_RUN_DISTANCE); \t\tIterator yearsIter = getYears(run).iterator(); \t\twhile (yearsIter.hasNext()) { \t\t\tGroup y = (Group) yearsIter.next(); \t\t\tif (y.getName().equals(year)) { \t\t\t\ttry { \t\t\t\t\tdistances = getGroupBiz(iwc).getChildGroupsRecursiveResultFiltered(y, type, true); \t\t\t\t} \t\t\t\tcatch (Exception e) { \t\t\t\t\tdistances = null; \t\t\t\t} \t\t\t} \t\t} \t\treturn distances; \t}"}
{"source": "Checks whether this ChatSection's argument can be parsed as a boolean <s> public boolean isBoolean() {\n        return arg.equals(\"true\") || arg.equals(\"false\");\n    } <s> public boolean isBoolean() {         return raw.equals(\"true\") || raw.equals(\"false\");     }"}
